(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global["tc-data-supplier"] = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports$1 (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$1 = function(d, b) {
	    extendStatics$1 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	    return extendStatics$1(d, b);
	};

	function __extends$1(d, b) {
	    if (typeof b !== "function" && b !== null)
	        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    extendStatics$1(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	function __awaiter(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __values(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	function __spreadArray(to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	}

	function __await(v) {
	    return this instanceof __await ? (this.v = v, this) : new __await(v);
	}

	function __asyncGenerator(thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	}

	function __asyncValues(o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	}

	function isFunction$1(value) {
	    return typeof value === 'function';
	}

	function createErrorClass(createImpl) {
	    var _super = function (instance) {
	        Error.call(instance);
	        instance.stack = new Error().stack;
	    };
	    var ctorFunc = createImpl(_super);
	    ctorFunc.prototype = Object.create(Error.prototype);
	    ctorFunc.prototype.constructor = ctorFunc;
	    return ctorFunc;
	}

	var UnsubscriptionError$1 = createErrorClass(function (_super) {
	    return function UnsubscriptionErrorImpl(errors) {
	        _super(this);
	        this.message = errors
	            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
	            : '';
	        this.name = 'UnsubscriptionError';
	        this.errors = errors;
	    };
	});

	function arrRemove(arr, item) {
	    if (arr) {
	        var index = arr.indexOf(item);
	        0 <= index && arr.splice(index, 1);
	    }
	}

	var Subscription$1 = (function () {
	    function Subscription(initialTeardown) {
	        this.initialTeardown = initialTeardown;
	        this.closed = false;
	        this._parentage = null;
	        this._finalizers = null;
	    }
	    Subscription.prototype.unsubscribe = function () {
	        var e_1, _a, e_2, _b;
	        var errors;
	        if (!this.closed) {
	            this.closed = true;
	            var _parentage = this._parentage;
	            if (_parentage) {
	                this._parentage = null;
	                if (Array.isArray(_parentage)) {
	                    try {
	                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
	                            var parent_1 = _parentage_1_1.value;
	                            parent_1.remove(this);
	                        }
	                    }
	                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                    finally {
	                        try {
	                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
	                        }
	                        finally { if (e_1) throw e_1.error; }
	                    }
	                }
	                else {
	                    _parentage.remove(this);
	                }
	            }
	            var initialFinalizer = this.initialTeardown;
	            if (isFunction$1(initialFinalizer)) {
	                try {
	                    initialFinalizer();
	                }
	                catch (e) {
	                    errors = e instanceof UnsubscriptionError$1 ? e.errors : [e];
	                }
	            }
	            var _finalizers = this._finalizers;
	            if (_finalizers) {
	                this._finalizers = null;
	                try {
	                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
	                        var finalizer = _finalizers_1_1.value;
	                        try {
	                            execFinalizer(finalizer);
	                        }
	                        catch (err) {
	                            errors = errors !== null && errors !== void 0 ? errors : [];
	                            if (err instanceof UnsubscriptionError$1) {
	                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
	                            }
	                            else {
	                                errors.push(err);
	                            }
	                        }
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	            }
	            if (errors) {
	                throw new UnsubscriptionError$1(errors);
	            }
	        }
	    };
	    Subscription.prototype.add = function (teardown) {
	        var _a;
	        if (teardown && teardown !== this) {
	            if (this.closed) {
	                execFinalizer(teardown);
	            }
	            else {
	                if (teardown instanceof Subscription) {
	                    if (teardown.closed || teardown._hasParent(this)) {
	                        return;
	                    }
	                    teardown._addParent(this);
	                }
	                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
	            }
	        }
	    };
	    Subscription.prototype._hasParent = function (parent) {
	        var _parentage = this._parentage;
	        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _parentage = this._parentage;
	        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
	    };
	    Subscription.prototype._removeParent = function (parent) {
	        var _parentage = this._parentage;
	        if (_parentage === parent) {
	            this._parentage = null;
	        }
	        else if (Array.isArray(_parentage)) {
	            arrRemove(_parentage, parent);
	        }
	    };
	    Subscription.prototype.remove = function (teardown) {
	        var _finalizers = this._finalizers;
	        _finalizers && arrRemove(_finalizers, teardown);
	        if (teardown instanceof Subscription) {
	            teardown._removeParent(this);
	        }
	    };
	    Subscription.EMPTY = (function () {
	        var empty = new Subscription();
	        empty.closed = true;
	        return empty;
	    })();
	    return Subscription;
	}());
	var EMPTY_SUBSCRIPTION = Subscription$1.EMPTY;
	function isSubscription(value) {
	    return (value instanceof Subscription$1 ||
	        (value && 'closed' in value && isFunction$1(value.remove) && isFunction$1(value.add) && isFunction$1(value.unsubscribe)));
	}
	function execFinalizer(finalizer) {
	    if (isFunction$1(finalizer)) {
	        finalizer();
	    }
	    else {
	        finalizer.unsubscribe();
	    }
	}

	var config$1 = {
	    onUnhandledError: null,
	    onStoppedNotification: null,
	    Promise: undefined,
	    useDeprecatedSynchronousErrorHandling: false,
	    useDeprecatedNextContext: false,
	};

	var timeoutProvider = {
	    setTimeout: function (handler, timeout) {
	        var args = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            args[_i - 2] = arguments[_i];
	        }
	        var delegate = timeoutProvider.delegate;
	        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
	            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
	        }
	        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
	    },
	    clearTimeout: function (handle) {
	        var delegate = timeoutProvider.delegate;
	        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
	    },
	    delegate: undefined,
	};

	function reportUnhandledError(err) {
	    timeoutProvider.setTimeout(function () {
	        var onUnhandledError = config$1.onUnhandledError;
	        if (onUnhandledError) {
	            onUnhandledError(err);
	        }
	        else {
	            throw err;
	        }
	    });
	}

	function noop$1() { }

	var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
	function errorNotification(error) {
	    return createNotification('E', undefined, error);
	}
	function nextNotification(value) {
	    return createNotification('N', value, undefined);
	}
	function createNotification(kind, value, error) {
	    return {
	        kind: kind,
	        value: value,
	        error: error,
	    };
	}

	var context = null;
	function errorContext(cb) {
	    if (config$1.useDeprecatedSynchronousErrorHandling) {
	        var isRoot = !context;
	        if (isRoot) {
	            context = { errorThrown: false, error: null };
	        }
	        cb();
	        if (isRoot) {
	            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
	            context = null;
	            if (errorThrown) {
	                throw error;
	            }
	        }
	    }
	    else {
	        cb();
	    }
	}
	function captureError(err) {
	    if (config$1.useDeprecatedSynchronousErrorHandling && context) {
	        context.errorThrown = true;
	        context.error = err;
	    }
	}

	var Subscriber$1 = (function (_super) {
	    __extends$1(Subscriber, _super);
	    function Subscriber(destination) {
	        var _this = _super.call(this) || this;
	        _this.isStopped = false;
	        if (destination) {
	            _this.destination = destination;
	            if (isSubscription(destination)) {
	                destination.add(_this);
	            }
	        }
	        else {
	            _this.destination = EMPTY_OBSERVER;
	        }
	        return _this;
	    }
	    Subscriber.create = function (next, error, complete) {
	        return new SafeSubscriber$1(next, error, complete);
	    };
	    Subscriber.prototype.next = function (value) {
	        if (this.isStopped) {
	            handleStoppedNotification(nextNotification(value), this);
	        }
	        else {
	            this._next(value);
	        }
	    };
	    Subscriber.prototype.error = function (err) {
	        if (this.isStopped) {
	            handleStoppedNotification(errorNotification(err), this);
	        }
	        else {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    Subscriber.prototype.complete = function () {
	        if (this.isStopped) {
	            handleStoppedNotification(COMPLETE_NOTIFICATION, this);
	        }
	        else {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (!this.closed) {
	            this.isStopped = true;
	            _super.prototype.unsubscribe.call(this);
	            this.destination = null;
	        }
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        try {
	            this.destination.error(err);
	        }
	        finally {
	            this.unsubscribe();
	        }
	    };
	    Subscriber.prototype._complete = function () {
	        try {
	            this.destination.complete();
	        }
	        finally {
	            this.unsubscribe();
	        }
	    };
	    return Subscriber;
	}(Subscription$1));
	var _bind = Function.prototype.bind;
	function bind(fn, thisArg) {
	    return _bind.call(fn, thisArg);
	}
	var ConsumerObserver = (function () {
	    function ConsumerObserver(partialObserver) {
	        this.partialObserver = partialObserver;
	    }
	    ConsumerObserver.prototype.next = function (value) {
	        var partialObserver = this.partialObserver;
	        if (partialObserver.next) {
	            try {
	                partialObserver.next(value);
	            }
	            catch (error) {
	                handleUnhandledError(error);
	            }
	        }
	    };
	    ConsumerObserver.prototype.error = function (err) {
	        var partialObserver = this.partialObserver;
	        if (partialObserver.error) {
	            try {
	                partialObserver.error(err);
	            }
	            catch (error) {
	                handleUnhandledError(error);
	            }
	        }
	        else {
	            handleUnhandledError(err);
	        }
	    };
	    ConsumerObserver.prototype.complete = function () {
	        var partialObserver = this.partialObserver;
	        if (partialObserver.complete) {
	            try {
	                partialObserver.complete();
	            }
	            catch (error) {
	                handleUnhandledError(error);
	            }
	        }
	    };
	    return ConsumerObserver;
	}());
	var SafeSubscriber$1 = (function (_super) {
	    __extends$1(SafeSubscriber, _super);
	    function SafeSubscriber(observerOrNext, error, complete) {
	        var _this = _super.call(this) || this;
	        var partialObserver;
	        if (isFunction$1(observerOrNext) || !observerOrNext) {
	            partialObserver = {
	                next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
	                error: error !== null && error !== void 0 ? error : undefined,
	                complete: complete !== null && complete !== void 0 ? complete : undefined,
	            };
	        }
	        else {
	            var context_1;
	            if (_this && config$1.useDeprecatedNextContext) {
	                context_1 = Object.create(observerOrNext);
	                context_1.unsubscribe = function () { return _this.unsubscribe(); };
	                partialObserver = {
	                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
	                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
	                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
	                };
	            }
	            else {
	                partialObserver = observerOrNext;
	            }
	        }
	        _this.destination = new ConsumerObserver(partialObserver);
	        return _this;
	    }
	    return SafeSubscriber;
	}(Subscriber$1));
	function handleUnhandledError(error) {
	    if (config$1.useDeprecatedSynchronousErrorHandling) {
	        captureError(error);
	    }
	    else {
	        reportUnhandledError(error);
	    }
	}
	function defaultErrorHandler(err) {
	    throw err;
	}
	function handleStoppedNotification(notification, subscriber) {
	    var onStoppedNotification = config$1.onStoppedNotification;
	    onStoppedNotification && timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
	}
	var EMPTY_OBSERVER = {
	    closed: true,
	    next: noop$1,
	    error: defaultErrorHandler,
	    complete: noop$1,
	};

	var observable$1 = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

	function identity$2(x) {
	    return x;
	}

	function pipe$1() {
	    var fns = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        fns[_i] = arguments[_i];
	    }
	    return pipeFromArray$1(fns);
	}
	function pipeFromArray$1(fns) {
	    if (fns.length === 0) {
	        return identity$2;
	    }
	    if (fns.length === 1) {
	        return fns[0];
	    }
	    return function piped(input) {
	        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
	    };
	}

	var Observable$1 = (function () {
	    function Observable(subscribe) {
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var _this = this;
	        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber$1(observerOrNext, error, complete);
	        errorContext(function () {
	            var _a = _this, operator = _a.operator, source = _a.source;
	            subscriber.add(operator
	                ?
	                    operator.call(subscriber, source)
	                : source
	                    ?
	                        _this._subscribe(subscriber)
	                    :
	                        _this._trySubscribe(subscriber));
	        });
	        return subscriber;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.error(err);
	        }
	    };
	    Observable.prototype.forEach = function (next, promiseCtor) {
	        var _this = this;
	        promiseCtor = getPromiseCtor$1(promiseCtor);
	        return new promiseCtor(function (resolve, reject) {
	            var subscriber = new SafeSubscriber$1({
	                next: function (value) {
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscriber.unsubscribe();
	                    }
	                },
	                error: reject,
	                complete: resolve,
	            });
	            _this.subscribe(subscriber);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        var _a;
	        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
	    };
	    Observable.prototype[observable$1] = function () {
	        return this;
	    };
	    Observable.prototype.pipe = function () {
	        var operations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operations[_i] = arguments[_i];
	        }
	        return pipeFromArray$1(operations)(this);
	    };
	    Observable.prototype.toPromise = function (promiseCtor) {
	        var _this = this;
	        promiseCtor = getPromiseCtor$1(promiseCtor);
	        return new promiseCtor(function (resolve, reject) {
	            var value;
	            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
	        });
	    };
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	function getPromiseCtor$1(promiseCtor) {
	    var _a;
	    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$1.Promise) !== null && _a !== void 0 ? _a : Promise;
	}
	function isObserver(value) {
	    return value && isFunction$1(value.next) && isFunction$1(value.error) && isFunction$1(value.complete);
	}
	function isSubscriber(value) {
	    return (value && value instanceof Subscriber$1) || (isObserver(value) && isSubscription(value));
	}

	function hasLift(source) {
	    return isFunction$1(source === null || source === void 0 ? void 0 : source.lift);
	}
	function operate(init) {
	    return function (source) {
	        if (hasLift(source)) {
	            return source.lift(function (liftedSource) {
	                try {
	                    return init(liftedSource, this);
	                }
	                catch (err) {
	                    this.error(err);
	                }
	            });
	        }
	        throw new TypeError('Unable to lift unknown Observable type');
	    };
	}

	function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
	    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
	}
	var OperatorSubscriber = (function (_super) {
	    __extends$1(OperatorSubscriber, _super);
	    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
	        var _this = _super.call(this, destination) || this;
	        _this.onFinalize = onFinalize;
	        _this.shouldUnsubscribe = shouldUnsubscribe;
	        _this._next = onNext
	            ? function (value) {
	                try {
	                    onNext(value);
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	            }
	            : _super.prototype._next;
	        _this._error = onError
	            ? function (err) {
	                try {
	                    onError(err);
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	                finally {
	                    this.unsubscribe();
	                }
	            }
	            : _super.prototype._error;
	        _this._complete = onComplete
	            ? function () {
	                try {
	                    onComplete();
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	                finally {
	                    this.unsubscribe();
	                }
	            }
	            : _super.prototype._complete;
	        return _this;
	    }
	    OperatorSubscriber.prototype.unsubscribe = function () {
	        var _a;
	        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
	            var closed_1 = this.closed;
	            _super.prototype.unsubscribe.call(this);
	            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
	        }
	    };
	    return OperatorSubscriber;
	}(Subscriber$1));

	function refCount$1() {
	    return operate(function (source, subscriber) {
	        var connection = null;
	        source._refCount++;
	        var refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {
	            if (!source || source._refCount <= 0 || 0 < --source._refCount) {
	                connection = null;
	                return;
	            }
	            var sharedConnection = source._connection;
	            var conn = connection;
	            connection = null;
	            if (sharedConnection && (!conn || sharedConnection === conn)) {
	                sharedConnection.unsubscribe();
	            }
	            subscriber.unsubscribe();
	        });
	        source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            connection = source.connect();
	        }
	    });
	}

	var ConnectableObservable$1 = (function (_super) {
	    __extends$1(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        var _this = _super.call(this) || this;
	        _this.source = source;
	        _this.subjectFactory = subjectFactory;
	        _this._subject = null;
	        _this._refCount = 0;
	        _this._connection = null;
	        if (hasLift(source)) {
	            _this.lift = source.lift;
	        }
	        return _this;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype._teardown = function () {
	        this._refCount = 0;
	        var _connection = this._connection;
	        this._subject = this._connection = null;
	        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var _this = this;
	        var connection = this._connection;
	        if (!connection) {
	            connection = this._connection = new Subscription$1();
	            var subject_1 = this.getSubject();
	            connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, undefined, function () {
	                _this._teardown();
	                subject_1.complete();
	            }, function (err) {
	                _this._teardown();
	                subject_1.error(err);
	            }, function () { return _this._teardown(); })));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription$1.EMPTY;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return refCount$1()(this);
	    };
	    return ConnectableObservable;
	}(Observable$1));

	var performanceTimestampProvider = {
	    now: function () {
	        return (performanceTimestampProvider.delegate || performance).now();
	    },
	    delegate: undefined,
	};

	var animationFrameProvider = {
	    schedule: function (callback) {
	        var request = requestAnimationFrame;
	        var cancel = cancelAnimationFrame;
	        var delegate = animationFrameProvider.delegate;
	        if (delegate) {
	            request = delegate.requestAnimationFrame;
	            cancel = delegate.cancelAnimationFrame;
	        }
	        var handle = request(function (timestamp) {
	            cancel = undefined;
	            callback(timestamp);
	        });
	        return new Subscription$1(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });
	    },
	    requestAnimationFrame: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var delegate = animationFrameProvider.delegate;
	        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
	    },
	    cancelAnimationFrame: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var delegate = animationFrameProvider.delegate;
	        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
	    },
	    delegate: undefined,
	};

	function animationFrames(timestampProvider) {
	    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
	}
	function animationFramesFactory(timestampProvider) {
	    var schedule = animationFrameProvider.schedule;
	    return new Observable$1(function (subscriber) {
	        var subscription = new Subscription$1();
	        var provider = timestampProvider || performanceTimestampProvider;
	        var start = provider.now();
	        var run = function (timestamp) {
	            var now = provider.now();
	            subscriber.next({
	                timestamp: timestampProvider ? now : timestamp,
	                elapsed: now - start,
	            });
	            if (!subscriber.closed) {
	                subscription.add(schedule(run));
	            }
	        };
	        subscription.add(schedule(run));
	        return subscription;
	    });
	}
	var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

	var ObjectUnsubscribedError$1 = createErrorClass(function (_super) {
	    return function ObjectUnsubscribedErrorImpl() {
	        _super(this);
	        this.name = 'ObjectUnsubscribedError';
	        this.message = 'object unsubscribed';
	    };
	});

	var Subject$1 = (function (_super) {
	    __extends$1(Subject, _super);
	    function Subject() {
	        var _this = _super.call(this) || this;
	        _this.closed = false;
	        _this.currentObservers = null;
	        _this.observers = [];
	        _this.isStopped = false;
	        _this.hasError = false;
	        _this.thrownError = null;
	        return _this;
	    }
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject$1(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype._throwIfClosed = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError$1();
	        }
	    };
	    Subject.prototype.next = function (value) {
	        var _this = this;
	        errorContext(function () {
	            var e_1, _a;
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                if (!_this.currentObservers) {
	                    _this.currentObservers = Array.from(_this.observers);
	                }
	                try {
	                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
	                        var observer = _c.value;
	                        observer.next(value);
	                    }
	                }
	                catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                finally {
	                    try {
	                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                    }
	                    finally { if (e_1) throw e_1.error; }
	                }
	            }
	        });
	    };
	    Subject.prototype.error = function (err) {
	        var _this = this;
	        errorContext(function () {
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                _this.hasError = _this.isStopped = true;
	                _this.thrownError = err;
	                var observers = _this.observers;
	                while (observers.length) {
	                    observers.shift().error(err);
	                }
	            }
	        });
	    };
	    Subject.prototype.complete = function () {
	        var _this = this;
	        errorContext(function () {
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                _this.isStopped = true;
	                var observers = _this.observers;
	                while (observers.length) {
	                    observers.shift().complete();
	                }
	            }
	        });
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = this.closed = true;
	        this.observers = this.currentObservers = null;
	    };
	    Object.defineProperty(Subject.prototype, "observed", {
	        get: function () {
	            var _a;
	            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Subject.prototype._trySubscribe = function (subscriber) {
	        this._throwIfClosed();
	        return _super.prototype._trySubscribe.call(this, subscriber);
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        this._throwIfClosed();
	        this._checkFinalizedStatuses(subscriber);
	        return this._innerSubscribe(subscriber);
	    };
	    Subject.prototype._innerSubscribe = function (subscriber) {
	        var _this = this;
	        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
	        if (hasError || isStopped) {
	            return EMPTY_SUBSCRIPTION;
	        }
	        this.currentObservers = null;
	        observers.push(subscriber);
	        return new Subscription$1(function () {
	            _this.currentObservers = null;
	            arrRemove(observers, subscriber);
	        });
	    };
	    Subject.prototype._checkFinalizedStatuses = function (subscriber) {
	        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
	        if (hasError) {
	            subscriber.error(thrownError);
	        }
	        else if (isStopped) {
	            subscriber.complete();
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable$1();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject$1(destination, source);
	    };
	    return Subject;
	}(Observable$1));
	var AnonymousSubject$1 = (function (_super) {
	    __extends$1(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        var _this = _super.call(this) || this;
	        _this.destination = destination;
	        _this.source = source;
	        return _this;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var _a, _b;
	        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
	    };
	    return AnonymousSubject;
	}(Subject$1));

	var BehaviorSubject$1 = (function (_super) {
	    __extends$1(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        var _this = _super.call(this) || this;
	        _this._value = _value;
	        return _this;
	    }
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: false,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        !subscription.closed && subscriber.next(this._value);
	        return subscription;
	    };
	    BehaviorSubject.prototype.getValue = function () {
	        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
	        if (hasError) {
	            throw thrownError;
	        }
	        this._throwIfClosed();
	        return _value;
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, (this._value = value));
	    };
	    return BehaviorSubject;
	}(Subject$1));

	var dateTimestampProvider = {
	    now: function () {
	        return (dateTimestampProvider.delegate || Date).now();
	    },
	    delegate: undefined,
	};

	var ReplaySubject$1 = (function (_super) {
	    __extends$1(ReplaySubject, _super);
	    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
	        if (_bufferSize === void 0) { _bufferSize = Infinity; }
	        if (_windowTime === void 0) { _windowTime = Infinity; }
	        if (_timestampProvider === void 0) { _timestampProvider = dateTimestampProvider; }
	        var _this = _super.call(this) || this;
	        _this._bufferSize = _bufferSize;
	        _this._windowTime = _windowTime;
	        _this._timestampProvider = _timestampProvider;
	        _this._buffer = [];
	        _this._infiniteTimeWindow = true;
	        _this._infiniteTimeWindow = _windowTime === Infinity;
	        _this._bufferSize = Math.max(1, _bufferSize);
	        _this._windowTime = Math.max(1, _windowTime);
	        return _this;
	    }
	    ReplaySubject.prototype.next = function (value) {
	        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
	        if (!isStopped) {
	            _buffer.push(value);
	            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
	        }
	        this._trimBuffer();
	        _super.prototype.next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        this._throwIfClosed();
	        this._trimBuffer();
	        var subscription = this._innerSubscribe(subscriber);
	        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
	        var copy = _buffer.slice();
	        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
	            subscriber.next(copy[i]);
	        }
	        this._checkFinalizedStatuses(subscriber);
	        return subscription;
	    };
	    ReplaySubject.prototype._trimBuffer = function () {
	        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
	        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
	        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
	        if (!_infiniteTimeWindow) {
	            var now = _timestampProvider.now();
	            var last = 0;
	            for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
	                last = i;
	            }
	            last && _buffer.splice(0, last + 1);
	        }
	    };
	    return ReplaySubject;
	}(Subject$1));

	var AsyncSubject$1 = (function (_super) {
	    __extends$1(AsyncSubject, _super);
	    function AsyncSubject() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._value = null;
	        _this._hasValue = false;
	        _this._isComplete = false;
	        return _this;
	    }
	    AsyncSubject.prototype._checkFinalizedStatuses = function (subscriber) {
	        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
	        if (hasError) {
	            subscriber.error(thrownError);
	        }
	        else if (isStopped || _isComplete) {
	            _hasValue && subscriber.next(_value);
	            subscriber.complete();
	        }
	    };
	    AsyncSubject.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._value = value;
	            this._hasValue = true;
	        }
	    };
	    AsyncSubject.prototype.complete = function () {
	        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
	        if (!_isComplete) {
	            this._isComplete = true;
	            _hasValue && _super.prototype.next.call(this, _value);
	            _super.prototype.complete.call(this);
	        }
	    };
	    return AsyncSubject;
	}(Subject$1));

	var Action$1 = (function (_super) {
	    __extends$1(Action, _super);
	    function Action(scheduler, work) {
	        return _super.call(this) || this;
	    }
	    Action.prototype.schedule = function (state, delay) {
	        return this;
	    };
	    return Action;
	}(Subscription$1));

	var intervalProvider = {
	    setInterval: function (handler, timeout) {
	        var args = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            args[_i - 2] = arguments[_i];
	        }
	        var delegate = intervalProvider.delegate;
	        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
	            return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
	        }
	        return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
	    },
	    clearInterval: function (handle) {
	        var delegate = intervalProvider.delegate;
	        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
	    },
	    delegate: undefined,
	};

	var AsyncAction$1 = (function (_super) {
	    __extends$1(AsyncAction, _super);
	    function AsyncAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        _this.pending = false;
	        return _this;
	    }
	    AsyncAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (this.closed) {
	            return this;
	        }
	        this.state = state;
	        var id = this.id;
	        var scheduler = this.scheduler;
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, delay);
	        }
	        this.pending = true;
	        this.delay = delay;
	        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
	        return this;
	    };
	    AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
	    };
	    AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay != null && this.delay === delay && this.pending === false) {
	            return id;
	        }
	        intervalProvider.clearInterval(id);
	        return undefined;
	    };
	    AsyncAction.prototype.execute = function (state, delay) {
	        if (this.closed) {
	            return new Error('executing a cancelled action');
	        }
	        this.pending = false;
	        var error = this._execute(state, delay);
	        if (error) {
	            return error;
	        }
	        else if (this.pending === false && this.id != null) {
	            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	        }
	    };
	    AsyncAction.prototype._execute = function (state, _delay) {
	        var errored = false;
	        var errorValue;
	        try {
	            this.work(state);
	        }
	        catch (e) {
	            errored = true;
	            errorValue = e ? e : new Error('Scheduled action threw falsy error');
	        }
	        if (errored) {
	            this.unsubscribe();
	            return errorValue;
	        }
	    };
	    AsyncAction.prototype.unsubscribe = function () {
	        if (!this.closed) {
	            var _a = this, id = _a.id, scheduler = _a.scheduler;
	            var actions = scheduler.actions;
	            this.work = this.state = this.scheduler = null;
	            this.pending = false;
	            arrRemove(actions, this);
	            if (id != null) {
	                this.id = this.recycleAsyncId(scheduler, id, null);
	            }
	            this.delay = null;
	            _super.prototype.unsubscribe.call(this);
	        }
	    };
	    return AsyncAction;
	}(Action$1));

	var nextHandle$1 = 1;
	var resolved;
	var activeHandles = {};
	function findAndClearHandle(handle) {
	    if (handle in activeHandles) {
	        delete activeHandles[handle];
	        return true;
	    }
	    return false;
	}
	var Immediate$1 = {
	    setImmediate: function (cb) {
	        var handle = nextHandle$1++;
	        activeHandles[handle] = true;
	        if (!resolved) {
	            resolved = Promise.resolve();
	        }
	        resolved.then(function () { return findAndClearHandle(handle) && cb(); });
	        return handle;
	    },
	    clearImmediate: function (handle) {
	        findAndClearHandle(handle);
	    },
	};

	var setImmediate = Immediate$1.setImmediate, clearImmediate = Immediate$1.clearImmediate;
	var immediateProvider = {
	    setImmediate: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var delegate = immediateProvider.delegate;
	        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
	    },
	    clearImmediate: function (handle) {
	        var delegate = immediateProvider.delegate;
	        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
	    },
	    delegate: undefined,
	};

	var AsapAction$1 = (function (_super) {
	    __extends$1(AsapAction, _super);
	    function AsapAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.actions.push(this);
	        return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
	    };
	    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        if (!scheduler.actions.some(function (action) { return action.id === id; })) {
	            immediateProvider.clearImmediate(id);
	            scheduler._scheduled = undefined;
	        }
	        return undefined;
	    };
	    return AsapAction;
	}(AsyncAction$1));

	var Scheduler$1 = (function () {
	    function Scheduler(schedulerActionCtor, now) {
	        if (now === void 0) { now = Scheduler.now; }
	        this.schedulerActionCtor = schedulerActionCtor;
	        this.now = now;
	    }
	    Scheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) { delay = 0; }
	        return new this.schedulerActionCtor(this, work).schedule(state, delay);
	    };
	    Scheduler.now = dateTimestampProvider.now;
	    return Scheduler;
	}());

	var AsyncScheduler$1 = (function (_super) {
	    __extends$1(AsyncScheduler, _super);
	    function AsyncScheduler(SchedulerAction, now) {
	        if (now === void 0) { now = Scheduler$1.now; }
	        var _this = _super.call(this, SchedulerAction, now) || this;
	        _this.actions = [];
	        _this._active = false;
	        _this._scheduled = undefined;
	        return _this;
	    }
	    AsyncScheduler.prototype.flush = function (action) {
	        var actions = this.actions;
	        if (this._active) {
	            actions.push(action);
	            return;
	        }
	        var error;
	        this._active = true;
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions.shift()));
	        this._active = false;
	        if (error) {
	            while ((action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsyncScheduler;
	}(Scheduler$1));

	var AsapScheduler$1 = (function (_super) {
	    __extends$1(AsapScheduler, _super);
	    function AsapScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AsapScheduler.prototype.flush = function (action) {
	        this._active = true;
	        var flushId = this._scheduled;
	        this._scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        action = action || actions.shift();
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions[0]) && action.id === flushId && actions.shift());
	        this._active = false;
	        if (error) {
	            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsapScheduler;
	}(AsyncScheduler$1));

	var asapScheduler = new AsapScheduler$1(AsapAction$1);
	var asap$1 = asapScheduler;

	var asyncScheduler = new AsyncScheduler$1(AsyncAction$1);
	var async$1 = asyncScheduler;

	var QueueAction$1 = (function (_super) {
	    __extends$1(QueueAction, _super);
	    function QueueAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    QueueAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        this.scheduler.flush(this);
	        return this;
	    };
	    QueueAction.prototype.execute = function (state, delay) {
	        return (delay > 0 || this.closed) ?
	            _super.prototype.execute.call(this, state, delay) :
	            this._execute(state, delay);
	    };
	    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        return scheduler.flush(this);
	    };
	    return QueueAction;
	}(AsyncAction$1));

	var QueueScheduler$1 = (function (_super) {
	    __extends$1(QueueScheduler, _super);
	    function QueueScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return QueueScheduler;
	}(AsyncScheduler$1));

	var queueScheduler = new QueueScheduler$1(QueueAction$1);
	var queue$1 = queueScheduler;

	var AnimationFrameAction$1 = (function (_super) {
	    __extends$1(AnimationFrameAction, _super);
	    function AnimationFrameAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.actions.push(this);
	        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));
	    };
	    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        if (!scheduler.actions.some(function (action) { return action.id === id; })) {
	            animationFrameProvider.cancelAnimationFrame(id);
	            scheduler._scheduled = undefined;
	        }
	        return undefined;
	    };
	    return AnimationFrameAction;
	}(AsyncAction$1));

	var AnimationFrameScheduler$1 = (function (_super) {
	    __extends$1(AnimationFrameScheduler, _super);
	    function AnimationFrameScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AnimationFrameScheduler.prototype.flush = function (action) {
	        this._active = true;
	        var flushId = this._scheduled;
	        this._scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        action = action || actions.shift();
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions[0]) && action.id === flushId && actions.shift());
	        this._active = false;
	        if (error) {
	            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AnimationFrameScheduler;
	}(AsyncScheduler$1));

	var animationFrameScheduler = new AnimationFrameScheduler$1(AnimationFrameAction$1);
	var animationFrame$1 = animationFrameScheduler;

	var VirtualTimeScheduler$1 = (function (_super) {
	    __extends$1(VirtualTimeScheduler, _super);
	    function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {
	        if (schedulerActionCtor === void 0) { schedulerActionCtor = VirtualAction$1; }
	        if (maxFrames === void 0) { maxFrames = Infinity; }
	        var _this = _super.call(this, schedulerActionCtor, function () { return _this.frame; }) || this;
	        _this.maxFrames = maxFrames;
	        _this.frame = 0;
	        _this.index = -1;
	        return _this;
	    }
	    VirtualTimeScheduler.prototype.flush = function () {
	        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
	        var error;
	        var action;
	        while ((action = actions[0]) && action.delay <= maxFrames) {
	            actions.shift();
	            this.frame = action.delay;
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        }
	        if (error) {
	            while ((action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    VirtualTimeScheduler.frameTimeFactor = 10;
	    return VirtualTimeScheduler;
	}(AsyncScheduler$1));
	var VirtualAction$1 = (function (_super) {
	    __extends$1(VirtualAction, _super);
	    function VirtualAction(scheduler, work, index) {
	        if (index === void 0) { index = (scheduler.index += 1); }
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        _this.index = index;
	        _this.active = true;
	        _this.index = scheduler.index = index;
	        return _this;
	    }
	    VirtualAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (Number.isFinite(delay)) {
	            if (!this.id) {
	                return _super.prototype.schedule.call(this, state, delay);
	            }
	            this.active = false;
	            var action = new VirtualAction(this.scheduler, this.work);
	            this.add(action);
	            return action.schedule(state, delay);
	        }
	        else {
	            return Subscription$1.EMPTY;
	        }
	    };
	    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.delay = scheduler.frame + delay;
	        var actions = scheduler.actions;
	        actions.push(this);
	        actions.sort(VirtualAction.sortActions);
	        return true;
	    };
	    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        return undefined;
	    };
	    VirtualAction.prototype._execute = function (state, delay) {
	        if (this.active === true) {
	            return _super.prototype._execute.call(this, state, delay);
	        }
	    };
	    VirtualAction.sortActions = function (a, b) {
	        if (a.delay === b.delay) {
	            if (a.index === b.index) {
	                return 0;
	            }
	            else if (a.index > b.index) {
	                return 1;
	            }
	            else {
	                return -1;
	            }
	        }
	        else if (a.delay > b.delay) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    };
	    return VirtualAction;
	}(AsyncAction$1));

	var EMPTY$1 = new Observable$1(function (subscriber) { return subscriber.complete(); });
	function empty$2(scheduler) {
	    return scheduler ? emptyScheduled$1(scheduler) : EMPTY$1;
	}
	function emptyScheduled$1(scheduler) {
	    return new Observable$1(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
	}

	function isScheduler$1(value) {
	    return value && isFunction$1(value.schedule);
	}

	function last$2(arr) {
	    return arr[arr.length - 1];
	}
	function popResultSelector(args) {
	    return isFunction$1(last$2(args)) ? args.pop() : undefined;
	}
	function popScheduler(args) {
	    return isScheduler$1(last$2(args)) ? args.pop() : undefined;
	}
	function popNumber(args, defaultValue) {
	    return typeof last$2(args) === 'number' ? args.pop() : defaultValue;
	}

	var isArrayLike$1 = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

	function isPromise$1(value) {
	    return isFunction$1(value === null || value === void 0 ? void 0 : value.then);
	}

	function isInteropObservable$1(input) {
	    return isFunction$1(input[observable$1]);
	}

	function isAsyncIterable(obj) {
	    return Symbol.asyncIterator && isFunction$1(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
	}

	function createInvalidObservableTypeError(input) {
	    return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
	}

	function getSymbolIterator$1() {
	    if (typeof Symbol !== 'function' || !Symbol.iterator) {
	        return '@@iterator';
	    }
	    return Symbol.iterator;
	}
	var iterator$1 = getSymbolIterator$1();

	function isIterable$1(input) {
	    return isFunction$1(input === null || input === void 0 ? void 0 : input[iterator$1]);
	}

	function readableStreamLikeToAsyncGenerator(readableStream) {
	    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
	        var reader, _a, value, done;
	        return __generator(this, function (_b) {
	            switch (_b.label) {
	                case 0:
	                    reader = readableStream.getReader();
	                    _b.label = 1;
	                case 1:
	                    _b.trys.push([1, , 9, 10]);
	                    _b.label = 2;
	                case 2:
	                    return [4, __await(reader.read())];
	                case 3:
	                    _a = _b.sent(), value = _a.value, done = _a.done;
	                    if (!done) return [3, 5];
	                    return [4, __await(void 0)];
	                case 4: return [2, _b.sent()];
	                case 5: return [4, __await(value)];
	                case 6: return [4, _b.sent()];
	                case 7:
	                    _b.sent();
	                    return [3, 2];
	                case 8: return [3, 10];
	                case 9:
	                    reader.releaseLock();
	                    return [7];
	                case 10: return [2];
	            }
	        });
	    });
	}
	function isReadableStreamLike(obj) {
	    return isFunction$1(obj === null || obj === void 0 ? void 0 : obj.getReader);
	}

	function innerFrom(input) {
	    if (input instanceof Observable$1) {
	        return input;
	    }
	    if (input != null) {
	        if (isInteropObservable$1(input)) {
	            return fromInteropObservable(input);
	        }
	        if (isArrayLike$1(input)) {
	            return fromArrayLike(input);
	        }
	        if (isPromise$1(input)) {
	            return fromPromise$1(input);
	        }
	        if (isAsyncIterable(input)) {
	            return fromAsyncIterable(input);
	        }
	        if (isIterable$1(input)) {
	            return fromIterable$1(input);
	        }
	        if (isReadableStreamLike(input)) {
	            return fromReadableStreamLike(input);
	        }
	    }
	    throw createInvalidObservableTypeError(input);
	}
	function fromInteropObservable(obj) {
	    return new Observable$1(function (subscriber) {
	        var obs = obj[observable$1]();
	        if (isFunction$1(obs.subscribe)) {
	            return obs.subscribe(subscriber);
	        }
	        throw new TypeError('Provided object does not correctly implement Symbol.observable');
	    });
	}
	function fromArrayLike(array) {
	    return new Observable$1(function (subscriber) {
	        for (var i = 0; i < array.length && !subscriber.closed; i++) {
	            subscriber.next(array[i]);
	        }
	        subscriber.complete();
	    });
	}
	function fromPromise$1(promise) {
	    return new Observable$1(function (subscriber) {
	        promise
	            .then(function (value) {
	            if (!subscriber.closed) {
	                subscriber.next(value);
	                subscriber.complete();
	            }
	        }, function (err) { return subscriber.error(err); })
	            .then(null, reportUnhandledError);
	    });
	}
	function fromIterable$1(iterable) {
	    return new Observable$1(function (subscriber) {
	        var e_1, _a;
	        try {
	            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
	                var value = iterable_1_1.value;
	                subscriber.next(value);
	                if (subscriber.closed) {
	                    return;
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        subscriber.complete();
	    });
	}
	function fromAsyncIterable(asyncIterable) {
	    return new Observable$1(function (subscriber) {
	        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
	    });
	}
	function fromReadableStreamLike(readableStream) {
	    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
	}
	function process(asyncIterable, subscriber) {
	    var asyncIterable_1, asyncIterable_1_1;
	    var e_2, _a;
	    return __awaiter(this, void 0, void 0, function () {
	        var value, e_2_1;
	        return __generator(this, function (_b) {
	            switch (_b.label) {
	                case 0:
	                    _b.trys.push([0, 5, 6, 11]);
	                    asyncIterable_1 = __asyncValues(asyncIterable);
	                    _b.label = 1;
	                case 1: return [4, asyncIterable_1.next()];
	                case 2:
	                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
	                    value = asyncIterable_1_1.value;
	                    subscriber.next(value);
	                    if (subscriber.closed) {
	                        return [2];
	                    }
	                    _b.label = 3;
	                case 3: return [3, 1];
	                case 4: return [3, 11];
	                case 5:
	                    e_2_1 = _b.sent();
	                    e_2 = { error: e_2_1 };
	                    return [3, 11];
	                case 6:
	                    _b.trys.push([6, , 9, 10]);
	                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
	                    return [4, _a.call(asyncIterable_1)];
	                case 7:
	                    _b.sent();
	                    _b.label = 8;
	                case 8: return [3, 10];
	                case 9:
	                    if (e_2) throw e_2.error;
	                    return [7];
	                case 10: return [7];
	                case 11:
	                    subscriber.complete();
	                    return [2];
	            }
	        });
	    });
	}

	function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
	    if (delay === void 0) { delay = 0; }
	    if (repeat === void 0) { repeat = false; }
	    var scheduleSubscription = scheduler.schedule(function () {
	        work();
	        if (repeat) {
	            parentSubscription.add(this.schedule(null, delay));
	        }
	        else {
	            this.unsubscribe();
	        }
	    }, delay);
	    parentSubscription.add(scheduleSubscription);
	    if (!repeat) {
	        return scheduleSubscription;
	    }
	}

	function observeOn$1(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return operate(function (source, subscriber) {
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
	    });
	}

	function subscribeOn$1(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return operate(function (source, subscriber) {
	        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
	    });
	}

	function scheduleObservable(input, scheduler) {
	    return innerFrom(input).pipe(subscribeOn$1(scheduler), observeOn$1(scheduler));
	}

	function schedulePromise(input, scheduler) {
	    return innerFrom(input).pipe(subscribeOn$1(scheduler), observeOn$1(scheduler));
	}

	function scheduleArray(input, scheduler) {
	    return new Observable$1(function (subscriber) {
	        var i = 0;
	        return scheduler.schedule(function () {
	            if (i === input.length) {
	                subscriber.complete();
	            }
	            else {
	                subscriber.next(input[i++]);
	                if (!subscriber.closed) {
	                    this.schedule();
	                }
	            }
	        });
	    });
	}

	function scheduleIterable(input, scheduler) {
	    return new Observable$1(function (subscriber) {
	        var iterator;
	        executeSchedule(subscriber, scheduler, function () {
	            iterator = input[iterator$1]();
	            executeSchedule(subscriber, scheduler, function () {
	                var _a;
	                var value;
	                var done;
	                try {
	                    (_a = iterator.next(), value = _a.value, done = _a.done);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                    return;
	                }
	                if (done) {
	                    subscriber.complete();
	                }
	                else {
	                    subscriber.next(value);
	                }
	            }, 0, true);
	        });
	        return function () { return isFunction$1(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return(); };
	    });
	}

	function scheduleAsyncIterable(input, scheduler) {
	    if (!input) {
	        throw new Error('Iterable cannot be null');
	    }
	    return new Observable$1(function (subscriber) {
	        executeSchedule(subscriber, scheduler, function () {
	            var iterator = input[Symbol.asyncIterator]();
	            executeSchedule(subscriber, scheduler, function () {
	                iterator.next().then(function (result) {
	                    if (result.done) {
	                        subscriber.complete();
	                    }
	                    else {
	                        subscriber.next(result.value);
	                    }
	                });
	            }, 0, true);
	        });
	    });
	}

	function scheduleReadableStreamLike(input, scheduler) {
	    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
	}

	function scheduled(input, scheduler) {
	    if (input != null) {
	        if (isInteropObservable$1(input)) {
	            return scheduleObservable(input, scheduler);
	        }
	        if (isArrayLike$1(input)) {
	            return scheduleArray(input, scheduler);
	        }
	        if (isPromise$1(input)) {
	            return schedulePromise(input, scheduler);
	        }
	        if (isAsyncIterable(input)) {
	            return scheduleAsyncIterable(input, scheduler);
	        }
	        if (isIterable$1(input)) {
	            return scheduleIterable(input, scheduler);
	        }
	        if (isReadableStreamLike(input)) {
	            return scheduleReadableStreamLike(input, scheduler);
	        }
	    }
	    throw createInvalidObservableTypeError(input);
	}

	function from$1(input, scheduler) {
	    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
	}

	function of$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = popScheduler(args);
	    return from$1(args, scheduler);
	}

	function throwError$1(errorOrErrorFactory, scheduler) {
	    var errorFactory = isFunction$1(errorOrErrorFactory) ? errorOrErrorFactory : function () { return errorOrErrorFactory; };
	    var init = function (subscriber) { return subscriber.error(errorFactory()); };
	    return new Observable$1(scheduler ? function (subscriber) { return scheduler.schedule(init, 0, subscriber); } : init);
	}

	var NotificationKind;
	(function (NotificationKind) {
	    NotificationKind["NEXT"] = "N";
	    NotificationKind["ERROR"] = "E";
	    NotificationKind["COMPLETE"] = "C";
	})(NotificationKind || (NotificationKind = {}));
	var Notification$1 = (function () {
	    function Notification(kind, value, error) {
	        this.kind = kind;
	        this.value = value;
	        this.error = error;
	        this.hasValue = kind === 'N';
	    }
	    Notification.prototype.observe = function (observer) {
	        return observeNotification(this, observer);
	    };
	    Notification.prototype.do = function (nextHandler, errorHandler, completeHandler) {
	        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
	        return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
	    };
	    Notification.prototype.accept = function (nextOrObserver, error, complete) {
	        var _a;
	        return isFunction$1((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next)
	            ? this.observe(nextOrObserver)
	            : this.do(nextOrObserver, error, complete);
	    };
	    Notification.prototype.toObservable = function () {
	        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
	        var result = kind === 'N'
	            ?
	                of$1(value)
	            :
	                kind === 'E'
	                    ?
	                        throwError$1(function () { return error; })
	                    :
	                        kind === 'C'
	                            ?
	                                EMPTY$1
	                            :
	                                0;
	        if (!result) {
	            throw new TypeError("Unexpected notification kind " + kind);
	        }
	        return result;
	    };
	    Notification.createNext = function (value) {
	        return new Notification('N', value);
	    };
	    Notification.createError = function (err) {
	        return new Notification('E', undefined, err);
	    };
	    Notification.createComplete = function () {
	        return Notification.completeNotification;
	    };
	    Notification.completeNotification = new Notification('C');
	    return Notification;
	}());
	function observeNotification(notification, observer) {
	    var _a, _b, _c;
	    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
	    if (typeof kind !== 'string') {
	        throw new TypeError('Invalid notification, missing "kind"');
	    }
	    kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
	}

	function isObservable$1(obj) {
	    return !!obj && (obj instanceof Observable$1 || (isFunction$1(obj.lift) && isFunction$1(obj.subscribe)));
	}

	var EmptyError$1 = createErrorClass(function (_super) { return function EmptyErrorImpl() {
	    _super(this);
	    this.name = 'EmptyError';
	    this.message = 'no elements in sequence';
	}; });

	function lastValueFrom(source, config) {
	    var hasConfig = typeof config === 'object';
	    return new Promise(function (resolve, reject) {
	        var _hasValue = false;
	        var _value;
	        source.subscribe({
	            next: function (value) {
	                _value = value;
	                _hasValue = true;
	            },
	            error: reject,
	            complete: function () {
	                if (_hasValue) {
	                    resolve(_value);
	                }
	                else if (hasConfig) {
	                    resolve(config.defaultValue);
	                }
	                else {
	                    reject(new EmptyError$1());
	                }
	            },
	        });
	    });
	}

	function firstValueFrom(source, config) {
	    var hasConfig = typeof config === 'object';
	    return new Promise(function (resolve, reject) {
	        var subscriber = new SafeSubscriber$1({
	            next: function (value) {
	                resolve(value);
	                subscriber.unsubscribe();
	            },
	            error: reject,
	            complete: function () {
	                if (hasConfig) {
	                    resolve(config.defaultValue);
	                }
	                else {
	                    reject(new EmptyError$1());
	                }
	            },
	        });
	        source.subscribe(subscriber);
	    });
	}

	var ArgumentOutOfRangeError$1 = createErrorClass(function (_super) {
	    return function ArgumentOutOfRangeErrorImpl() {
	        _super(this);
	        this.name = 'ArgumentOutOfRangeError';
	        this.message = 'argument out of range';
	    };
	});

	var NotFoundError = createErrorClass(function (_super) {
	    return function NotFoundErrorImpl(message) {
	        _super(this);
	        this.name = 'NotFoundError';
	        this.message = message;
	    };
	});

	var SequenceError = createErrorClass(function (_super) {
	    return function SequenceErrorImpl(message) {
	        _super(this);
	        this.name = 'SequenceError';
	        this.message = message;
	    };
	});

	function isValidDate(value) {
	    return value instanceof Date && !isNaN(value);
	}

	var TimeoutError$1 = createErrorClass(function (_super) {
	    return function TimeoutErrorImpl(info) {
	        if (info === void 0) { info = null; }
	        _super(this);
	        this.message = 'Timeout has occurred';
	        this.name = 'TimeoutError';
	        this.info = info;
	    };
	});
	function timeout$1(config, schedulerArg) {
	    var _a = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config), first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
	    if (first == null && each == null) {
	        throw new TypeError('No timeout provided.');
	    }
	    return operate(function (source, subscriber) {
	        var originalSourceSubscription;
	        var timerSubscription;
	        var lastValue = null;
	        var seen = 0;
	        var startTimer = function (delay) {
	            timerSubscription = executeSchedule(subscriber, scheduler, function () {
	                try {
	                    originalSourceSubscription.unsubscribe();
	                    innerFrom(_with({
	                        meta: meta,
	                        lastValue: lastValue,
	                        seen: seen,
	                    })).subscribe(subscriber);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                }
	            }, delay);
	        };
	        originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
	            seen++;
	            subscriber.next((lastValue = value));
	            each > 0 && startTimer(each);
	        }, undefined, undefined, function () {
	            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
	                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
	            }
	            lastValue = null;
	        }));
	        !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);
	    });
	}
	function timeoutErrorFactory(info) {
	    throw new TimeoutError$1(info);
	}

	function map$1(project, thisArg) {
	    return operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            subscriber.next(project.call(thisArg, value, index++));
	        }));
	    });
	}

	var isArray$3 = Array.isArray;
	function callOrApply(fn, args) {
	    return isArray$3(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
	}
	function mapOneOrManyArgs(fn) {
	    return map$1(function (args) { return callOrApply(fn, args); });
	}

	function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
	    if (resultSelector) {
	        if (isScheduler$1(resultSelector)) {
	            scheduler = resultSelector;
	        }
	        else {
	            return function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i] = arguments[_i];
	                }
	                return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler)
	                    .apply(this, args)
	                    .pipe(mapOneOrManyArgs(resultSelector));
	            };
	        }
	    }
	    if (scheduler) {
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return bindCallbackInternals(isNodeStyle, callbackFunc)
	                .apply(this, args)
	                .pipe(subscribeOn$1(scheduler), observeOn$1(scheduler));
	        };
	    }
	    return function () {
	        var _this = this;
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var subject = new AsyncSubject$1();
	        var uninitialized = true;
	        return new Observable$1(function (subscriber) {
	            var subs = subject.subscribe(subscriber);
	            if (uninitialized) {
	                uninitialized = false;
	                var isAsync_1 = false;
	                var isComplete_1 = false;
	                callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
	                    function () {
	                        var results = [];
	                        for (var _i = 0; _i < arguments.length; _i++) {
	                            results[_i] = arguments[_i];
	                        }
	                        if (isNodeStyle) {
	                            var err = results.shift();
	                            if (err != null) {
	                                subject.error(err);
	                                return;
	                            }
	                        }
	                        subject.next(1 < results.length ? results : results[0]);
	                        isComplete_1 = true;
	                        if (isAsync_1) {
	                            subject.complete();
	                        }
	                    },
	                ]));
	                if (isComplete_1) {
	                    subject.complete();
	                }
	                isAsync_1 = true;
	            }
	            return subs;
	        });
	    };
	}

	function bindCallback$1(callbackFunc, resultSelector, scheduler) {
	    return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
	}

	function bindNodeCallback$1(callbackFunc, resultSelector, scheduler) {
	    return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
	}

	var isArray$2 = Array.isArray;
	var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
	function argsArgArrayOrObject(args) {
	    if (args.length === 1) {
	        var first_1 = args[0];
	        if (isArray$2(first_1)) {
	            return { args: first_1, keys: null };
	        }
	        if (isPOJO(first_1)) {
	            var keys = getKeys(first_1);
	            return {
	                args: keys.map(function (key) { return first_1[key]; }),
	                keys: keys,
	            };
	        }
	    }
	    return { args: args, keys: null };
	}
	function isPOJO(obj) {
	    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
	}

	function createObject(keys, values) {
	    return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});
	}

	function combineLatest$3() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = popScheduler(args);
	    var resultSelector = popResultSelector(args);
	    var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
	    if (observables.length === 0) {
	        return from$1([], scheduler);
	    }
	    var result = new Observable$1(combineLatestInit(observables, scheduler, keys
	        ?
	            function (values) { return createObject(keys, values); }
	        :
	            identity$2));
	    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
	}
	function combineLatestInit(observables, scheduler, valueTransform) {
	    if (valueTransform === void 0) { valueTransform = identity$2; }
	    return function (subscriber) {
	        maybeSchedule(scheduler, function () {
	            var length = observables.length;
	            var values = new Array(length);
	            var active = length;
	            var remainingFirstValues = length;
	            var _loop_1 = function (i) {
	                maybeSchedule(scheduler, function () {
	                    var source = from$1(observables[i], scheduler);
	                    var hasFirstValue = false;
	                    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	                        values[i] = value;
	                        if (!hasFirstValue) {
	                            hasFirstValue = true;
	                            remainingFirstValues--;
	                        }
	                        if (!remainingFirstValues) {
	                            subscriber.next(valueTransform(values.slice()));
	                        }
	                    }, function () {
	                        if (!--active) {
	                            subscriber.complete();
	                        }
	                    }));
	                }, subscriber);
	            };
	            for (var i = 0; i < length; i++) {
	                _loop_1(i);
	            }
	        }, subscriber);
	    };
	}
	function maybeSchedule(scheduler, execute, subscription) {
	    if (scheduler) {
	        executeSchedule(subscription, scheduler, execute);
	    }
	    else {
	        execute();
	    }
	}

	function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
	    var buffer = [];
	    var active = 0;
	    var index = 0;
	    var isComplete = false;
	    var checkComplete = function () {
	        if (isComplete && !buffer.length && !active) {
	            subscriber.complete();
	        }
	    };
	    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
	    var doInnerSub = function (value) {
	        expand && subscriber.next(value);
	        active++;
	        var innerComplete = false;
	        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {
	            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
	            if (expand) {
	                outerNext(innerValue);
	            }
	            else {
	                subscriber.next(innerValue);
	            }
	        }, function () {
	            innerComplete = true;
	        }, undefined, function () {
	            if (innerComplete) {
	                try {
	                    active--;
	                    var _loop_1 = function () {
	                        var bufferedValue = buffer.shift();
	                        if (innerSubScheduler) {
	                            executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });
	                        }
	                        else {
	                            doInnerSub(bufferedValue);
	                        }
	                    };
	                    while (buffer.length && active < concurrent) {
	                        _loop_1();
	                    }
	                    checkComplete();
	                }
	                catch (err) {
	                    subscriber.error(err);
	                }
	            }
	        }));
	    };
	    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {
	        isComplete = true;
	        checkComplete();
	    }));
	    return function () {
	        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
	    };
	}

	function mergeMap$1(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    if (isFunction$1(resultSelector)) {
	        return mergeMap$1(function (a, i) { return map$1(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);
	    }
	    else if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	    }
	    return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });
	}

	function mergeAll$1(concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    return mergeMap$1(identity$2, concurrent);
	}

	function concatAll$1() {
	    return mergeAll$1(1);
	}

	function concat$3() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    return concatAll$1()(from$1(args, popScheduler(args)));
	}

	function defer$1(observableFactory) {
	    return new Observable$1(function (subscriber) {
	        innerFrom(observableFactory()).subscribe(subscriber);
	    });
	}

	var DEFAULT_CONFIG$1 = {
	    connector: function () { return new Subject$1(); },
	    resetOnDisconnect: true,
	};
	function connectable(source, config) {
	    if (config === void 0) { config = DEFAULT_CONFIG$1; }
	    var connection = null;
	    var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
	    var subject = connector();
	    var result = new Observable$1(function (subscriber) {
	        return subject.subscribe(subscriber);
	    });
	    result.connect = function () {
	        if (!connection || connection.closed) {
	            connection = defer$1(function () { return source; }).subscribe(subject);
	            if (resetOnDisconnect) {
	                connection.add(function () { return (subject = connector()); });
	            }
	        }
	        return connection;
	    };
	    return result;
	}

	function forkJoin$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = popResultSelector(args);
	    var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
	    var result = new Observable$1(function (subscriber) {
	        var length = sources.length;
	        if (!length) {
	            subscriber.complete();
	            return;
	        }
	        var values = new Array(length);
	        var remainingCompletions = length;
	        var remainingEmissions = length;
	        var _loop_1 = function (sourceIndex) {
	            var hasValue = false;
	            innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function (value) {
	                if (!hasValue) {
	                    hasValue = true;
	                    remainingEmissions--;
	                }
	                values[sourceIndex] = value;
	            }, function () { return remainingCompletions--; }, undefined, function () {
	                if (!remainingCompletions || !hasValue) {
	                    if (!remainingEmissions) {
	                        subscriber.next(keys ? createObject(keys, values) : values);
	                    }
	                    subscriber.complete();
	                }
	            }));
	        };
	        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
	            _loop_1(sourceIndex);
	        }
	    });
	    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
	}

	var nodeEventEmitterMethods = ['addListener', 'removeListener'];
	var eventTargetMethods = ['addEventListener', 'removeEventListener'];
	var jqueryMethods = ['on', 'off'];
	function fromEvent$1(target, eventName, options, resultSelector) {
	    if (isFunction$1(options)) {
	        resultSelector = options;
	        options = undefined;
	    }
	    if (resultSelector) {
	        return fromEvent$1(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
	    }
	    var _a = __read(isEventTarget$1(target)
	        ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
	        :
	            isNodeStyleEventEmitter$1(target)
	                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
	                : isJQueryStyleEventEmitter$1(target)
	                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
	                    : [], 2), add = _a[0], remove = _a[1];
	    if (!add) {
	        if (isArrayLike$1(target)) {
	            return mergeMap$1(function (subTarget) { return fromEvent$1(subTarget, eventName, options); })(innerFrom(target));
	        }
	    }
	    if (!add) {
	        throw new TypeError('Invalid event target');
	    }
	    return new Observable$1(function (subscriber) {
	        var handler = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return subscriber.next(1 < args.length ? args : args[0]);
	        };
	        add(handler);
	        return function () { return remove(handler); };
	    });
	}
	function toCommonHandlerRegistry(target, eventName) {
	    return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
	}
	function isNodeStyleEventEmitter$1(target) {
	    return isFunction$1(target.addListener) && isFunction$1(target.removeListener);
	}
	function isJQueryStyleEventEmitter$1(target) {
	    return isFunction$1(target.on) && isFunction$1(target.off);
	}
	function isEventTarget$1(target) {
	    return isFunction$1(target.addEventListener) && isFunction$1(target.removeEventListener);
	}

	function fromEventPattern$1(addHandler, removeHandler, resultSelector) {
	    if (resultSelector) {
	        return fromEventPattern$1(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
	    }
	    return new Observable$1(function (subscriber) {
	        var handler = function () {
	            var e = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                e[_i] = arguments[_i];
	            }
	            return subscriber.next(e.length === 1 ? e[0] : e);
	        };
	        var retValue = addHandler(handler);
	        return isFunction$1(removeHandler) ? function () { return removeHandler(handler, retValue); } : undefined;
	    });
	}

	function generate$1(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
	    var _a, _b;
	    var resultSelector;
	    var initialState;
	    if (arguments.length === 1) {
	        (_a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity$2 : _b, scheduler = _a.scheduler);
	    }
	    else {
	        initialState = initialStateOrOptions;
	        if (!resultSelectorOrScheduler || isScheduler$1(resultSelectorOrScheduler)) {
	            resultSelector = identity$2;
	            scheduler = resultSelectorOrScheduler;
	        }
	        else {
	            resultSelector = resultSelectorOrScheduler;
	        }
	    }
	    function gen() {
	        var state;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    state = initialState;
	                    _a.label = 1;
	                case 1:
	                    if (!(!condition || condition(state))) return [3, 4];
	                    return [4, resultSelector(state)];
	                case 2:
	                    _a.sent();
	                    _a.label = 3;
	                case 3:
	                    state = iterate(state);
	                    return [3, 1];
	                case 4: return [2];
	            }
	        });
	    }
	    return defer$1((scheduler
	        ?
	            function () { return scheduleIterable(gen(), scheduler); }
	        :
	            gen));
	}

	function iif$1(condition, trueResult, falseResult) {
	    return defer$1(function () { return (condition() ? trueResult : falseResult); });
	}

	function timer$1(dueTime, intervalOrScheduler, scheduler) {
	    if (dueTime === void 0) { dueTime = 0; }
	    if (scheduler === void 0) { scheduler = async$1; }
	    var intervalDuration = -1;
	    if (intervalOrScheduler != null) {
	        if (isScheduler$1(intervalOrScheduler)) {
	            scheduler = intervalOrScheduler;
	        }
	        else {
	            intervalDuration = intervalOrScheduler;
	        }
	    }
	    return new Observable$1(function (subscriber) {
	        var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
	        if (due < 0) {
	            due = 0;
	        }
	        var n = 0;
	        return scheduler.schedule(function () {
	            if (!subscriber.closed) {
	                subscriber.next(n++);
	                if (0 <= intervalDuration) {
	                    this.schedule(undefined, intervalDuration);
	                }
	                else {
	                    subscriber.complete();
	                }
	            }
	        }, due);
	    });
	}

	function interval$1(period, scheduler) {
	    if (period === void 0) { period = 0; }
	    if (scheduler === void 0) { scheduler = asyncScheduler; }
	    if (period < 0) {
	        period = 0;
	    }
	    return timer$1(period, period, scheduler);
	}

	function merge$3() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = popScheduler(args);
	    var concurrent = popNumber(args, Infinity);
	    var sources = args;
	    return !sources.length
	        ?
	            EMPTY$1
	        : sources.length === 1
	            ?
	                innerFrom(sources[0])
	            :
	                mergeAll$1(concurrent)(from$1(sources, scheduler));
	}

	var NEVER$1 = new Observable$1(noop$1);
	function never$1() {
	    return NEVER$1;
	}

	var isArray$1 = Array.isArray;
	function argsOrArgArray(args) {
	    return args.length === 1 && isArray$1(args[0]) ? args[0] : args;
	}

	function onErrorResumeNext$3() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    var nextSources = argsOrArgArray(sources);
	    return operate(function (source, subscriber) {
	        var remaining = __spreadArray([source], __read(nextSources));
	        var subscribeNext = function () {
	            if (!subscriber.closed) {
	                if (remaining.length > 0) {
	                    var nextSource = void 0;
	                    try {
	                        nextSource = innerFrom(remaining.shift());
	                    }
	                    catch (err) {
	                        subscribeNext();
	                        return;
	                    }
	                    var innerSub = createOperatorSubscriber(subscriber, undefined, noop$1, noop$1);
	                    nextSource.subscribe(innerSub);
	                    innerSub.add(subscribeNext);
	                }
	                else {
	                    subscriber.complete();
	                }
	            }
	        };
	        subscribeNext();
	    });
	}

	function onErrorResumeNext$2() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    return onErrorResumeNext$3(argsOrArgArray(sources))(EMPTY$1);
	}

	function pairs$1(obj, scheduler) {
	    return from$1(Object.entries(obj), scheduler);
	}

	function not$1(pred, thisArg) {
	    return function (value, index) { return !pred.call(thisArg, value, index); };
	}

	function filter$1(predicate, thisArg) {
	    return operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
	    });
	}

	function partition$1(source, predicate, thisArg) {
	    return [filter$1(predicate, thisArg)(innerFrom(source)), filter$1(not$1(predicate, thisArg))(innerFrom(source))];
	}

	function race$2() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    sources = argsOrArgArray(sources);
	    return sources.length === 1 ? innerFrom(sources[0]) : new Observable$1(raceInit(sources));
	}
	function raceInit(sources) {
	    return function (subscriber) {
	        var subscriptions = [];
	        var _loop_1 = function (i) {
	            subscriptions.push(innerFrom(sources[i]).subscribe(createOperatorSubscriber(subscriber, function (value) {
	                if (subscriptions) {
	                    for (var s = 0; s < subscriptions.length; s++) {
	                        s !== i && subscriptions[s].unsubscribe();
	                    }
	                    subscriptions = null;
	                }
	                subscriber.next(value);
	            })));
	        };
	        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
	            _loop_1(i);
	        }
	    };
	}

	function range$1(start, count, scheduler) {
	    if (count == null) {
	        count = start;
	        start = 0;
	    }
	    if (count <= 0) {
	        return EMPTY$1;
	    }
	    var end = count + start;
	    return new Observable$1(scheduler
	        ?
	            function (subscriber) {
	                var n = start;
	                return scheduler.schedule(function () {
	                    if (n < end) {
	                        subscriber.next(n++);
	                        this.schedule();
	                    }
	                    else {
	                        subscriber.complete();
	                    }
	                });
	            }
	        :
	            function (subscriber) {
	                var n = start;
	                while (n < end && !subscriber.closed) {
	                    subscriber.next(n++);
	                }
	                subscriber.complete();
	            });
	}

	function using$1(resourceFactory, observableFactory) {
	    return new Observable$1(function (subscriber) {
	        var resource = resourceFactory();
	        var result = observableFactory(resource);
	        var source = result ? innerFrom(result) : EMPTY$1;
	        source.subscribe(subscriber);
	        return function () {
	            if (resource) {
	                resource.unsubscribe();
	            }
	        };
	    });
	}

	function zip$3() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = popResultSelector(args);
	    var sources = argsOrArgArray(args);
	    return sources.length
	        ? new Observable$1(function (subscriber) {
	            var buffers = sources.map(function () { return []; });
	            var completed = sources.map(function () { return false; });
	            subscriber.add(function () {
	                buffers = completed = null;
	            });
	            var _loop_1 = function (sourceIndex) {
	                innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function (value) {
	                    buffers[sourceIndex].push(value);
	                    if (buffers.every(function (buffer) { return buffer.length; })) {
	                        var result = buffers.map(function (buffer) { return buffer.shift(); });
	                        subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
	                        if (buffers.some(function (buffer, i) { return !buffer.length && completed[i]; })) {
	                            subscriber.complete();
	                        }
	                    }
	                }, function () {
	                    completed[sourceIndex] = true;
	                    !buffers[sourceIndex].length && subscriber.complete();
	                }));
	            };
	            for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
	                _loop_1(sourceIndex);
	            }
	            return function () {
	                buffers = completed = null;
	            };
	        })
	        : EMPTY$1;
	}

	function audit$2(durationSelector) {
	    return operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        var durationSubscriber = null;
	        var isComplete = false;
	        var endDuration = function () {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            durationSubscriber = null;
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	            isComplete && subscriber.complete();
	        };
	        var cleanupDuration = function () {
	            durationSubscriber = null;
	            isComplete && subscriber.complete();
	        };
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            lastValue = value;
	            if (!durationSubscriber) {
	                innerFrom(durationSelector(value)).subscribe((durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration)));
	            }
	        }, function () {
	            isComplete = true;
	            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
	        }));
	    });
	}

	function auditTime$1(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = asyncScheduler; }
	    return audit$2(function () { return timer$1(duration, scheduler); });
	}

	function buffer$1(closingNotifier) {
	    return operate(function (source, subscriber) {
	        var currentBuffer = [];
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {
	            subscriber.next(currentBuffer);
	            subscriber.complete();
	        }));
	        closingNotifier.subscribe(createOperatorSubscriber(subscriber, function () {
	            var b = currentBuffer;
	            currentBuffer = [];
	            subscriber.next(b);
	        }, noop$1));
	        return function () {
	            currentBuffer = null;
	        };
	    });
	}

	function bufferCount$1(bufferSize, startBufferEvery) {
	    if (startBufferEvery === void 0) { startBufferEvery = null; }
	    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
	    return operate(function (source, subscriber) {
	        var buffers = [];
	        var count = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a, e_2, _b;
	            var toEmit = null;
	            if (count++ % startBufferEvery === 0) {
	                buffers.push([]);
	            }
	            try {
	                for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
	                    var buffer = buffers_1_1.value;
	                    buffer.push(value);
	                    if (bufferSize <= buffer.length) {
	                        toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
	                        toEmit.push(buffer);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            if (toEmit) {
	                try {
	                    for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
	                        var buffer = toEmit_1_1.value;
	                        arrRemove(buffers, buffer);
	                        subscriber.next(buffer);
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	            }
	        }, function () {
	            var e_3, _a;
	            try {
	                for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
	                    var buffer = buffers_2_1.value;
	                    subscriber.next(buffer);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	            subscriber.complete();
	        }, undefined, function () {
	            buffers = null;
	        }));
	    });
	}

	function bufferTime$1(bufferTimeSpan) {
	    var _a, _b;
	    var otherArgs = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        otherArgs[_i - 1] = arguments[_i];
	    }
	    var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
	    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
	    var maxBufferSize = otherArgs[1] || Infinity;
	    return operate(function (source, subscriber) {
	        var bufferRecords = [];
	        var restartOnEmit = false;
	        var emit = function (record) {
	            var buffer = record.buffer, subs = record.subs;
	            subs.unsubscribe();
	            arrRemove(bufferRecords, record);
	            subscriber.next(buffer);
	            restartOnEmit && startBuffer();
	        };
	        var startBuffer = function () {
	            if (bufferRecords) {
	                var subs = new Subscription$1();
	                subscriber.add(subs);
	                var buffer = [];
	                var record_1 = {
	                    buffer: buffer,
	                    subs: subs,
	                };
	                bufferRecords.push(record_1);
	                executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);
	            }
	        };
	        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
	            executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
	        }
	        else {
	            restartOnEmit = true;
	        }
	        startBuffer();
	        var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            var recordsCopy = bufferRecords.slice();
	            try {
	                for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
	                    var record = recordsCopy_1_1.value;
	                    var buffer = record.buffer;
	                    buffer.push(value);
	                    maxBufferSize <= buffer.length && emit(record);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
	                subscriber.next(bufferRecords.shift().buffer);
	            }
	            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
	            subscriber.complete();
	            subscriber.unsubscribe();
	        }, undefined, function () { return (bufferRecords = null); });
	        source.subscribe(bufferTimeSubscriber);
	    });
	}

	function bufferToggle$1(openings, closingSelector) {
	    return operate(function (source, subscriber) {
	        var buffers = [];
	        innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function (openValue) {
	            var buffer = [];
	            buffers.push(buffer);
	            var closingSubscription = new Subscription$1();
	            var emitBuffer = function () {
	                arrRemove(buffers, buffer);
	                subscriber.next(buffer);
	                closingSubscription.unsubscribe();
	            };
	            closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop$1)));
	        }, noop$1));
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            try {
	                for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
	                    var buffer = buffers_1_1.value;
	                    buffer.push(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (buffers.length > 0) {
	                subscriber.next(buffers.shift());
	            }
	            subscriber.complete();
	        }));
	    });
	}

	function bufferWhen$1(closingSelector) {
	    return operate(function (source, subscriber) {
	        var buffer = null;
	        var closingSubscriber = null;
	        var openBuffer = function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            var b = buffer;
	            buffer = [];
	            b && subscriber.next(b);
	            innerFrom(closingSelector()).subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop$1)));
	        };
	        openBuffer();
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return buffer === null || buffer === void 0 ? void 0 : buffer.push(value); }, function () {
	            buffer && subscriber.next(buffer);
	            subscriber.complete();
	        }, undefined, function () { return (buffer = closingSubscriber = null); }));
	    });
	}

	function catchError$1(selector) {
	    return operate(function (source, subscriber) {
	        var innerSub = null;
	        var syncUnsub = false;
	        var handledResult;
	        innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
	            handledResult = innerFrom(selector(err, catchError$1(selector)(source)));
	            if (innerSub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                handledResult.subscribe(subscriber);
	            }
	            else {
	                syncUnsub = true;
	            }
	        }));
	        if (syncUnsub) {
	            innerSub.unsubscribe();
	            innerSub = null;
	            handledResult.subscribe(subscriber);
	        }
	    });
	}

	function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
	    return function (source, subscriber) {
	        var hasState = hasSeed;
	        var state = seed;
	        var index = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var i = index++;
	            state = hasState
	                ?
	                    accumulator(state, value, i)
	                :
	                    ((hasState = true), value);
	            emitOnNext && subscriber.next(state);
	        }, emitBeforeComplete &&
	            (function () {
	                hasState && subscriber.next(state);
	                subscriber.complete();
	            })));
	    };
	}

	function reduce$1(accumulator, seed) {
	    return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
	}

	var arrReducer = function (arr, value) { return (arr.push(value), arr); };
	function toArray$1() {
	    return operate(function (source, subscriber) {
	        reduce$1(arrReducer, [])(source).subscribe(subscriber);
	    });
	}

	function joinAllInternals(joinFn, project) {
	    return pipe$1(toArray$1(), mergeMap$1(function (sources) { return joinFn(sources); }), project ? mapOneOrManyArgs(project) : identity$2);
	}

	function combineLatestAll(project) {
	    return joinAllInternals(combineLatest$3, project);
	}

	var combineAll$1 = combineLatestAll;

	function combineLatest$2() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = popResultSelector(args);
	    return resultSelector
	        ? pipe$1(combineLatest$2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector))
	        : operate(function (source, subscriber) {
	            combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
	        });
	}

	function combineLatestWith() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return combineLatest$2.apply(void 0, __spreadArray([], __read(otherSources)));
	}

	function concatMap$1(project, resultSelector) {
	    return isFunction$1(resultSelector) ? mergeMap$1(project, resultSelector, 1) : mergeMap$1(project, 1);
	}

	function concatMapTo$1(innerObservable, resultSelector) {
	    return isFunction$1(resultSelector) ? concatMap$1(function () { return innerObservable; }, resultSelector) : concatMap$1(function () { return innerObservable; });
	}

	function concat$2() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = popScheduler(args);
	    return operate(function (source, subscriber) {
	        concatAll$1()(from$1(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
	    });
	}

	function concatWith() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return concat$2.apply(void 0, __spreadArray([], __read(otherSources)));
	}

	function fromSubscribable(subscribable) {
	    return new Observable$1(function (subscriber) { return subscribable.subscribe(subscriber); });
	}

	var DEFAULT_CONFIG = {
	    connector: function () { return new Subject$1(); },
	};
	function connect(selector, config) {
	    if (config === void 0) { config = DEFAULT_CONFIG; }
	    var connector = config.connector;
	    return operate(function (source, subscriber) {
	        var subject = connector();
	        from$1(selector(fromSubscribable(subject))).subscribe(subscriber);
	        subscriber.add(source.subscribe(subject));
	    });
	}

	function count$1(predicate) {
	    return reduce$1(function (total, value, i) { return (!predicate || predicate(value, i) ? total + 1 : total); }, 0);
	}

	function debounce$1(durationSelector) {
	    return operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        var durationSubscriber = null;
	        var emit = function () {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            durationSubscriber = null;
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        };
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            hasValue = true;
	            lastValue = value;
	            durationSubscriber = createOperatorSubscriber(subscriber, emit, noop$1);
	            innerFrom(durationSelector(value)).subscribe(durationSubscriber);
	        }, function () {
	            emit();
	            subscriber.complete();
	        }, undefined, function () {
	            lastValue = durationSubscriber = null;
	        }));
	    });
	}

	function debounceTime$1(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = asyncScheduler; }
	    return operate(function (source, subscriber) {
	        var activeTask = null;
	        var lastValue = null;
	        var lastTime = null;
	        var emit = function () {
	            if (activeTask) {
	                activeTask.unsubscribe();
	                activeTask = null;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        };
	        function emitWhenIdle() {
	            var targetTime = lastTime + dueTime;
	            var now = scheduler.now();
	            if (now < targetTime) {
	                activeTask = this.schedule(undefined, targetTime - now);
	                subscriber.add(activeTask);
	                return;
	            }
	            emit();
	        }
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            lastValue = value;
	            lastTime = scheduler.now();
	            if (!activeTask) {
	                activeTask = scheduler.schedule(emitWhenIdle, dueTime);
	                subscriber.add(activeTask);
	            }
	        }, function () {
	            emit();
	            subscriber.complete();
	        }, undefined, function () {
	            lastValue = activeTask = null;
	        }));
	    });
	}

	function defaultIfEmpty$1(defaultValue) {
	    return operate(function (source, subscriber) {
	        var hasValue = false;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            subscriber.next(value);
	        }, function () {
	            if (!hasValue) {
	                subscriber.next(defaultValue);
	            }
	            subscriber.complete();
	        }));
	    });
	}

	function take$1(count) {
	    return count <= 0
	        ?
	            function () { return EMPTY$1; }
	        : operate(function (source, subscriber) {
	            var seen = 0;
	            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	                if (++seen <= count) {
	                    subscriber.next(value);
	                    if (count <= seen) {
	                        subscriber.complete();
	                    }
	                }
	            }));
	        });
	}

	function ignoreElements$1() {
	    return operate(function (source, subscriber) {
	        source.subscribe(createOperatorSubscriber(subscriber, noop$1));
	    });
	}

	function mapTo$1(value) {
	    return map$1(function () { return value; });
	}

	function delayWhen$1(delayDurationSelector, subscriptionDelay) {
	    if (subscriptionDelay) {
	        return function (source) {
	            return concat$3(subscriptionDelay.pipe(take$1(1), ignoreElements$1()), source.pipe(delayWhen$1(delayDurationSelector)));
	        };
	    }
	    return mergeMap$1(function (value, index) { return delayDurationSelector(value, index).pipe(take$1(1), mapTo$1(value)); });
	}

	function delay$1(due, scheduler) {
	    if (scheduler === void 0) { scheduler = asyncScheduler; }
	    var duration = timer$1(due, scheduler);
	    return delayWhen$1(function () { return duration; });
	}

	function dematerialize$1() {
	    return operate(function (source, subscriber) {
	        source.subscribe(createOperatorSubscriber(subscriber, function (notification) { return observeNotification(notification, subscriber); }));
	    });
	}

	function distinct$1(keySelector, flushes) {
	    return operate(function (source, subscriber) {
	        var distinctKeys = new Set();
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var key = keySelector ? keySelector(value) : value;
	            if (!distinctKeys.has(key)) {
	                distinctKeys.add(key);
	                subscriber.next(value);
	            }
	        }));
	        flushes === null || flushes === void 0 ? void 0 : flushes.subscribe(createOperatorSubscriber(subscriber, function () { return distinctKeys.clear(); }, noop$1));
	    });
	}

	function distinctUntilChanged$1(comparator, keySelector) {
	    if (keySelector === void 0) { keySelector = identity$2; }
	    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
	    return operate(function (source, subscriber) {
	        var previousKey;
	        var first = true;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var currentKey = keySelector(value);
	            if (first || !comparator(previousKey, currentKey)) {
	                first = false;
	                previousKey = currentKey;
	                subscriber.next(value);
	            }
	        }));
	    });
	}
	function defaultCompare(a, b) {
	    return a === b;
	}

	function distinctUntilKeyChanged$1(key, compare) {
	    return distinctUntilChanged$1(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
	}

	function throwIfEmpty$1(errorFactory) {
	    if (errorFactory === void 0) { errorFactory = defaultErrorFactory$1; }
	    return operate(function (source, subscriber) {
	        var hasValue = false;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            subscriber.next(value);
	        }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));
	    });
	}
	function defaultErrorFactory$1() {
	    return new EmptyError$1();
	}

	function elementAt$1(index, defaultValue) {
	    if (index < 0) {
	        throw new ArgumentOutOfRangeError$1();
	    }
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(filter$1(function (v, i) { return i === index; }), take$1(1), hasDefaultValue ? defaultIfEmpty$1(defaultValue) : throwIfEmpty$1(function () { return new ArgumentOutOfRangeError$1(); }));
	    };
	}

	function endWith$1() {
	    var values = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        values[_i] = arguments[_i];
	    }
	    return function (source) { return concat$3(source, of$1.apply(void 0, __spreadArray([], __read(values)))); };
	}

	function every$1(predicate, thisArg) {
	    return operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            if (!predicate.call(thisArg, value, index++, source)) {
	                subscriber.next(false);
	                subscriber.complete();
	            }
	        }, function () {
	            subscriber.next(true);
	            subscriber.complete();
	        }));
	    });
	}

	function exhaustAll() {
	    return operate(function (source, subscriber) {
	        var isComplete = false;
	        var innerSub = null;
	        source.subscribe(createOperatorSubscriber(subscriber, function (inner) {
	            if (!innerSub) {
	                innerSub = innerFrom(inner).subscribe(createOperatorSubscriber(subscriber, undefined, function () {
	                    innerSub = null;
	                    isComplete && subscriber.complete();
	                }));
	            }
	        }, function () {
	            isComplete = true;
	            !innerSub && subscriber.complete();
	        }));
	    });
	}

	var exhaust$1 = exhaustAll;

	function exhaustMap$1(project, resultSelector) {
	    if (resultSelector) {
	        return function (source) {
	            return source.pipe(exhaustMap$1(function (a, i) { return innerFrom(project(a, i)).pipe(map$1(function (b, ii) { return resultSelector(a, b, i, ii); })); }));
	        };
	    }
	    return operate(function (source, subscriber) {
	        var index = 0;
	        var innerSub = null;
	        var isComplete = false;
	        source.subscribe(createOperatorSubscriber(subscriber, function (outerValue) {
	            if (!innerSub) {
	                innerSub = createOperatorSubscriber(subscriber, undefined, function () {
	                    innerSub = null;
	                    isComplete && subscriber.complete();
	                });
	                innerFrom(project(outerValue, index++)).subscribe(innerSub);
	            }
	        }, function () {
	            isComplete = true;
	            !innerSub && subscriber.complete();
	        }));
	    });
	}

	function expand$1(project, concurrent, scheduler) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
	    return operate(function (source, subscriber) {
	        return mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
	    });
	}

	function finalize$1(callback) {
	    return operate(function (source, subscriber) {
	        try {
	            source.subscribe(subscriber);
	        }
	        finally {
	            subscriber.add(callback);
	        }
	    });
	}

	function find$1(predicate, thisArg) {
	    return operate(createFind(predicate, thisArg, 'value'));
	}
	function createFind(predicate, thisArg, emit) {
	    var findIndex = emit === 'index';
	    return function (source, subscriber) {
	        var index = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var i = index++;
	            if (predicate.call(thisArg, value, i, source)) {
	                subscriber.next(findIndex ? i : value);
	                subscriber.complete();
	            }
	        }, function () {
	            subscriber.next(findIndex ? -1 : undefined);
	            subscriber.complete();
	        }));
	    };
	}

	function findIndex$1(predicate, thisArg) {
	    return operate(createFind(predicate, thisArg, 'index'));
	}

	function first$1(predicate, defaultValue) {
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(predicate ? filter$1(function (v, i) { return predicate(v, i, source); }) : identity$2, take$1(1), hasDefaultValue ? defaultIfEmpty$1(defaultValue) : throwIfEmpty$1(function () { return new EmptyError$1(); }));
	    };
	}

	function groupBy$1(keySelector, elementOrOptions, duration, connector) {
	    return operate(function (source, subscriber) {
	        var element;
	        if (!elementOrOptions || typeof elementOrOptions === 'function') {
	            element = elementOrOptions;
	        }
	        else {
	            (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);
	        }
	        var groups = new Map();
	        var notify = function (cb) {
	            groups.forEach(cb);
	            cb(subscriber);
	        };
	        var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };
	        var activeGroups = 0;
	        var teardownAttempted = false;
	        var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function (value) {
	            try {
	                var key_1 = keySelector(value);
	                var group_1 = groups.get(key_1);
	                if (!group_1) {
	                    groups.set(key_1, (group_1 = connector ? connector() : new Subject$1()));
	                    var grouped = createGroupedObservable(key_1, group_1);
	                    subscriber.next(grouped);
	                    if (duration) {
	                        var durationSubscriber_1 = createOperatorSubscriber(group_1, function () {
	                            group_1.complete();
	                            durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
	                        }, undefined, undefined, function () { return groups.delete(key_1); });
	                        groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
	                    }
	                }
	                group_1.next(element ? element(value) : value);
	            }
	            catch (err) {
	                handleError(err);
	            }
	        }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); }, function () {
	            teardownAttempted = true;
	            return activeGroups === 0;
	        });
	        source.subscribe(groupBySourceSubscriber);
	        function createGroupedObservable(key, groupSubject) {
	            var result = new Observable$1(function (groupSubscriber) {
	                activeGroups++;
	                var innerSub = groupSubject.subscribe(groupSubscriber);
	                return function () {
	                    innerSub.unsubscribe();
	                    --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
	                };
	            });
	            result.key = key;
	            return result;
	        }
	    });
	}

	function isEmpty$1() {
	    return operate(function (source, subscriber) {
	        source.subscribe(createOperatorSubscriber(subscriber, function () {
	            subscriber.next(false);
	            subscriber.complete();
	        }, function () {
	            subscriber.next(true);
	            subscriber.complete();
	        }));
	    });
	}

	function takeLast$1(count) {
	    return count <= 0
	        ? function () { return EMPTY$1; }
	        : operate(function (source, subscriber) {
	            var buffer = [];
	            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	                buffer.push(value);
	                count < buffer.length && buffer.shift();
	            }, function () {
	                var e_1, _a;
	                try {
	                    for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
	                        var value = buffer_1_1.value;
	                        subscriber.next(value);
	                    }
	                }
	                catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                finally {
	                    try {
	                        if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
	                    }
	                    finally { if (e_1) throw e_1.error; }
	                }
	                subscriber.complete();
	            }, undefined, function () {
	                buffer = null;
	            }));
	        });
	}

	function last$1(predicate, defaultValue) {
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(predicate ? filter$1(function (v, i) { return predicate(v, i, source); }) : identity$2, takeLast$1(1), hasDefaultValue ? defaultIfEmpty$1(defaultValue) : throwIfEmpty$1(function () { return new EmptyError$1(); }));
	    };
	}

	function materialize$1() {
	    return operate(function (source, subscriber) {
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            subscriber.next(Notification$1.createNext(value));
	        }, function () {
	            subscriber.next(Notification$1.createComplete());
	            subscriber.complete();
	        }, function (err) {
	            subscriber.next(Notification$1.createError(err));
	            subscriber.complete();
	        }));
	    });
	}

	function max$1(comparer) {
	    return reduce$1(isFunction$1(comparer) ? function (x, y) { return (comparer(x, y) > 0 ? x : y); } : function (x, y) { return (x > y ? x : y); });
	}

	var flatMap = mergeMap$1;

	function mergeMapTo$1(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    if (isFunction$1(resultSelector)) {
	        return mergeMap$1(function () { return innerObservable; }, resultSelector, concurrent);
	    }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	    }
	    return mergeMap$1(function () { return innerObservable; }, concurrent);
	}

	function mergeScan$1(accumulator, seed, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    return operate(function (source, subscriber) {
	        var state = seed;
	        return mergeInternals(source, subscriber, function (value, index) { return accumulator(state, value, index); }, concurrent, function (value) {
	            state = value;
	        }, false, undefined, function () { return (state = null); });
	    });
	}

	function merge$2() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = popScheduler(args);
	    var concurrent = popNumber(args, Infinity);
	    args = argsOrArgArray(args);
	    return operate(function (source, subscriber) {
	        mergeAll$1(concurrent)(from$1(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
	    });
	}

	function mergeWith() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return merge$2.apply(void 0, __spreadArray([], __read(otherSources)));
	}

	function min$1(comparer) {
	    return reduce$1(isFunction$1(comparer) ? function (x, y) { return (comparer(x, y) < 0 ? x : y); } : function (x, y) { return (x < y ? x : y); });
	}

	function multicast$1(subjectOrSubjectFactory, selector) {
	    var subjectFactory = isFunction$1(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () { return subjectOrSubjectFactory; };
	    if (isFunction$1(selector)) {
	        return connect(selector, {
	            connector: subjectFactory,
	        });
	    }
	    return function (source) { return new ConnectableObservable$1(source, subjectFactory); };
	}

	function pairwise$1() {
	    return operate(function (source, subscriber) {
	        var prev;
	        var hasPrev = false;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var p = prev;
	            prev = value;
	            hasPrev && subscriber.next([p, value]);
	            hasPrev = true;
	        }));
	    });
	}

	function pluck$1() {
	    var properties = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        properties[_i] = arguments[_i];
	    }
	    var length = properties.length;
	    if (length === 0) {
	        throw new Error('list of properties cannot be empty.');
	    }
	    return map$1(function (x) {
	        var currentProp = x;
	        for (var i = 0; i < length; i++) {
	            var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
	            if (typeof p !== 'undefined') {
	                currentProp = p;
	            }
	            else {
	                return undefined;
	            }
	        }
	        return currentProp;
	    });
	}

	function publish$1(selector) {
	    return selector ? function (source) { return connect(selector)(source); } : function (source) { return multicast$1(new Subject$1())(source); };
	}

	function publishBehavior$1(initialValue) {
	    return function (source) {
	        var subject = new BehaviorSubject$1(initialValue);
	        return new ConnectableObservable$1(source, function () { return subject; });
	    };
	}

	function publishLast$1() {
	    return function (source) {
	        var subject = new AsyncSubject$1();
	        return new ConnectableObservable$1(source, function () { return subject; });
	    };
	}

	function publishReplay$1(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
	    if (selectorOrScheduler && !isFunction$1(selectorOrScheduler)) {
	        timestampProvider = selectorOrScheduler;
	    }
	    var selector = isFunction$1(selectorOrScheduler) ? selectorOrScheduler : undefined;
	    return function (source) { return multicast$1(new ReplaySubject$1(bufferSize, windowTime, timestampProvider), selector)(source); };
	}

	function raceWith() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return !otherSources.length
	        ? identity$2
	        : operate(function (source, subscriber) {
	            raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
	        });
	}

	function repeat$1(countOrConfig) {
	    var _a;
	    var count = Infinity;
	    var delay;
	    if (countOrConfig != null) {
	        if (typeof countOrConfig === 'object') {
	            (_a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay);
	        }
	        else {
	            count = countOrConfig;
	        }
	    }
	    return count <= 0
	        ? function () { return EMPTY$1; }
	        : operate(function (source, subscriber) {
	            var soFar = 0;
	            var sourceSub;
	            var resubscribe = function () {
	                sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
	                sourceSub = null;
	                if (delay != null) {
	                    var notifier = typeof delay === 'number' ? timer$1(delay) : innerFrom(delay(soFar));
	                    var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function () {
	                        notifierSubscriber_1.unsubscribe();
	                        subscribeToSource();
	                    });
	                    notifier.subscribe(notifierSubscriber_1);
	                }
	                else {
	                    subscribeToSource();
	                }
	            };
	            var subscribeToSource = function () {
	                var syncUnsub = false;
	                sourceSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, function () {
	                    if (++soFar < count) {
	                        if (sourceSub) {
	                            resubscribe();
	                        }
	                        else {
	                            syncUnsub = true;
	                        }
	                    }
	                    else {
	                        subscriber.complete();
	                    }
	                }));
	                if (syncUnsub) {
	                    resubscribe();
	                }
	            };
	            subscribeToSource();
	        });
	}

	function repeatWhen$1(notifier) {
	    return operate(function (source, subscriber) {
	        var innerSub;
	        var syncResub = false;
	        var completions$;
	        var isNotifierComplete = false;
	        var isMainComplete = false;
	        var checkComplete = function () { return isMainComplete && isNotifierComplete && (subscriber.complete(), true); };
	        var getCompletionSubject = function () {
	            if (!completions$) {
	                completions$ = new Subject$1();
	                notifier(completions$).subscribe(createOperatorSubscriber(subscriber, function () {
	                    if (innerSub) {
	                        subscribeForRepeatWhen();
	                    }
	                    else {
	                        syncResub = true;
	                    }
	                }, function () {
	                    isNotifierComplete = true;
	                    checkComplete();
	                }));
	            }
	            return completions$;
	        };
	        var subscribeForRepeatWhen = function () {
	            isMainComplete = false;
	            innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, function () {
	                isMainComplete = true;
	                !checkComplete() && getCompletionSubject().next();
	            }));
	            if (syncResub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                syncResub = false;
	                subscribeForRepeatWhen();
	            }
	        };
	        subscribeForRepeatWhen();
	    });
	}

	function retry$1(configOrCount) {
	    if (configOrCount === void 0) { configOrCount = Infinity; }
	    var config;
	    if (configOrCount && typeof configOrCount === 'object') {
	        config = configOrCount;
	    }
	    else {
	        config = {
	            count: configOrCount,
	        };
	    }
	    var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
	    return count <= 0
	        ? identity$2
	        : operate(function (source, subscriber) {
	            var soFar = 0;
	            var innerSub;
	            var subscribeForRetry = function () {
	                var syncUnsub = false;
	                innerSub = source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	                    if (resetOnSuccess) {
	                        soFar = 0;
	                    }
	                    subscriber.next(value);
	                }, undefined, function (err) {
	                    if (soFar++ < count) {
	                        var resub_1 = function () {
	                            if (innerSub) {
	                                innerSub.unsubscribe();
	                                innerSub = null;
	                                subscribeForRetry();
	                            }
	                            else {
	                                syncUnsub = true;
	                            }
	                        };
	                        if (delay != null) {
	                            var notifier = typeof delay === 'number' ? timer$1(delay) : innerFrom(delay(err, soFar));
	                            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function () {
	                                notifierSubscriber_1.unsubscribe();
	                                resub_1();
	                            }, function () {
	                                subscriber.complete();
	                            });
	                            notifier.subscribe(notifierSubscriber_1);
	                        }
	                        else {
	                            resub_1();
	                        }
	                    }
	                    else {
	                        subscriber.error(err);
	                    }
	                }));
	                if (syncUnsub) {
	                    innerSub.unsubscribe();
	                    innerSub = null;
	                    subscribeForRetry();
	                }
	            };
	            subscribeForRetry();
	        });
	}

	function retryWhen$1(notifier) {
	    return operate(function (source, subscriber) {
	        var innerSub;
	        var syncResub = false;
	        var errors$;
	        var subscribeForRetryWhen = function () {
	            innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
	                if (!errors$) {
	                    errors$ = new Subject$1();
	                    notifier(errors$).subscribe(createOperatorSubscriber(subscriber, function () {
	                        return innerSub ? subscribeForRetryWhen() : (syncResub = true);
	                    }));
	                }
	                if (errors$) {
	                    errors$.next(err);
	                }
	            }));
	            if (syncResub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                syncResub = false;
	                subscribeForRetryWhen();
	            }
	        };
	        subscribeForRetryWhen();
	    });
	}

	function sample$1(notifier) {
	    return operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            lastValue = value;
	        }));
	        notifier.subscribe(createOperatorSubscriber(subscriber, function () {
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        }, noop$1));
	    });
	}

	function sampleTime$1(period, scheduler) {
	    if (scheduler === void 0) { scheduler = asyncScheduler; }
	    return sample$1(interval$1(period, scheduler));
	}

	function scan$1(accumulator, seed) {
	    return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
	}

	function sequenceEqual$1(compareTo, comparator) {
	    if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }
	    return operate(function (source, subscriber) {
	        var aState = createState();
	        var bState = createState();
	        var emit = function (isEqual) {
	            subscriber.next(isEqual);
	            subscriber.complete();
	        };
	        var createSubscriber = function (selfState, otherState) {
	            var sequenceEqualSubscriber = createOperatorSubscriber(subscriber, function (a) {
	                var buffer = otherState.buffer, complete = otherState.complete;
	                if (buffer.length === 0) {
	                    complete ? emit(false) : selfState.buffer.push(a);
	                }
	                else {
	                    !comparator(a, buffer.shift()) && emit(false);
	                }
	            }, function () {
	                selfState.complete = true;
	                var complete = otherState.complete, buffer = otherState.buffer;
	                complete && emit(buffer.length === 0);
	                sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
	            });
	            return sequenceEqualSubscriber;
	        };
	        source.subscribe(createSubscriber(aState, bState));
	        compareTo.subscribe(createSubscriber(bState, aState));
	    });
	}
	function createState() {
	    return {
	        buffer: [],
	        complete: false,
	    };
	}

	function share$1(options) {
	    if (options === void 0) { options = {}; }
	    var _a = options.connector, connector = _a === void 0 ? function () { return new Subject$1(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
	    return function (wrapperSource) {
	        var connection = null;
	        var resetConnection = null;
	        var subject = null;
	        var refCount = 0;
	        var hasCompleted = false;
	        var hasErrored = false;
	        var cancelReset = function () {
	            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
	            resetConnection = null;
	        };
	        var reset = function () {
	            cancelReset();
	            connection = subject = null;
	            hasCompleted = hasErrored = false;
	        };
	        var resetAndUnsubscribe = function () {
	            var conn = connection;
	            reset();
	            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
	        };
	        return operate(function (source, subscriber) {
	            refCount++;
	            if (!hasErrored && !hasCompleted) {
	                cancelReset();
	            }
	            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());
	            subscriber.add(function () {
	                refCount--;
	                if (refCount === 0 && !hasErrored && !hasCompleted) {
	                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
	                }
	            });
	            dest.subscribe(subscriber);
	            if (!connection) {
	                connection = new SafeSubscriber$1({
	                    next: function (value) { return dest.next(value); },
	                    error: function (err) {
	                        hasErrored = true;
	                        cancelReset();
	                        resetConnection = handleReset(reset, resetOnError, err);
	                        dest.error(err);
	                    },
	                    complete: function () {
	                        hasCompleted = true;
	                        cancelReset();
	                        resetConnection = handleReset(reset, resetOnComplete);
	                        dest.complete();
	                    },
	                });
	                from$1(source).subscribe(connection);
	            }
	        })(wrapperSource);
	    };
	}
	function handleReset(reset, on) {
	    var args = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        args[_i - 2] = arguments[_i];
	    }
	    if (on === true) {
	        reset();
	        return null;
	    }
	    if (on === false) {
	        return null;
	    }
	    return on.apply(void 0, __spreadArray([], __read(args))).pipe(take$1(1))
	        .subscribe(function () { return reset(); });
	}

	function shareReplay$1(configOrBufferSize, windowTime, scheduler) {
	    var _a, _b, _c;
	    var bufferSize;
	    var refCount = false;
	    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
	        (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);
	    }
	    else {
	        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
	    }
	    return share$1({
	        connector: function () { return new ReplaySubject$1(bufferSize, windowTime, scheduler); },
	        resetOnError: true,
	        resetOnComplete: false,
	        resetOnRefCountZero: refCount,
	    });
	}

	function single$1(predicate) {
	    return operate(function (source, subscriber) {
	        var hasValue = false;
	        var singleValue;
	        var seenValue = false;
	        var index = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            seenValue = true;
	            if (!predicate || predicate(value, index++, source)) {
	                hasValue && subscriber.error(new SequenceError('Too many matching values'));
	                hasValue = true;
	                singleValue = value;
	            }
	        }, function () {
	            if (hasValue) {
	                subscriber.next(singleValue);
	                subscriber.complete();
	            }
	            else {
	                subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError$1());
	            }
	        }));
	    });
	}

	function skip$1(count) {
	    return filter$1(function (_, index) { return count <= index; });
	}

	function skipLast$1(skipCount) {
	    return skipCount <= 0
	        ?
	            identity$2
	        : operate(function (source, subscriber) {
	            var ring = new Array(skipCount);
	            var seen = 0;
	            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	                var valueIndex = seen++;
	                if (valueIndex < skipCount) {
	                    ring[valueIndex] = value;
	                }
	                else {
	                    var index = valueIndex % skipCount;
	                    var oldValue = ring[index];
	                    ring[index] = value;
	                    subscriber.next(oldValue);
	                }
	            }));
	            return function () {
	                ring = null;
	            };
	        });
	}

	function skipUntil$1(notifier) {
	    return operate(function (source, subscriber) {
	        var taking = false;
	        var skipSubscriber = createOperatorSubscriber(subscriber, function () {
	            skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
	            taking = true;
	        }, noop$1);
	        innerFrom(notifier).subscribe(skipSubscriber);
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return taking && subscriber.next(value); }));
	    });
	}

	function skipWhile$1(predicate) {
	    return operate(function (source, subscriber) {
	        var taking = false;
	        var index = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return (taking || (taking = !predicate(value, index++))) && subscriber.next(value); }));
	    });
	}

	function startWith$1() {
	    var values = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        values[_i] = arguments[_i];
	    }
	    var scheduler = popScheduler(values);
	    return operate(function (source, subscriber) {
	        (scheduler ? concat$3(values, source, scheduler) : concat$3(values, source)).subscribe(subscriber);
	    });
	}

	function switchMap$1(project, resultSelector) {
	    return operate(function (source, subscriber) {
	        var innerSubscriber = null;
	        var index = 0;
	        var isComplete = false;
	        var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
	            var innerIndex = 0;
	            var outerIndex = index++;
	            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {
	                innerSubscriber = null;
	                checkComplete();
	            })));
	        }, function () {
	            isComplete = true;
	            checkComplete();
	        }));
	    });
	}

	function switchAll$1() {
	    return switchMap$1(identity$2);
	}

	function switchMapTo$1(innerObservable, resultSelector) {
	    return isFunction$1(resultSelector) ? switchMap$1(function () { return innerObservable; }, resultSelector) : switchMap$1(function () { return innerObservable; });
	}

	function switchScan(accumulator, seed) {
	    return operate(function (source, subscriber) {
	        var state = seed;
	        switchMap$1(function (value, index) { return accumulator(state, value, index); }, function (_, innerValue) { return ((state = innerValue), innerValue); })(source).subscribe(subscriber);
	        return function () {
	            state = null;
	        };
	    });
	}

	function takeUntil$1(notifier) {
	    return operate(function (source, subscriber) {
	        innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop$1));
	        !subscriber.closed && source.subscribe(subscriber);
	    });
	}

	function takeWhile$1(predicate, inclusive) {
	    if (inclusive === void 0) { inclusive = false; }
	    return operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var result = predicate(value, index++);
	            (result || inclusive) && subscriber.next(value);
	            !result && subscriber.complete();
	        }));
	    });
	}

	function tap$1(observerOrNext, error, complete) {
	    var tapObserver = isFunction$1(observerOrNext) || error || complete
	        ?
	            { next: observerOrNext, error: error, complete: complete }
	        : observerOrNext;
	    return tapObserver
	        ? operate(function (source, subscriber) {
	            var _a;
	            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	            var isUnsub = true;
	            source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	                var _a;
	                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
	                subscriber.next(value);
	            }, function () {
	                var _a;
	                isUnsub = false;
	                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	                subscriber.complete();
	            }, function (err) {
	                var _a;
	                isUnsub = false;
	                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
	                subscriber.error(err);
	            }, function () {
	                var _a, _b;
	                if (isUnsub) {
	                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	                }
	                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
	            }));
	        })
	        :
	            identity$2;
	}

	var defaultThrottleConfig$1 = {
	    leading: true,
	    trailing: false,
	};
	function throttle$1(durationSelector, config) {
	    if (config === void 0) { config = defaultThrottleConfig$1; }
	    return operate(function (source, subscriber) {
	        var leading = config.leading, trailing = config.trailing;
	        var hasValue = false;
	        var sendValue = null;
	        var throttled = null;
	        var isComplete = false;
	        var endThrottling = function () {
	            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
	            throttled = null;
	            if (trailing) {
	                send();
	                isComplete && subscriber.complete();
	            }
	        };
	        var cleanupThrottling = function () {
	            throttled = null;
	            isComplete && subscriber.complete();
	        };
	        var startThrottle = function (value) {
	            return (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
	        };
	        var send = function () {
	            if (hasValue) {
	                hasValue = false;
	                var value = sendValue;
	                sendValue = null;
	                subscriber.next(value);
	                !isComplete && startThrottle(value);
	            }
	        };
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            sendValue = value;
	            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
	        }, function () {
	            isComplete = true;
	            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
	        }));
	    });
	}

	function throttleTime$1(duration, scheduler, config) {
	    if (scheduler === void 0) { scheduler = asyncScheduler; }
	    if (config === void 0) { config = defaultThrottleConfig$1; }
	    var duration$ = timer$1(duration, scheduler);
	    return throttle$1(function () { return duration$; }, config);
	}

	function timeInterval$1(scheduler) {
	    if (scheduler === void 0) { scheduler = asyncScheduler; }
	    return operate(function (source, subscriber) {
	        var last = scheduler.now();
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var now = scheduler.now();
	            var interval = now - last;
	            last = now;
	            subscriber.next(new TimeInterval$1(value, interval));
	        }));
	    });
	}
	var TimeInterval$1 = (function () {
	    function TimeInterval(value, interval) {
	        this.value = value;
	        this.interval = interval;
	    }
	    return TimeInterval;
	}());

	function timeoutWith$1(due, withObservable, scheduler) {
	    var first;
	    var each;
	    var _with;
	    scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async$1;
	    if (isValidDate(due)) {
	        first = due;
	    }
	    else if (typeof due === 'number') {
	        each = due;
	    }
	    if (withObservable) {
	        _with = function () { return withObservable; };
	    }
	    else {
	        throw new TypeError('No observable provided to switch to');
	    }
	    if (first == null && each == null) {
	        throw new TypeError('No timeout provided.');
	    }
	    return timeout$1({
	        first: first,
	        each: each,
	        scheduler: scheduler,
	        with: _with,
	    });
	}

	function timestamp$1(timestampProvider) {
	    if (timestampProvider === void 0) { timestampProvider = dateTimestampProvider; }
	    return map$1(function (value) { return ({ value: value, timestamp: timestampProvider.now() }); });
	}

	function window$2(windowBoundaries) {
	    return operate(function (source, subscriber) {
	        var windowSubject = new Subject$1();
	        subscriber.next(windowSubject.asObservable());
	        var errorHandler = function (err) {
	            windowSubject.error(err);
	            subscriber.error(err);
	        };
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value); }, function () {
	            windowSubject.complete();
	            subscriber.complete();
	        }, errorHandler));
	        windowBoundaries.subscribe(createOperatorSubscriber(subscriber, function () {
	            windowSubject.complete();
	            subscriber.next((windowSubject = new Subject$1()));
	        }, noop$1, errorHandler));
	        return function () {
	            windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
	            windowSubject = null;
	        };
	    });
	}

	function windowCount$1(windowSize, startWindowEvery) {
	    if (startWindowEvery === void 0) { startWindowEvery = 0; }
	    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
	    return operate(function (source, subscriber) {
	        var windows = [new Subject$1()];
	        var starts = [];
	        var count = 0;
	        subscriber.next(windows[0].asObservable());
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            try {
	                for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
	                    var window_1 = windows_1_1.value;
	                    window_1.next(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            var c = count - windowSize + 1;
	            if (c >= 0 && c % startEvery === 0) {
	                windows.shift().complete();
	            }
	            if (++count % startEvery === 0) {
	                var window_2 = new Subject$1();
	                windows.push(window_2);
	                subscriber.next(window_2.asObservable());
	            }
	        }, function () {
	            while (windows.length > 0) {
	                windows.shift().complete();
	            }
	            subscriber.complete();
	        }, function (err) {
	            while (windows.length > 0) {
	                windows.shift().error(err);
	            }
	            subscriber.error(err);
	        }, function () {
	            starts = null;
	            windows = null;
	        }));
	    });
	}

	function windowTime$1(windowTimeSpan) {
	    var _a, _b;
	    var otherArgs = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        otherArgs[_i - 1] = arguments[_i];
	    }
	    var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
	    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
	    var maxWindowSize = otherArgs[1] || Infinity;
	    return operate(function (source, subscriber) {
	        var windowRecords = [];
	        var restartOnClose = false;
	        var closeWindow = function (record) {
	            var window = record.window, subs = record.subs;
	            window.complete();
	            subs.unsubscribe();
	            arrRemove(windowRecords, record);
	            restartOnClose && startWindow();
	        };
	        var startWindow = function () {
	            if (windowRecords) {
	                var subs = new Subscription$1();
	                subscriber.add(subs);
	                var window_1 = new Subject$1();
	                var record_1 = {
	                    window: window_1,
	                    subs: subs,
	                    seen: 0,
	                };
	                windowRecords.push(record_1);
	                subscriber.next(window_1.asObservable());
	                executeSchedule(subs, scheduler, function () { return closeWindow(record_1); }, windowTimeSpan);
	            }
	        };
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
	        }
	        else {
	            restartOnClose = true;
	        }
	        startWindow();
	        var loop = function (cb) { return windowRecords.slice().forEach(cb); };
	        var terminate = function (cb) {
	            loop(function (_a) {
	                var window = _a.window;
	                return cb(window);
	            });
	            cb(subscriber);
	            subscriber.unsubscribe();
	        };
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            loop(function (record) {
	                record.window.next(value);
	                maxWindowSize <= ++record.seen && closeWindow(record);
	            });
	        }, function () { return terminate(function (consumer) { return consumer.complete(); }); }, function (err) { return terminate(function (consumer) { return consumer.error(err); }); }));
	        return function () {
	            windowRecords = null;
	        };
	    });
	}

	function windowToggle$1(openings, closingSelector) {
	    return operate(function (source, subscriber) {
	        var windows = [];
	        var handleError = function (err) {
	            while (0 < windows.length) {
	                windows.shift().error(err);
	            }
	            subscriber.error(err);
	        };
	        innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function (openValue) {
	            var window = new Subject$1();
	            windows.push(window);
	            var closingSubscription = new Subscription$1();
	            var closeWindow = function () {
	                arrRemove(windows, window);
	                window.complete();
	                closingSubscription.unsubscribe();
	            };
	            var closingNotifier;
	            try {
	                closingNotifier = innerFrom(closingSelector(openValue));
	            }
	            catch (err) {
	                handleError(err);
	                return;
	            }
	            subscriber.next(window.asObservable());
	            closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop$1, handleError)));
	        }, noop$1));
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            var windowsCopy = windows.slice();
	            try {
	                for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
	                    var window_1 = windowsCopy_1_1.value;
	                    window_1.next(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (0 < windows.length) {
	                windows.shift().complete();
	            }
	            subscriber.complete();
	        }, handleError, function () {
	            while (0 < windows.length) {
	                windows.shift().unsubscribe();
	            }
	        }));
	    });
	}

	function windowWhen$1(closingSelector) {
	    return operate(function (source, subscriber) {
	        var window;
	        var closingSubscriber;
	        var handleError = function (err) {
	            window.error(err);
	            subscriber.error(err);
	        };
	        var openWindow = function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            window === null || window === void 0 ? void 0 : window.complete();
	            window = new Subject$1();
	            subscriber.next(window.asObservable());
	            var closingNotifier;
	            try {
	                closingNotifier = innerFrom(closingSelector());
	            }
	            catch (err) {
	                handleError(err);
	                return;
	            }
	            closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));
	        };
	        openWindow();
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) { return window.next(value); }, function () {
	            window.complete();
	            subscriber.complete();
	        }, handleError, function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            window = null;
	        }));
	    });
	}

	function withLatestFrom$1() {
	    var inputs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        inputs[_i] = arguments[_i];
	    }
	    var project = popResultSelector(inputs);
	    return operate(function (source, subscriber) {
	        var len = inputs.length;
	        var otherValues = new Array(len);
	        var hasValue = inputs.map(function () { return false; });
	        var ready = false;
	        var _loop_1 = function (i) {
	            innerFrom(inputs[i]).subscribe(createOperatorSubscriber(subscriber, function (value) {
	                otherValues[i] = value;
	                if (!ready && !hasValue[i]) {
	                    hasValue[i] = true;
	                    (ready = hasValue.every(identity$2)) && (hasValue = null);
	                }
	            }, noop$1));
	        };
	        for (var i = 0; i < len; i++) {
	            _loop_1(i);
	        }
	        source.subscribe(createOperatorSubscriber(subscriber, function (value) {
	            if (ready) {
	                var values = __spreadArray([value], __read(otherValues));
	                subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
	            }
	        }));
	    });
	}

	function zipAll$1(project) {
	    return joinAllInternals(zip$3, project);
	}

	function zip$2() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    return operate(function (source, subscriber) {
	        zip$3.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
	    });
	}

	function zipWith() {
	    var otherInputs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherInputs[_i] = arguments[_i];
	    }
	    return zip$2.apply(void 0, __spreadArray([], __read(otherInputs)));
	}

	var esm5$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Observable: Observable$1,
		ConnectableObservable: ConnectableObservable$1,
		observable: observable$1,
		animationFrames: animationFrames,
		Subject: Subject$1,
		BehaviorSubject: BehaviorSubject$1,
		ReplaySubject: ReplaySubject$1,
		AsyncSubject: AsyncSubject$1,
		asap: asap$1,
		asapScheduler: asapScheduler,
		async: async$1,
		asyncScheduler: asyncScheduler,
		queue: queue$1,
		queueScheduler: queueScheduler,
		animationFrame: animationFrame$1,
		animationFrameScheduler: animationFrameScheduler,
		VirtualTimeScheduler: VirtualTimeScheduler$1,
		VirtualAction: VirtualAction$1,
		Scheduler: Scheduler$1,
		Subscription: Subscription$1,
		Subscriber: Subscriber$1,
		Notification: Notification$1,
		get NotificationKind () { return NotificationKind; },
		pipe: pipe$1,
		noop: noop$1,
		identity: identity$2,
		isObservable: isObservable$1,
		lastValueFrom: lastValueFrom,
		firstValueFrom: firstValueFrom,
		ArgumentOutOfRangeError: ArgumentOutOfRangeError$1,
		EmptyError: EmptyError$1,
		NotFoundError: NotFoundError,
		ObjectUnsubscribedError: ObjectUnsubscribedError$1,
		SequenceError: SequenceError,
		TimeoutError: TimeoutError$1,
		UnsubscriptionError: UnsubscriptionError$1,
		bindCallback: bindCallback$1,
		bindNodeCallback: bindNodeCallback$1,
		combineLatest: combineLatest$3,
		concat: concat$3,
		connectable: connectable,
		defer: defer$1,
		empty: empty$2,
		forkJoin: forkJoin$1,
		from: from$1,
		fromEvent: fromEvent$1,
		fromEventPattern: fromEventPattern$1,
		generate: generate$1,
		iif: iif$1,
		interval: interval$1,
		merge: merge$3,
		never: never$1,
		of: of$1,
		onErrorResumeNext: onErrorResumeNext$2,
		pairs: pairs$1,
		partition: partition$1,
		race: race$2,
		range: range$1,
		throwError: throwError$1,
		timer: timer$1,
		using: using$1,
		zip: zip$3,
		scheduled: scheduled,
		EMPTY: EMPTY$1,
		NEVER: NEVER$1,
		config: config$1,
		audit: audit$2,
		auditTime: auditTime$1,
		buffer: buffer$1,
		bufferCount: bufferCount$1,
		bufferTime: bufferTime$1,
		bufferToggle: bufferToggle$1,
		bufferWhen: bufferWhen$1,
		catchError: catchError$1,
		combineAll: combineAll$1,
		combineLatestAll: combineLatestAll,
		combineLatestWith: combineLatestWith,
		concatAll: concatAll$1,
		concatMap: concatMap$1,
		concatMapTo: concatMapTo$1,
		concatWith: concatWith,
		connect: connect,
		count: count$1,
		debounce: debounce$1,
		debounceTime: debounceTime$1,
		defaultIfEmpty: defaultIfEmpty$1,
		delay: delay$1,
		delayWhen: delayWhen$1,
		dematerialize: dematerialize$1,
		distinct: distinct$1,
		distinctUntilChanged: distinctUntilChanged$1,
		distinctUntilKeyChanged: distinctUntilKeyChanged$1,
		elementAt: elementAt$1,
		endWith: endWith$1,
		every: every$1,
		exhaust: exhaust$1,
		exhaustAll: exhaustAll,
		exhaustMap: exhaustMap$1,
		expand: expand$1,
		filter: filter$1,
		finalize: finalize$1,
		find: find$1,
		findIndex: findIndex$1,
		first: first$1,
		groupBy: groupBy$1,
		ignoreElements: ignoreElements$1,
		isEmpty: isEmpty$1,
		last: last$1,
		map: map$1,
		mapTo: mapTo$1,
		materialize: materialize$1,
		max: max$1,
		mergeAll: mergeAll$1,
		flatMap: flatMap,
		mergeMap: mergeMap$1,
		mergeMapTo: mergeMapTo$1,
		mergeScan: mergeScan$1,
		mergeWith: mergeWith,
		min: min$1,
		multicast: multicast$1,
		observeOn: observeOn$1,
		pairwise: pairwise$1,
		pluck: pluck$1,
		publish: publish$1,
		publishBehavior: publishBehavior$1,
		publishLast: publishLast$1,
		publishReplay: publishReplay$1,
		raceWith: raceWith,
		reduce: reduce$1,
		repeat: repeat$1,
		repeatWhen: repeatWhen$1,
		retry: retry$1,
		retryWhen: retryWhen$1,
		refCount: refCount$1,
		sample: sample$1,
		sampleTime: sampleTime$1,
		scan: scan$1,
		sequenceEqual: sequenceEqual$1,
		share: share$1,
		shareReplay: shareReplay$1,
		single: single$1,
		skip: skip$1,
		skipLast: skipLast$1,
		skipUntil: skipUntil$1,
		skipWhile: skipWhile$1,
		startWith: startWith$1,
		subscribeOn: subscribeOn$1,
		switchAll: switchAll$1,
		switchMap: switchMap$1,
		switchMapTo: switchMapTo$1,
		switchScan: switchScan,
		take: take$1,
		takeLast: takeLast$1,
		takeUntil: takeUntil$1,
		takeWhile: takeWhile$1,
		tap: tap$1,
		throttle: throttle$1,
		throttleTime: throttleTime$1,
		throwIfEmpty: throwIfEmpty$1,
		timeInterval: timeInterval$1,
		timeout: timeout$1,
		timeoutWith: timeoutWith$1,
		timestamp: timestamp$1,
		toArray: toArray$1,
		window: window$2,
		windowCount: windowCount$1,
		windowTime: windowTime$1,
		windowToggle: windowToggle$1,
		windowWhen: windowWhen$1,
		withLatestFrom: withLatestFrom$1,
		zipAll: zipAll$1,
		zipWith: zipWith
	});

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var browserPonyfill = createCommonjsModule(function (module) {
	var __root__ = (function (root) {
	function F() { this.fetch = false; }
	F.prototype = root;
	return new F();
	})(typeof self !== 'undefined' ? self : commonjsGlobal);
	(function(self) {

	(function(self) {

	  if (self.fetch) {
	    return
	  }

	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob();
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  };

	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ];

	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    };

	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    };
	  }

	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name);
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }

	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value);
	    }
	    return value
	  }

	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift();
	        return {done: value === undefined, value: value}
	      }
	    };

	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      };
	    }

	    return iterator
	  }

	  function Headers(headers) {
	    this.map = {};

	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value);
	      }, this);
	    } else if (Array.isArray(headers)) {
	      headers.forEach(function(header) {
	        this.append(header[0], header[1]);
	      }, this);
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name]);
	      }, this);
	    }
	  }

	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name);
	    value = normalizeValue(value);
	    var oldValue = this.map[name];
	    this.map[name] = oldValue ? oldValue+','+value : value;
	  };

	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)];
	  };

	  Headers.prototype.get = function(name) {
	    name = normalizeName(name);
	    return this.has(name) ? this.map[name] : null
	  };

	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  };

	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value);
	  };

	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this);
	      }
	    }
	  };

	  Headers.prototype.keys = function() {
	    var items = [];
	    this.forEach(function(value, name) { items.push(name); });
	    return iteratorFor(items)
	  };

	  Headers.prototype.values = function() {
	    var items = [];
	    this.forEach(function(value) { items.push(value); });
	    return iteratorFor(items)
	  };

	  Headers.prototype.entries = function() {
	    var items = [];
	    this.forEach(function(value, name) { items.push([name, value]); });
	    return iteratorFor(items)
	  };

	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	  }

	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true;
	  }

	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result);
	      };
	      reader.onerror = function() {
	        reject(reader.error);
	      };
	    })
	  }

	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader();
	    var promise = fileReaderReady(reader);
	    reader.readAsArrayBuffer(blob);
	    return promise
	  }

	  function readBlobAsText(blob) {
	    var reader = new FileReader();
	    var promise = fileReaderReady(reader);
	    reader.readAsText(blob);
	    return promise
	  }

	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf);
	    var chars = new Array(view.length);

	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i]);
	    }
	    return chars.join('')
	  }

	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength);
	      view.set(new Uint8Array(buf));
	      return view.buffer
	    }
	  }

	  function Body() {
	    this.bodyUsed = false;

	    this._initBody = function(body) {
	      this._bodyInit = body;
	      if (!body) {
	        this._bodyText = '';
	      } else if (typeof body === 'string') {
	        this._bodyText = body;
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body;
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body;
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString();
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer);
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer]);
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body);
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }

	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8');
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type);
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	        }
	      }
	    };

	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this);
	        if (rejected) {
	          return rejected
	        }

	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      };

	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      };
	    }

	    this.text = function() {
	      var rejected = consumed(this);
	      if (rejected) {
	        return rejected
	      }

	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    };

	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      };
	    }

	    this.json = function() {
	      return this.text().then(JSON.parse)
	    };

	    return this
	  }

	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase();
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }

	  function Request(input, options) {
	    options = options || {};
	    var body = options.body;

	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url;
	      this.credentials = input.credentials;
	      if (!options.headers) {
	        this.headers = new Headers(input.headers);
	      }
	      this.method = input.method;
	      this.mode = input.mode;
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit;
	        input.bodyUsed = true;
	      }
	    } else {
	      this.url = String(input);
	    }

	    this.credentials = options.credentials || this.credentials || 'omit';
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers);
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET');
	    this.mode = options.mode || this.mode || null;
	    this.referrer = null;

	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body);
	  }

	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  };

	  function decode(body) {
	    var form = new FormData();
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=');
	        var name = split.shift().replace(/\+/g, ' ');
	        var value = split.join('=').replace(/\+/g, ' ');
	        form.append(decodeURIComponent(name), decodeURIComponent(value));
	      }
	    });
	    return form
	  }

	  function parseHeaders(rawHeaders) {
	    var headers = new Headers();
	    rawHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':');
	      var key = parts.shift().trim();
	      if (key) {
	        var value = parts.join(':').trim();
	        headers.append(key, value);
	      }
	    });
	    return headers
	  }

	  Body.call(Request.prototype);

	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {};
	    }

	    this.type = 'default';
	    this.status = 'status' in options ? options.status : 200;
	    this.ok = this.status >= 200 && this.status < 300;
	    this.statusText = 'statusText' in options ? options.statusText : 'OK';
	    this.headers = new Headers(options.headers);
	    this.url = options.url || '';
	    this._initBody(bodyInit);
	  }

	  Body.call(Response.prototype);

	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  };

	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''});
	    response.type = 'error';
	    return response
	  };

	  var redirectStatuses = [301, 302, 303, 307, 308];

	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }

	    return new Response(null, {status: status, headers: {location: url}})
	  };

	  self.Headers = Headers;
	  self.Request = Request;
	  self.Response = Response;

	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init);
	      var xhr = new XMLHttpRequest();

	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        };
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
	        var body = 'response' in xhr ? xhr.response : xhr.responseText;
	        resolve(new Response(body, options));
	      };

	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'));
	      };

	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'));
	      };

	      xhr.open(request.method, request.url, true);

	      if (request.credentials === 'include') {
	        xhr.withCredentials = true;
	      }

	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob';
	      }

	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value);
	      });

	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
	    })
	  };
	  self.fetch.polyfill = true;
	})(typeof self !== 'undefined' ? self : this);
	}).call(__root__, void(0));
	var fetch = __root__.fetch;
	fetch.Response = __root__.Response;
	fetch.Request = __root__.Request;
	fetch.Headers = __root__.Headers;
	if (module.exports) {
	module.exports = fetch;
	}
	});

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isFunction(x) {
	    return typeof x === 'function';
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var _enable_super_gross_mode_that_will_cause_bad_things = false;
	var config = {
	    Promise: undefined,
	    set useDeprecatedSynchronousErrorHandling(value) {
	        if (value) {
	            var error = /*@__PURE__*/ new Error();
	            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
	        }
	        _enable_super_gross_mode_that_will_cause_bad_things = value;
	    },
	    get useDeprecatedSynchronousErrorHandling() {
	        return _enable_super_gross_mode_that_will_cause_bad_things;
	    },
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function hostReportError(err) {
	    setTimeout(function () { throw err; });
	}

	/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
	var empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) {
	        if (config.useDeprecatedSynchronousErrorHandling) {
	            throw err;
	        }
	        else {
	            hostReportError(err);
	        }
	    },
	    complete: function () { }
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isObject(x) {
	    return x !== null && typeof x === 'object';
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function UnsubscriptionErrorImpl(errors) {
	    Error.call(this);
	    this.message = errors ?
	        errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
	    this.name = 'UnsubscriptionError';
	    this.errors = errors;
	    return this;
	}
	UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
	var UnsubscriptionError = UnsubscriptionErrorImpl;

	/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
	var Subscription = /*@__PURE__*/ (function () {
	    function Subscription(unsubscribe) {
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        while (_parent) {
	            _parent.remove(this);
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction(_unsubscribe)) {
	            try {
	                _unsubscribe.call(this);
	            }
	            catch (e) {
	                hasErrors = true;
	                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
	            }
	        }
	        if (isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject(sub)) {
	                    try {
	                        sub.unsubscribe();
	                    }
	                    catch (e) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        if (e instanceof UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
	                        }
	                        else {
	                            errors.push(e);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError(errors);
	        }
	    };
	    Subscription.prototype.add = function (teardown) {
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (!(subscription instanceof Subscription)) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default: {
	                if (!teardown) {
	                    return Subscription.EMPTY;
	                }
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	            }
	        }
	        if (subscription._addParent(this)) {
	            var subscriptions = this._subscriptions;
	            if (subscriptions) {
	                subscriptions.push(subscription);
	            }
	            else {
	                this._subscriptions = [subscription];
	            }
	        }
	        return subscription;
	    };
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (_parent === parent) {
	            return false;
	        }
	        else if (!_parent) {
	            this._parent = parent;
	            return true;
	        }
	        else if (!_parents) {
	            this._parents = [parent];
	            return true;
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            _parents.push(parent);
	            return true;
	        }
	        return false;
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var rxSubscriber = typeof Symbol === 'function'
	    ? /*@__PURE__*/ Symbol('rxSubscriber')
	    : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();

	/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
	var Subscriber = /*@__PURE__*/ (function (_super) {
	    __extends(Subscriber, _super);
	    function Subscriber(destinationOrNext, error, complete) {
	        var _this = _super.call(this) || this;
	        _this.syncErrorValue = null;
	        _this.syncErrorThrown = false;
	        _this.syncErrorThrowable = false;
	        _this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                _this.destination = empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    _this.destination = empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
	                        _this.destination = destinationOrNext;
	                        destinationOrNext.add(_this);
	                    }
	                    else {
	                        _this.syncErrorThrowable = true;
	                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                _this.syncErrorThrowable = true;
	                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
	                break;
	        }
	        return _this;
	    }
	    Subscriber.prototype[rxSubscriber] = function () { return this; };
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription));
	var SafeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        var _this = _super.call(this) || this;
	        _this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = _this;
	        if (isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction(context.unsubscribe)) {
	                    _this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = _this.unsubscribe.bind(_this);
	            }
	        }
	        _this._context = context;
	        _this._next = next;
	        _this._error = error;
	        _this._complete = complete;
	        return _this;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
	            if (this._error) {
	                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                if (useDeprecatedSynchronousErrorHandling) {
	                    throw err;
	                }
	                hostReportError(err);
	            }
	            else {
	                if (useDeprecatedSynchronousErrorHandling) {
	                    _parentSubscriber.syncErrorValue = err;
	                    _parentSubscriber.syncErrorThrown = true;
	                }
	                else {
	                    hostReportError(err);
	                }
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        var _this = this;
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                var wrappedComplete = function () { return _this._complete.call(_this._context); };
	                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(wrappedComplete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            if (config.useDeprecatedSynchronousErrorHandling) {
	                throw err;
	            }
	            else {
	                hostReportError(err);
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        if (!config.useDeprecatedSynchronousErrorHandling) {
	            throw new Error('bad call');
	        }
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            if (config.useDeprecatedSynchronousErrorHandling) {
	                parent.syncErrorValue = err;
	                parent.syncErrorThrown = true;
	                return true;
	            }
	            else {
	                hostReportError(err);
	                return true;
	            }
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
	function canReportError(observer) {
	    while (observer) {
	        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
	        if (closed_1 || isStopped) {
	            return false;
	        }
	        else if (destination && destination instanceof Subscriber) {
	            observer = destination;
	        }
	        else {
	            observer = null;
	        }
	    }
	    return true;
	}

	/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber]) {
	            return nextOrObserver[rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber(empty);
	    }
	    return new Subscriber(nextOrObserver, error, complete);
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function noop() { }

	/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
	function pipe() {
	    var fns = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        fns[_i] = arguments[_i];
	    }
	    return pipeFromArray(fns);
	}
	function pipeFromArray(fns) {
	    if (!fns) {
	        return noop;
	    }
	    if (fns.length === 1) {
	        return fns[0];
	    }
	    return function piped(input) {
	        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
	    };
	}

	/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
	var Observable = /*@__PURE__*/ (function () {
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    Observable.prototype.lift = function (operator) {
	        var observable$$1 = new Observable();
	        observable$$1.source = this;
	        observable$$1.operator = operator;
	        return observable$$1;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            sink.add(operator.call(sink, this.source));
	        }
	        else {
	            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
	                this._subscribe(sink) :
	                this._trySubscribe(sink));
	        }
	        if (config.useDeprecatedSynchronousErrorHandling) {
	            if (sink.syncErrorThrowable) {
	                sink.syncErrorThrowable = false;
	                if (sink.syncErrorThrown) {
	                    throw sink.syncErrorValue;
	                }
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            if (config.useDeprecatedSynchronousErrorHandling) {
	                sink.syncErrorThrown = true;
	                sink.syncErrorValue = err;
	            }
	            if (canReportError(sink)) {
	                sink.error(err);
	            }
	            else {
	                console.warn(err);
	            }
	        }
	    };
	    Observable.prototype.forEach = function (next, promiseCtor) {
	        var _this = this;
	        promiseCtor = getPromiseCtor(promiseCtor);
	        return new promiseCtor(function (resolve, reject) {
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                try {
	                    next(value);
	                }
	                catch (err) {
	                    reject(err);
	                    if (subscription) {
	                        subscription.unsubscribe();
	                    }
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        return source && source.subscribe(subscriber);
	    };
	    Observable.prototype[observable] = function () {
	        return this;
	    };
	    Observable.prototype.pipe = function () {
	        var operations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operations[_i] = arguments[_i];
	        }
	        if (operations.length === 0) {
	            return this;
	        }
	        return pipeFromArray(operations)(this);
	    };
	    Observable.prototype.toPromise = function (promiseCtor) {
	        var _this = this;
	        promiseCtor = getPromiseCtor(promiseCtor);
	        return new promiseCtor(function (resolve, reject) {
	            var value;
	            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	        });
	    };
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	function getPromiseCtor(promiseCtor) {
	    if (!promiseCtor) {
	        promiseCtor = config.Promise || Promise;
	    }
	    if (!promiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return promiseCtor;
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function ObjectUnsubscribedErrorImpl() {
	    Error.call(this);
	    this.message = 'object unsubscribed';
	    this.name = 'ObjectUnsubscribedError';
	    return this;
	}
	ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
	var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

	/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
	var SubjectSubscription = /*@__PURE__*/ (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        var _this = _super.call(this) || this;
	        _this.subject = subject;
	        _this.subscriber = subscriber;
	        _this.closed = false;
	        return _this;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription));

	/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
	var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        var _this = _super.call(this, destination) || this;
	        _this.destination = destination;
	        return _this;
	    }
	    return SubjectSubscriber;
	}(Subscriber));
	var Subject = /*@__PURE__*/ (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        var _this = _super.call(this) || this;
	        _this.observers = [];
	        _this.closed = false;
	        _this.isStopped = false;
	        _this.hasError = false;
	        _this.thrownError = null;
	        return _this;
	    }
	    Subject.prototype[rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._trySubscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError();
	        }
	        else {
	            return _super.prototype._trySubscribe.call(this, subscriber);
	        }
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable));
	var AnonymousSubject = /*@__PURE__*/ (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        var _this = _super.call(this) || this;
	        _this.destination = destination;
	        _this.source = source;
	        return _this;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function refCount() {
	    return function refCountOperatorFunction(source) {
	        return source.lift(new RefCountOperator(source));
	    };
	}
	var RefCountOperator = /*@__PURE__*/ (function () {
	    function RefCountOperator(connectable) {
	        this.connectable = connectable;
	    }
	    RefCountOperator.prototype.call = function (subscriber, source) {
	        var connectable = this.connectable;
	        connectable._refCount++;
	        var refCounter = new RefCountSubscriber(subscriber, connectable);
	        var subscription = source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            refCounter.connection = connectable.connect();
	        }
	        return subscription;
	    };
	    return RefCountOperator;
	}());
	var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(RefCountSubscriber, _super);
	    function RefCountSubscriber(destination, connectable) {
	        var _this = _super.call(this, destination) || this;
	        _this.connectable = connectable;
	        return _this;
	    }
	    RefCountSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (!connectable) {
	            this.connection = null;
	            return;
	        }
	        this.connectable = null;
	        var refCount = connectable._refCount;
	        if (refCount <= 0) {
	            this.connection = null;
	            return;
	        }
	        connectable._refCount = refCount - 1;
	        if (refCount > 1) {
	            this.connection = null;
	            return;
	        }
	        var connection = this.connection;
	        var sharedConnection = connectable._connection;
	        this.connection = null;
	        if (sharedConnection && (!connection || sharedConnection === connection)) {
	            sharedConnection.unsubscribe();
	        }
	    };
	    return RefCountSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
	var ConnectableObservable = /*@__PURE__*/ (function (_super) {
	    __extends(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        var _this = _super.call(this) || this;
	        _this.source = source;
	        _this.subjectFactory = subjectFactory;
	        _this._refCount = 0;
	        _this._isComplete = false;
	        return _this;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var connection = this._connection;
	        if (!connection) {
	            this._isComplete = false;
	            connection = this._connection = new Subscription();
	            connection.add(this.source
	                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription.EMPTY;
	            }
	            else {
	                this._connection = connection;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return refCount()(this);
	    };
	    return ConnectableObservable;
	}(Observable));
	var connectableProto = ConnectableObservable.prototype;
	var connectableObservableDescriptor = {
	    operator: { value: null },
	    _refCount: { value: 0, writable: true },
	    _subject: { value: null, writable: true },
	    _connection: { value: null, writable: true },
	    _subscribe: { value: connectableProto._subscribe },
	    _isComplete: { value: connectableProto._isComplete, writable: true },
	    getSubject: { value: connectableProto.getSubject },
	    connect: { value: connectableProto.connect },
	    refCount: { value: connectableProto.refCount }
	};
	var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ConnectableSubscriber, _super);
	    function ConnectableSubscriber(destination, connectable) {
	        var _this = _super.call(this, destination) || this;
	        _this.connectable = connectable;
	        return _this;
	    }
	    ConnectableSubscriber.prototype._error = function (err) {
	        this._unsubscribe();
	        _super.prototype._error.call(this, err);
	    };
	    ConnectableSubscriber.prototype._complete = function () {
	        this.connectable._isComplete = true;
	        this._unsubscribe();
	        _super.prototype._complete.call(this);
	    };
	    ConnectableSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (connectable) {
	            this.connectable = null;
	            var connection = connectable._connection;
	            connectable._refCount = 0;
	            connectable._subject = null;
	            connectable._connection = null;
	            if (connection) {
	                connection.unsubscribe();
	            }
	        }
	    };
	    return ConnectableSubscriber;
	}(SubjectSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
	function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
	    return function (source) {
	        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
	    };
	}
	var GroupByOperator = /*@__PURE__*/ (function () {
	    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.subjectSelector = subjectSelector;
	    }
	    GroupByOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
	    };
	    return GroupByOperator;
	}());
	var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(GroupBySubscriber, _super);
	    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.keySelector = keySelector;
	        _this.elementSelector = elementSelector;
	        _this.durationSelector = durationSelector;
	        _this.subjectSelector = subjectSelector;
	        _this.groups = null;
	        _this.attemptedToUnsubscribe = false;
	        _this.count = 0;
	        return _this;
	    }
	    GroupBySubscriber.prototype._next = function (value) {
	        var key;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            this.error(err);
	            return;
	        }
	        this._group(value, key);
	    };
	    GroupBySubscriber.prototype._group = function (value, key) {
	        var groups = this.groups;
	        if (!groups) {
	            groups = this.groups = new Map();
	        }
	        var group = groups.get(key);
	        var element;
	        if (this.elementSelector) {
	            try {
	                element = this.elementSelector(value);
	            }
	            catch (err) {
	                this.error(err);
	            }
	        }
	        else {
	            element = value;
	        }
	        if (!group) {
	            group = (this.subjectSelector ? this.subjectSelector() : new Subject());
	            groups.set(key, group);
	            var groupedObservable = new GroupedObservable(key, group, this);
	            this.destination.next(groupedObservable);
	            if (this.durationSelector) {
	                var duration = void 0;
	                try {
	                    duration = this.durationSelector(new GroupedObservable(key, group));
	                }
	                catch (err) {
	                    this.error(err);
	                    return;
	                }
	                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
	            }
	        }
	        if (!group.closed) {
	            group.next(element);
	        }
	    };
	    GroupBySubscriber.prototype._error = function (err) {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.error(err);
	            });
	            groups.clear();
	        }
	        this.destination.error(err);
	    };
	    GroupBySubscriber.prototype._complete = function () {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.complete();
	            });
	            groups.clear();
	        }
	        this.destination.complete();
	    };
	    GroupBySubscriber.prototype.removeGroup = function (key) {
	        this.groups.delete(key);
	    };
	    GroupBySubscriber.prototype.unsubscribe = function () {
	        if (!this.closed) {
	            this.attemptedToUnsubscribe = true;
	            if (this.count === 0) {
	                _super.prototype.unsubscribe.call(this);
	            }
	        }
	    };
	    return GroupBySubscriber;
	}(Subscriber));
	var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(GroupDurationSubscriber, _super);
	    function GroupDurationSubscriber(key, group, parent) {
	        var _this = _super.call(this, group) || this;
	        _this.key = key;
	        _this.group = group;
	        _this.parent = parent;
	        return _this;
	    }
	    GroupDurationSubscriber.prototype._next = function (value) {
	        this.complete();
	    };
	    GroupDurationSubscriber.prototype._unsubscribe = function () {
	        var _a = this, parent = _a.parent, key = _a.key;
	        this.key = this.parent = null;
	        if (parent) {
	            parent.removeGroup(key);
	        }
	    };
	    return GroupDurationSubscriber;
	}(Subscriber));
	var GroupedObservable = /*@__PURE__*/ (function (_super) {
	    __extends(GroupedObservable, _super);
	    function GroupedObservable(key, groupSubject, refCountSubscription) {
	        var _this = _super.call(this) || this;
	        _this.key = key;
	        _this.groupSubject = groupSubject;
	        _this.refCountSubscription = refCountSubscription;
	        return _this;
	    }
	    GroupedObservable.prototype._subscribe = function (subscriber) {
	        var subscription = new Subscription();
	        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
	        if (refCountSubscription && !refCountSubscription.closed) {
	            subscription.add(new InnerRefCountSubscription(refCountSubscription));
	        }
	        subscription.add(groupSubject.subscribe(subscriber));
	        return subscription;
	    };
	    return GroupedObservable;
	}(Observable));
	var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
	    __extends(InnerRefCountSubscription, _super);
	    function InnerRefCountSubscription(parent) {
	        var _this = _super.call(this) || this;
	        _this.parent = parent;
	        parent.count++;
	        return _this;
	    }
	    InnerRefCountSubscription.prototype.unsubscribe = function () {
	        var parent = this.parent;
	        if (!parent.closed && !this.closed) {
	            _super.prototype.unsubscribe.call(this);
	            parent.count -= 1;
	            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
	                parent.unsubscribe();
	            }
	        }
	    };
	    return InnerRefCountSubscription;
	}(Subscription));

	/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
	var BehaviorSubject = /*@__PURE__*/ (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        var _this = _super.call(this) || this;
	        _this._value = _value;
	        return _this;
	    }
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        if (subscription && !subscription.closed) {
	            subscriber.next(this._value);
	        }
	        return subscription;
	    };
	    BehaviorSubject.prototype.getValue = function () {
	        if (this.hasError) {
	            throw this.thrownError;
	        }
	        else if (this.closed) {
	            throw new ObjectUnsubscribedError();
	        }
	        else {
	            return this._value;
	        }
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, this._value = value);
	    };
	    return BehaviorSubject;
	}(Subject));

	/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
	var Action = /*@__PURE__*/ (function (_super) {
	    __extends(Action, _super);
	    function Action(scheduler, work) {
	        return _super.call(this) || this;
	    }
	    Action.prototype.schedule = function (state, delay) {
	        return this;
	    };
	    return Action;
	}(Subscription));

	/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
	var AsyncAction = /*@__PURE__*/ (function (_super) {
	    __extends(AsyncAction, _super);
	    function AsyncAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        _this.pending = false;
	        return _this;
	    }
	    AsyncAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if (this.closed) {
	            return this;
	        }
	        this.state = state;
	        var id = this.id;
	        var scheduler = this.scheduler;
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, delay);
	        }
	        this.pending = true;
	        this.delay = delay;
	        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
	        return this;
	    };
	    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        return setInterval(scheduler.flush.bind(scheduler, this), delay);
	    };
	    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if (delay !== null && this.delay === delay && this.pending === false) {
	            return id;
	        }
	        clearInterval(id);
	        return undefined;
	    };
	    AsyncAction.prototype.execute = function (state, delay) {
	        if (this.closed) {
	            return new Error('executing a cancelled action');
	        }
	        this.pending = false;
	        var error = this._execute(state, delay);
	        if (error) {
	            return error;
	        }
	        else if (this.pending === false && this.id != null) {
	            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	        }
	    };
	    AsyncAction.prototype._execute = function (state, delay) {
	        var errored = false;
	        var errorValue = undefined;
	        try {
	            this.work(state);
	        }
	        catch (e) {
	            errored = true;
	            errorValue = !!e && e || new Error(e);
	        }
	        if (errored) {
	            this.unsubscribe();
	            return errorValue;
	        }
	    };
	    AsyncAction.prototype._unsubscribe = function () {
	        var id = this.id;
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = null;
	        this.state = null;
	        this.pending = false;
	        this.scheduler = null;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, null);
	        }
	        this.delay = null;
	    };
	    return AsyncAction;
	}(Action));

	/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
	var QueueAction = /*@__PURE__*/ (function (_super) {
	    __extends(QueueAction, _super);
	    function QueueAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    QueueAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if (delay > 0) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        this.scheduler.flush(this);
	        return this;
	    };
	    QueueAction.prototype.execute = function (state, delay) {
	        return (delay > 0 || this.closed) ?
	            _super.prototype.execute.call(this, state, delay) :
	            this._execute(state, delay);
	    };
	    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        return scheduler.flush(this);
	    };
	    return QueueAction;
	}(AsyncAction));

	var Scheduler = /*@__PURE__*/ (function () {
	    function Scheduler(SchedulerAction, now) {
	        if (now === void 0) {
	            now = Scheduler.now;
	        }
	        this.SchedulerAction = SchedulerAction;
	        this.now = now;
	    }
	    Scheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        return new this.SchedulerAction(this, work).schedule(state, delay);
	    };
	    Scheduler.now = function () { return Date.now(); };
	    return Scheduler;
	}());

	/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
	var AsyncScheduler = /*@__PURE__*/ (function (_super) {
	    __extends(AsyncScheduler, _super);
	    function AsyncScheduler(SchedulerAction, now) {
	        if (now === void 0) {
	            now = Scheduler.now;
	        }
	        var _this = _super.call(this, SchedulerAction, function () {
	            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
	                return AsyncScheduler.delegate.now();
	            }
	            else {
	                return now();
	            }
	        }) || this;
	        _this.actions = [];
	        _this.active = false;
	        _this.scheduled = undefined;
	        return _this;
	    }
	    AsyncScheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
	            return AsyncScheduler.delegate.schedule(work, delay, state);
	        }
	        else {
	            return _super.prototype.schedule.call(this, work, delay, state);
	        }
	    };
	    AsyncScheduler.prototype.flush = function (action) {
	        var actions = this.actions;
	        if (this.active) {
	            actions.push(action);
	            return;
	        }
	        var error;
	        this.active = true;
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (action = actions.shift());
	        this.active = false;
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsyncScheduler;
	}(Scheduler));

	/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
	var QueueScheduler = /*@__PURE__*/ (function (_super) {
	    __extends(QueueScheduler, _super);
	    function QueueScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return QueueScheduler;
	}(AsyncScheduler));

	/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
	var queue = /*@__PURE__*/ new QueueScheduler(QueueAction);

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
	var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
	function empty$1(scheduler) {
	    return scheduler ? emptyScheduled(scheduler) : EMPTY;
	}
	function emptyScheduled(scheduler) {
	    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isScheduler(value) {
	    return value && typeof value.schedule === 'function';
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var subscribeToArray = function (array) {
	    return function (subscriber) {
	        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
	            subscriber.next(array[i]);
	        }
	        if (!subscriber.closed) {
	            subscriber.complete();
	        }
	    };
	};

	/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
	function fromArray(input, scheduler) {
	    if (!scheduler) {
	        return new Observable(subscribeToArray(input));
	    }
	    else {
	        return new Observable(function (subscriber) {
	            var sub = new Subscription();
	            var i = 0;
	            sub.add(scheduler.schedule(function () {
	                if (i === input.length) {
	                    subscriber.complete();
	                    return;
	                }
	                subscriber.next(input[i++]);
	                if (!subscriber.closed) {
	                    sub.add(this.schedule());
	                }
	            }));
	            return sub;
	        });
	    }
	}

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
	function scalar(value) {
	    var result = new Observable(function (subscriber) {
	        subscriber.next(value);
	        subscriber.complete();
	    });
	    result._isScalar = true;
	    result.value = value;
	    return result;
	}

	/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
	function of() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args[args.length - 1];
	    if (isScheduler(scheduler)) {
	        args.pop();
	    }
	    else {
	        scheduler = undefined;
	    }
	    switch (args.length) {
	        case 0:
	            return empty$1(scheduler);
	        case 1:
	            return scheduler ? fromArray(args, scheduler) : scalar(args[0]);
	        default:
	            return fromArray(args, scheduler);
	    }
	}

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
	function throwError(error, scheduler) {
	    if (!scheduler) {
	        return new Observable(function (subscriber) { return subscriber.error(error); });
	    }
	    else {
	        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
	    }
	}
	function dispatch(_a) {
	    var error = _a.error, subscriber = _a.subscriber;
	    subscriber.error(error);
	}
	var Notification = /*@__PURE__*/ (function () {
	    function Notification(kind, value, error) {
	        this.kind = kind;
	        this.value = value;
	        this.error = error;
	        this.hasValue = kind === "N";
	    }
	    Notification.prototype.observe = function (observer) {
	        switch (this.kind) {
	            case "N":
	                return observer.next && observer.next(this.value);
	            case "E":
	                return observer.error && observer.error(this.error);
	            case "C":
	                return observer.complete && observer.complete();
	        }
	    };
	    Notification.prototype.do = function (next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case "N":
	                return next && next(this.value);
	            case "E":
	                return error && error(this.error);
	            case "C":
	                return complete && complete();
	        }
	    };
	    Notification.prototype.accept = function (nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        }
	        else {
	            return this.do(nextOrObserver, error, complete);
	        }
	    };
	    Notification.prototype.toObservable = function () {
	        var kind = this.kind;
	        switch (kind) {
	            case "N":
	                return of(this.value);
	            case "E":
	                return throwError(this.error);
	            case "C":
	                return empty$1();
	        }
	        throw new Error('unexpected notification kind value');
	    };
	    Notification.createNext = function (value) {
	        if (typeof value !== 'undefined') {
	            return new Notification("N", value);
	        }
	        return Notification.undefinedValueNotification;
	    };
	    Notification.createError = function (err) {
	        return new Notification("E", undefined, err);
	    };
	    Notification.createComplete = function () {
	        return Notification.completeNotification;
	    };
	    Notification.completeNotification = new Notification("C");
	    Notification.undefinedValueNotification = new Notification("N", undefined);
	    return Notification;
	}());

	/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
	function observeOn(scheduler, delay) {
	    if (delay === void 0) {
	        delay = 0;
	    }
	    return function observeOnOperatorFunction(source) {
	        return source.lift(new ObserveOnOperator(scheduler, delay));
	    };
	}
	var ObserveOnOperator = /*@__PURE__*/ (function () {
	    function ObserveOnOperator(scheduler, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
	    };
	    return ObserveOnOperator;
	}());
	var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ObserveOnSubscriber, _super);
	    function ObserveOnSubscriber(destination, scheduler, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        var _this = _super.call(this, destination) || this;
	        _this.scheduler = scheduler;
	        _this.delay = delay;
	        return _this;
	    }
	    ObserveOnSubscriber.dispatch = function (arg) {
	        var notification = arg.notification, destination = arg.destination;
	        notification.observe(destination);
	        this.unsubscribe();
	    };
	    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
	        var destination = this.destination;
	        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
	    };
	    ObserveOnSubscriber.prototype._next = function (value) {
	        this.scheduleMessage(Notification.createNext(value));
	    };
	    ObserveOnSubscriber.prototype._error = function (err) {
	        this.scheduleMessage(Notification.createError(err));
	        this.unsubscribe();
	    };
	    ObserveOnSubscriber.prototype._complete = function () {
	        this.scheduleMessage(Notification.createComplete());
	        this.unsubscribe();
	    };
	    return ObserveOnSubscriber;
	}(Subscriber));
	var ObserveOnMessage = /*@__PURE__*/ (function () {
	    function ObserveOnMessage(notification, destination) {
	        this.notification = notification;
	        this.destination = destination;
	    }
	    return ObserveOnMessage;
	}());

	/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
	var ReplaySubject = /*@__PURE__*/ (function (_super) {
	    __extends(ReplaySubject, _super);
	    function ReplaySubject(bufferSize, windowTime, scheduler) {
	        if (bufferSize === void 0) {
	            bufferSize = Number.POSITIVE_INFINITY;
	        }
	        if (windowTime === void 0) {
	            windowTime = Number.POSITIVE_INFINITY;
	        }
	        var _this = _super.call(this) || this;
	        _this.scheduler = scheduler;
	        _this._events = [];
	        _this._infiniteTimeWindow = false;
	        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        _this._windowTime = windowTime < 1 ? 1 : windowTime;
	        if (windowTime === Number.POSITIVE_INFINITY) {
	            _this._infiniteTimeWindow = true;
	            _this.next = _this.nextInfiniteTimeWindow;
	        }
	        else {
	            _this.next = _this.nextTimeWindow;
	        }
	        return _this;
	    }
	    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
	        var _events = this._events;
	        _events.push(value);
	        if (_events.length > this._bufferSize) {
	            _events.shift();
	        }
	        _super.prototype.next.call(this, value);
	    };
	    ReplaySubject.prototype.nextTimeWindow = function (value) {
	        this._events.push(new ReplayEvent(this._getNow(), value));
	        this._trimBufferThenGetEvents();
	        _super.prototype.next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        var _infiniteTimeWindow = this._infiniteTimeWindow;
	        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
	        var scheduler = this.scheduler;
	        var len = _events.length;
	        var subscription;
	        if (this.closed) {
	            throw new ObjectUnsubscribedError();
	        }
	        else if (this.isStopped || this.hasError) {
	            subscription = Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            subscription = new SubjectSubscription(this, subscriber);
	        }
	        if (scheduler) {
	            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
	        }
	        if (_infiniteTimeWindow) {
	            for (var i = 0; i < len && !subscriber.closed; i++) {
	                subscriber.next(_events[i]);
	            }
	        }
	        else {
	            for (var i = 0; i < len && !subscriber.closed; i++) {
	                subscriber.next(_events[i].value);
	            }
	        }
	        if (this.hasError) {
	            subscriber.error(this.thrownError);
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	        }
	        return subscription;
	    };
	    ReplaySubject.prototype._getNow = function () {
	        return (this.scheduler || queue).now();
	    };
	    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
	        var now = this._getNow();
	        var _bufferSize = this._bufferSize;
	        var _windowTime = this._windowTime;
	        var _events = this._events;
	        var eventsCount = _events.length;
	        var spliceCount = 0;
	        while (spliceCount < eventsCount) {
	            if ((now - _events[spliceCount].time) < _windowTime) {
	                break;
	            }
	            spliceCount++;
	        }
	        if (eventsCount > _bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
	        }
	        if (spliceCount > 0) {
	            _events.splice(0, spliceCount);
	        }
	        return _events;
	    };
	    return ReplaySubject;
	}(Subject));
	var ReplayEvent = /*@__PURE__*/ (function () {
	    function ReplayEvent(time, value) {
	        this.time = time;
	        this.value = value;
	    }
	    return ReplayEvent;
	}());

	/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
	var AsyncSubject = /*@__PURE__*/ (function (_super) {
	    __extends(AsyncSubject, _super);
	    function AsyncSubject() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.value = null;
	        _this.hasNext = false;
	        _this.hasCompleted = false;
	        return _this;
	    }
	    AsyncSubject.prototype._subscribe = function (subscriber) {
	        if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription.EMPTY;
	        }
	        else if (this.hasCompleted && this.hasNext) {
	            subscriber.next(this.value);
	            subscriber.complete();
	            return Subscription.EMPTY;
	        }
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    AsyncSubject.prototype.next = function (value) {
	        if (!this.hasCompleted) {
	            this.value = value;
	            this.hasNext = true;
	        }
	    };
	    AsyncSubject.prototype.error = function (error) {
	        if (!this.hasCompleted) {
	            _super.prototype.error.call(this, error);
	        }
	    };
	    AsyncSubject.prototype.complete = function () {
	        this.hasCompleted = true;
	        if (this.hasNext) {
	            _super.prototype.next.call(this, this.value);
	        }
	        _super.prototype.complete.call(this);
	    };
	    return AsyncSubject;
	}(Subject));

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var nextHandle = 1;
	var tasksByHandle = {};
	function runIfPresent(handle) {
	    var cb = tasksByHandle[handle];
	    if (cb) {
	        cb();
	    }
	}
	var Immediate = {
	    setImmediate: function (cb) {
	        var handle = nextHandle++;
	        tasksByHandle[handle] = cb;
	        Promise.resolve().then(function () { return runIfPresent(handle); });
	        return handle;
	    },
	    clearImmediate: function (handle) {
	        delete tasksByHandle[handle];
	    },
	};

	/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
	var AsapAction = /*@__PURE__*/ (function (_super) {
	    __extends(AsapAction, _super);
	    function AsapAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.actions.push(this);
	        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
	    };
	    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        if (scheduler.actions.length === 0) {
	            Immediate.clearImmediate(id);
	            scheduler.scheduled = undefined;
	        }
	        return undefined;
	    };
	    return AsapAction;
	}(AsyncAction));

	/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
	var AsapScheduler = /*@__PURE__*/ (function (_super) {
	    __extends(AsapScheduler, _super);
	    function AsapScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AsapScheduler.prototype.flush = function (action) {
	        this.active = true;
	        this.scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        var index = -1;
	        var count = actions.length;
	        action = action || actions.shift();
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (++index < count && (action = actions.shift()));
	        this.active = false;
	        if (error) {
	            while (++index < count && (action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsapScheduler;
	}(AsyncScheduler));

	/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
	var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);

	/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
	var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);

	/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
	var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
	    __extends(AnimationFrameAction, _super);
	    function AnimationFrameAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.actions.push(this);
	        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
	    };
	    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        if (scheduler.actions.length === 0) {
	            cancelAnimationFrame(id);
	            scheduler.scheduled = undefined;
	        }
	        return undefined;
	    };
	    return AnimationFrameAction;
	}(AsyncAction));

	/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
	var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
	    __extends(AnimationFrameScheduler, _super);
	    function AnimationFrameScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AnimationFrameScheduler.prototype.flush = function (action) {
	        this.active = true;
	        this.scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        var index = -1;
	        var count = actions.length;
	        action = action || actions.shift();
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (++index < count && (action = actions.shift()));
	        this.active = false;
	        if (error) {
	            while (++index < count && (action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AnimationFrameScheduler;
	}(AsyncScheduler));

	/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
	var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);

	/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
	var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
	    __extends(VirtualTimeScheduler, _super);
	    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
	        if (SchedulerAction === void 0) {
	            SchedulerAction = VirtualAction;
	        }
	        if (maxFrames === void 0) {
	            maxFrames = Number.POSITIVE_INFINITY;
	        }
	        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
	        _this.maxFrames = maxFrames;
	        _this.frame = 0;
	        _this.index = -1;
	        return _this;
	    }
	    VirtualTimeScheduler.prototype.flush = function () {
	        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
	        var error, action;
	        while ((action = actions[0]) && action.delay <= maxFrames) {
	            actions.shift();
	            this.frame = action.delay;
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        }
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    VirtualTimeScheduler.frameTimeFactor = 10;
	    return VirtualTimeScheduler;
	}(AsyncScheduler));
	var VirtualAction = /*@__PURE__*/ (function (_super) {
	    __extends(VirtualAction, _super);
	    function VirtualAction(scheduler, work, index) {
	        if (index === void 0) {
	            index = scheduler.index += 1;
	        }
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        _this.index = index;
	        _this.active = true;
	        _this.index = scheduler.index = index;
	        return _this;
	    }
	    VirtualAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if (!this.id) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.active = false;
	        var action = new VirtualAction(this.scheduler, this.work);
	        this.add(action);
	        return action.schedule(state, delay);
	    };
	    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        this.delay = scheduler.frame + delay;
	        var actions = scheduler.actions;
	        actions.push(this);
	        actions.sort(VirtualAction.sortActions);
	        return true;
	    };
	    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        return undefined;
	    };
	    VirtualAction.prototype._execute = function (state, delay) {
	        if (this.active === true) {
	            return _super.prototype._execute.call(this, state, delay);
	        }
	    };
	    VirtualAction.sortActions = function (a, b) {
	        if (a.delay === b.delay) {
	            if (a.index === b.index) {
	                return 0;
	            }
	            else if (a.index > b.index) {
	                return 1;
	            }
	            else {
	                return -1;
	            }
	        }
	        else if (a.delay > b.delay) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    };
	    return VirtualAction;
	}(AsyncAction));

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function identity(x) {
	    return x;
	}

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
	function isObservable(obj) {
	    return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function ArgumentOutOfRangeErrorImpl() {
	    Error.call(this);
	    this.message = 'argument out of range';
	    this.name = 'ArgumentOutOfRangeError';
	    return this;
	}
	ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
	var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function EmptyErrorImpl() {
	    Error.call(this);
	    this.message = 'no elements in sequence';
	    this.name = 'EmptyError';
	    return this;
	}
	EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
	var EmptyError = EmptyErrorImpl;

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function TimeoutErrorImpl() {
	    Error.call(this);
	    this.message = 'Timeout has occurred';
	    this.name = 'TimeoutError';
	    return this;
	}
	TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
	var TimeoutError = TimeoutErrorImpl;

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function map(project, thisArg) {
	    return function mapOperation(source) {
	        if (typeof project !== 'function') {
	            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	        }
	        return source.lift(new MapOperator(project, thisArg));
	    };
	}
	var MapOperator = /*@__PURE__*/ (function () {
	    function MapOperator(project, thisArg) {
	        this.project = project;
	        this.thisArg = thisArg;
	    }
	    MapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	    };
	    return MapOperator;
	}());
	var MapSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(MapSubscriber, _super);
	    function MapSubscriber(destination, project, thisArg) {
	        var _this = _super.call(this, destination) || this;
	        _this.project = project;
	        _this.count = 0;
	        _this.thisArg = thisArg || _this;
	        return _this;
	    }
	    MapSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.project.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return MapSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */
	function bindCallback(callbackFunc, resultSelector, scheduler) {
	    if (resultSelector) {
	        if (isScheduler(resultSelector)) {
	            scheduler = resultSelector;
	        }
	        else {
	            return function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i] = arguments[_i];
	                }
	                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
	            };
	        }
	    }
	    return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var context = this;
	        var subject;
	        var params = {
	            context: context,
	            subject: subject,
	            callbackFunc: callbackFunc,
	            scheduler: scheduler,
	        };
	        return new Observable(function (subscriber) {
	            if (!scheduler) {
	                if (!subject) {
	                    subject = new AsyncSubject();
	                    var handler = function () {
	                        var innerArgs = [];
	                        for (var _i = 0; _i < arguments.length; _i++) {
	                            innerArgs[_i] = arguments[_i];
	                        }
	                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    };
	                    try {
	                        callbackFunc.apply(context, args.concat([handler]));
	                    }
	                    catch (err) {
	                        if (canReportError(subject)) {
	                            subject.error(err);
	                        }
	                        else {
	                            console.warn(err);
	                        }
	                    }
	                }
	                return subject.subscribe(subscriber);
	            }
	            else {
	                var state = {
	                    args: args, subscriber: subscriber, params: params,
	                };
	                return scheduler.schedule(dispatch$1, 0, state);
	            }
	        });
	    };
	}
	function dispatch$1(state) {
	    var _this = this;
	    var args = state.args, subscriber = state.subscriber, params = state.params;
	    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
	    var subject = params.subject;
	    if (!subject) {
	        subject = params.subject = new AsyncSubject();
	        var handler = function () {
	            var innerArgs = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                innerArgs[_i] = arguments[_i];
	            }
	            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
	            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
	        };
	        try {
	            callbackFunc.apply(context, args.concat([handler]));
	        }
	        catch (err) {
	            subject.error(err);
	        }
	    }
	    this.add(subject.subscribe(subscriber));
	}
	function dispatchNext(state) {
	    var value = state.value, subject = state.subject;
	    subject.next(value);
	    subject.complete();
	}

	/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */
	function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
	    if (resultSelector) {
	        if (isScheduler(resultSelector)) {
	            scheduler = resultSelector;
	        }
	        else {
	            return function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i] = arguments[_i];
	                }
	                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
	            };
	        }
	    }
	    return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var params = {
	            subject: undefined,
	            args: args,
	            callbackFunc: callbackFunc,
	            scheduler: scheduler,
	            context: this,
	        };
	        return new Observable(function (subscriber) {
	            var context = params.context;
	            var subject = params.subject;
	            if (!scheduler) {
	                if (!subject) {
	                    subject = params.subject = new AsyncSubject();
	                    var handler = function () {
	                        var innerArgs = [];
	                        for (var _i = 0; _i < arguments.length; _i++) {
	                            innerArgs[_i] = arguments[_i];
	                        }
	                        var err = innerArgs.shift();
	                        if (err) {
	                            subject.error(err);
	                            return;
	                        }
	                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    };
	                    try {
	                        callbackFunc.apply(context, args.concat([handler]));
	                    }
	                    catch (err) {
	                        if (canReportError(subject)) {
	                            subject.error(err);
	                        }
	                        else {
	                            console.warn(err);
	                        }
	                    }
	                }
	                return subject.subscribe(subscriber);
	            }
	            else {
	                return scheduler.schedule(dispatch$2, 0, { params: params, subscriber: subscriber, context: context });
	            }
	        });
	    };
	}
	function dispatch$2(state) {
	    var _this = this;
	    var params = state.params, subscriber = state.subscriber, context = state.context;
	    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
	    var subject = params.subject;
	    if (!subject) {
	        subject = params.subject = new AsyncSubject();
	        var handler = function () {
	            var innerArgs = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                innerArgs[_i] = arguments[_i];
	            }
	            var err = innerArgs.shift();
	            if (err) {
	                _this.add(scheduler.schedule(dispatchError$1, 0, { err: err, subject: subject }));
	            }
	            else {
	                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
	                _this.add(scheduler.schedule(dispatchNext$1, 0, { value: value, subject: subject }));
	            }
	        };
	        try {
	            callbackFunc.apply(context, args.concat([handler]));
	        }
	        catch (err) {
	            this.add(scheduler.schedule(dispatchError$1, 0, { err: err, subject: subject }));
	        }
	    }
	    this.add(subject.subscribe(subscriber));
	}
	function dispatchNext$1(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError$1(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	var OuterSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	var InnerSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        var _this = _super.call(this) || this;
	        _this.parent = parent;
	        _this.outerValue = outerValue;
	        _this.outerIndex = outerIndex;
	        _this.index = 0;
	        return _this;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
	var subscribeToPromise = function (promise) {
	    return function (subscriber) {
	        promise.then(function (value) {
	            if (!subscriber.closed) {
	                subscriber.next(value);
	                subscriber.complete();
	            }
	        }, function (err) { return subscriber.error(err); })
	            .then(null, hostReportError);
	        return subscriber;
	    };
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function getSymbolIterator() {
	    if (typeof Symbol !== 'function' || !Symbol.iterator) {
	        return '@@iterator';
	    }
	    return Symbol.iterator;
	}
	var iterator = /*@__PURE__*/ getSymbolIterator();

	/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
	var subscribeToIterable = function (iterable) {
	    return function (subscriber) {
	        var iterator$$1 = iterable[iterator]();
	        do {
	            var item = iterator$$1.next();
	            if (item.done) {
	                subscriber.complete();
	                break;
	            }
	            subscriber.next(item.value);
	            if (subscriber.closed) {
	                break;
	            }
	        } while (true);
	        if (typeof iterator$$1.return === 'function') {
	            subscriber.add(function () {
	                if (iterator$$1.return) {
	                    iterator$$1.return();
	                }
	            });
	        }
	        return subscriber;
	    };
	};

	/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
	var subscribeToObservable = function (obj) {
	    return function (subscriber) {
	        var obs = obj[observable]();
	        if (typeof obs.subscribe !== 'function') {
	            throw new TypeError('Provided object does not correctly implement Symbol.observable');
	        }
	        else {
	            return obs.subscribe(subscriber);
	        }
	    };
	};

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isPromise(value) {
	    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}

	/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
	var subscribeTo = function (result) {
	    if (result instanceof Observable) {
	        return function (subscriber) {
	            if (result._isScalar) {
	                subscriber.next(result.value);
	                subscriber.complete();
	                return undefined;
	            }
	            else {
	                return result.subscribe(subscriber);
	            }
	        };
	    }
	    else if (!!result && typeof result[observable] === 'function') {
	        return subscribeToObservable(result);
	    }
	    else if (isArrayLike(result)) {
	        return subscribeToArray(result);
	    }
	    else if (isPromise(result)) {
	        return subscribeToPromise(result);
	    }
	    else if (!!result && typeof result[iterator] === 'function') {
	        return subscribeToIterable(result);
	    }
	    else {
	        var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
	        var msg = "You provided " + value + " where a stream was expected."
	            + ' You can provide an Observable, Promise, Array, or Iterable.';
	        throw new TypeError(msg);
	    }
	};

	/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
	    if (destination === void 0) {
	        destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    }
	    if (destination.closed) {
	        return;
	    }
	    return subscribeTo(result)(destination);
	}

	/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
	var NONE = {};
	function combineLatest() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    var resultSelector = null;
	    var scheduler = null;
	    if (isScheduler(observables[observables.length - 1])) {
	        scheduler = observables.pop();
	    }
	    if (typeof observables[observables.length - 1] === 'function') {
	        resultSelector = observables.pop();
	    }
	    if (observables.length === 1 && isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
	}
	var CombineLatestOperator = /*@__PURE__*/ (function () {
	    function CombineLatestOperator(resultSelector) {
	        this.resultSelector = resultSelector;
	    }
	    CombineLatestOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
	    };
	    return CombineLatestOperator;
	}());
	var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(CombineLatestSubscriber, _super);
	    function CombineLatestSubscriber(destination, resultSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.resultSelector = resultSelector;
	        _this.active = 0;
	        _this.values = [];
	        _this.observables = [];
	        return _this;
	    }
	    CombineLatestSubscriber.prototype._next = function (observable) {
	        this.values.push(NONE);
	        this.observables.push(observable);
	    };
	    CombineLatestSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            this.active = len;
	            this.toRespond = len;
	            for (var i = 0; i < len; i++) {
	                var observable = observables[i];
	                this.add(subscribeToResult(this, observable, observable, i));
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var values = this.values;
	        var oldVal = values[outerIndex];
	        var toRespond = !this.toRespond
	            ? 0
	            : oldVal === NONE ? --this.toRespond : this.toRespond;
	        values[outerIndex] = innerValue;
	        if (toRespond === 0) {
	            if (this.resultSelector) {
	                this._tryResultSelector(values);
	            }
	            else {
	                this.destination.next(values.slice());
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
	        var result;
	        try {
	            result = this.resultSelector.apply(this, values);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return CombineLatestSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
	function isInteropObservable(input) {
	    return input && typeof input[observable] === 'function';
	}

	/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
	function isIterable(input) {
	    return input && typeof input[iterator] === 'function';
	}

	/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
	function fromPromise(input, scheduler) {
	    if (!scheduler) {
	        return new Observable(subscribeToPromise(input));
	    }
	    else {
	        return new Observable(function (subscriber) {
	            var sub = new Subscription();
	            sub.add(scheduler.schedule(function () {
	                return input.then(function (value) {
	                    sub.add(scheduler.schedule(function () {
	                        subscriber.next(value);
	                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
	                    }));
	                }, function (err) {
	                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
	                });
	            }));
	            return sub;
	        });
	    }
	}

	/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */
	function fromIterable(input, scheduler) {
	    if (!input) {
	        throw new Error('Iterable cannot be null');
	    }
	    if (!scheduler) {
	        return new Observable(subscribeToIterable(input));
	    }
	    else {
	        return new Observable(function (subscriber) {
	            var sub = new Subscription();
	            var iterator$$1;
	            sub.add(function () {
	                if (iterator$$1 && typeof iterator$$1.return === 'function') {
	                    iterator$$1.return();
	                }
	            });
	            sub.add(scheduler.schedule(function () {
	                iterator$$1 = input[iterator]();
	                sub.add(scheduler.schedule(function () {
	                    if (subscriber.closed) {
	                        return;
	                    }
	                    var value;
	                    var done;
	                    try {
	                        var result = iterator$$1.next();
	                        value = result.value;
	                        done = result.done;
	                    }
	                    catch (err) {
	                        subscriber.error(err);
	                        return;
	                    }
	                    if (done) {
	                        subscriber.complete();
	                    }
	                    else {
	                        subscriber.next(value);
	                        this.schedule();
	                    }
	                }));
	            }));
	            return sub;
	        });
	    }
	}

	/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */
	function fromObservable(input, scheduler) {
	    if (!scheduler) {
	        return new Observable(subscribeToObservable(input));
	    }
	    else {
	        return new Observable(function (subscriber) {
	            var sub = new Subscription();
	            sub.add(scheduler.schedule(function () {
	                var observable$$1 = input[observable]();
	                sub.add(observable$$1.subscribe({
	                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
	                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
	                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
	                }));
	            }));
	            return sub;
	        });
	    }
	}

	/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
	function from(input, scheduler) {
	    if (!scheduler) {
	        if (input instanceof Observable) {
	            return input;
	        }
	        return new Observable(subscribeTo(input));
	    }
	    if (input != null) {
	        if (isInteropObservable(input)) {
	            return fromObservable(input, scheduler);
	        }
	        else if (isPromise(input)) {
	            return fromPromise(input, scheduler);
	        }
	        else if (isArrayLike(input)) {
	            return fromArray(input, scheduler);
	        }
	        else if (isIterable(input) || typeof input === 'string') {
	            return fromIterable(input, scheduler);
	        }
	    }
	    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
	}

	/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
	function mergeMap(project, resultSelector, concurrent) {
	    if (concurrent === void 0) {
	        concurrent = Number.POSITIVE_INFINITY;
	    }
	    if (typeof resultSelector === 'function') {
	        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
	    }
	    else if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	    }
	    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
	}
	var MergeMapOperator = /*@__PURE__*/ (function () {
	    function MergeMapOperator(project, concurrent) {
	        if (concurrent === void 0) {
	            concurrent = Number.POSITIVE_INFINITY;
	        }
	        this.project = project;
	        this.concurrent = concurrent;
	    }
	    MergeMapOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
	    };
	    return MergeMapOperator;
	}());
	var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(MergeMapSubscriber, _super);
	    function MergeMapSubscriber(destination, project, concurrent) {
	        if (concurrent === void 0) {
	            concurrent = Number.POSITIVE_INFINITY;
	        }
	        var _this = _super.call(this, destination) || this;
	        _this.project = project;
	        _this.concurrent = concurrent;
	        _this.hasCompleted = false;
	        _this.buffer = [];
	        _this.active = 0;
	        _this.index = 0;
	        return _this;
	    }
	    MergeMapSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            this._tryNext(value);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapSubscriber.prototype._tryNext = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.active++;
	        this._innerSub(result, value, index);
	    };
	    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	        var destination = this.destination;
	        destination.add(innerSubscriber);
	        subscribeToResult(this, ish, value, index, innerSubscriber);
	    };
	    MergeMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	        this.unsubscribe();
	    };
	    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
	function mergeAll(concurrent) {
	    if (concurrent === void 0) {
	        concurrent = Number.POSITIVE_INFINITY;
	    }
	    return mergeMap(identity, concurrent);
	}

	/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
	function concatAll() {
	    return mergeAll(1);
	}

	/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
	function concat() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    return concatAll()(of.apply(void 0, observables));
	}

	/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
	function defer(observableFactory) {
	    return new Observable(function (subscriber) {
	        var input;
	        try {
	            input = observableFactory();
	        }
	        catch (err) {
	            subscriber.error(err);
	            return undefined;
	        }
	        var source = input ? from(input) : empty$1();
	        return source.subscribe(subscriber);
	    });
	}

	/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */
	function forkJoin() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    var resultSelector;
	    if (typeof sources[sources.length - 1] === 'function') {
	        resultSelector = sources.pop();
	    }
	    if (sources.length === 1 && isArray(sources[0])) {
	        sources = sources[0];
	    }
	    if (sources.length === 0) {
	        return EMPTY;
	    }
	    if (resultSelector) {
	        return forkJoin(sources).pipe(map(function (args) { return resultSelector.apply(void 0, args); }));
	    }
	    return new Observable(function (subscriber) {
	        return new ForkJoinSubscriber(subscriber, sources);
	    });
	}
	var ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ForkJoinSubscriber, _super);
	    function ForkJoinSubscriber(destination, sources) {
	        var _this = _super.call(this, destination) || this;
	        _this.sources = sources;
	        _this.completed = 0;
	        _this.haveValues = 0;
	        var len = sources.length;
	        _this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            var source = sources[i];
	            var innerSubscription = subscribeToResult(_this, source, null, i);
	            if (innerSubscription) {
	                _this.add(innerSubscription);
	            }
	        }
	        return _this;
	    }
	    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        if (!innerSub._hasValue) {
	            innerSub._hasValue = true;
	            this.haveValues++;
	        }
	    };
	    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
	        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
	        var len = values.length;
	        if (!innerSub._hasValue) {
	            destination.complete();
	            return;
	        }
	        this.completed++;
	        if (this.completed !== len) {
	            return;
	        }
	        if (haveValues === len) {
	            destination.next(values);
	        }
	        destination.complete();
	    };
	    return ForkJoinSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
	function fromEvent(target, eventName, options, resultSelector) {
	    if (isFunction(options)) {
	        resultSelector = options;
	        options = undefined;
	    }
	    if (resultSelector) {
	        return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
	    }
	    return new Observable(function (subscriber) {
	        function handler(e) {
	            if (arguments.length > 1) {
	                subscriber.next(Array.prototype.slice.call(arguments));
	            }
	            else {
	                subscriber.next(e);
	            }
	        }
	        setupSubscription(target, eventName, handler, subscriber, options);
	    });
	}
	function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
	    var unsubscribe;
	    if (isEventTarget(sourceObj)) {
	        var source_1 = sourceObj;
	        sourceObj.addEventListener(eventName, handler, options);
	        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
	    }
	    else if (isJQueryStyleEventEmitter(sourceObj)) {
	        var source_2 = sourceObj;
	        sourceObj.on(eventName, handler);
	        unsubscribe = function () { return source_2.off(eventName, handler); };
	    }
	    else if (isNodeStyleEventEmitter(sourceObj)) {
	        var source_3 = sourceObj;
	        sourceObj.addListener(eventName, handler);
	        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
	    }
	    else if (sourceObj && sourceObj.length) {
	        for (var i = 0, len = sourceObj.length; i < len; i++) {
	            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
	        }
	    }
	    else {
	        throw new TypeError('Invalid event target');
	    }
	    subscriber.add(unsubscribe);
	}
	function isNodeStyleEventEmitter(sourceObj) {
	    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
	}
	function isJQueryStyleEventEmitter(sourceObj) {
	    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
	}
	function isEventTarget(sourceObj) {
	    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
	}

	/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
	function fromEventPattern(addHandler, removeHandler, resultSelector) {
	    if (resultSelector) {
	        return fromEventPattern(addHandler, removeHandler).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
	    }
	    return new Observable(function (subscriber) {
	        var handler = function () {
	            var e = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                e[_i] = arguments[_i];
	            }
	            return subscriber.next(e.length === 1 ? e[0] : e);
	        };
	        var retValue;
	        try {
	            retValue = addHandler(handler);
	        }
	        catch (err) {
	            subscriber.error(err);
	            return undefined;
	        }
	        if (!isFunction(removeHandler)) {
	            return undefined;
	        }
	        return function () { return removeHandler(handler, retValue); };
	    });
	}

	/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */
	function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
	    var resultSelector;
	    var initialState;
	    if (arguments.length == 1) {
	        var options = initialStateOrOptions;
	        initialState = options.initialState;
	        condition = options.condition;
	        iterate = options.iterate;
	        resultSelector = options.resultSelector || identity;
	        scheduler = options.scheduler;
	    }
	    else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {
	        initialState = initialStateOrOptions;
	        resultSelector = identity;
	        scheduler = resultSelectorOrObservable;
	    }
	    else {
	        initialState = initialStateOrOptions;
	        resultSelector = resultSelectorOrObservable;
	    }
	    return new Observable(function (subscriber) {
	        var state = initialState;
	        if (scheduler) {
	            return scheduler.schedule(dispatch$3, 0, {
	                subscriber: subscriber,
	                iterate: iterate,
	                condition: condition,
	                resultSelector: resultSelector,
	                state: state
	            });
	        }
	        do {
	            if (condition) {
	                var conditionResult = void 0;
	                try {
	                    conditionResult = condition(state);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                    return undefined;
	                }
	                if (!conditionResult) {
	                    subscriber.complete();
	                    break;
	                }
	            }
	            var value = void 0;
	            try {
	                value = resultSelector(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return undefined;
	            }
	            subscriber.next(value);
	            if (subscriber.closed) {
	                break;
	            }
	            try {
	                state = iterate(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return undefined;
	            }
	        } while (true);
	        return undefined;
	    });
	}
	function dispatch$3(state) {
	    var subscriber = state.subscriber, condition = state.condition;
	    if (subscriber.closed) {
	        return undefined;
	    }
	    if (state.needIterate) {
	        try {
	            state.state = state.iterate(state.state);
	        }
	        catch (err) {
	            subscriber.error(err);
	            return undefined;
	        }
	    }
	    else {
	        state.needIterate = true;
	    }
	    if (condition) {
	        var conditionResult = void 0;
	        try {
	            conditionResult = condition(state.state);
	        }
	        catch (err) {
	            subscriber.error(err);
	            return undefined;
	        }
	        if (!conditionResult) {
	            subscriber.complete();
	            return undefined;
	        }
	        if (subscriber.closed) {
	            return undefined;
	        }
	    }
	    var value;
	    try {
	        value = state.resultSelector(state.state);
	    }
	    catch (err) {
	        subscriber.error(err);
	        return undefined;
	    }
	    if (subscriber.closed) {
	        return undefined;
	    }
	    subscriber.next(value);
	    if (subscriber.closed) {
	        return undefined;
	    }
	    return this.schedule(state);
	}

	/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */
	function iif(condition, trueResult, falseResult) {
	    if (trueResult === void 0) {
	        trueResult = EMPTY;
	    }
	    if (falseResult === void 0) {
	        falseResult = EMPTY;
	    }
	    return defer(function () { return condition() ? trueResult : falseResult; });
	}

	/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
	function isNumeric(val) {
	    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
	}

	/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
	function interval(period, scheduler) {
	    if (period === void 0) {
	        period = 0;
	    }
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    if (!isNumeric(period) || period < 0) {
	        period = 0;
	    }
	    if (!scheduler || typeof scheduler.schedule !== 'function') {
	        scheduler = async;
	    }
	    return new Observable(function (subscriber) {
	        subscriber.add(scheduler.schedule(dispatch$4, period, { subscriber: subscriber, counter: 0, period: period }));
	        return subscriber;
	    });
	}
	function dispatch$4(state) {
	    var subscriber = state.subscriber, counter = state.counter, period = state.period;
	    subscriber.next(counter);
	    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
	}

	/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
	function merge() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = null;
	    var last = observables[observables.length - 1];
	    if (isScheduler(last)) {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    }
	    else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
	        return observables[0];
	    }
	    return mergeAll(concurrent)(fromArray(observables, scheduler));
	}

	/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
	var NEVER = /*@__PURE__*/ new Observable(noop);
	function never() {
	    return NEVER;
	}

	/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */
	function onErrorResumeNext() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    if (sources.length === 0) {
	        return EMPTY;
	    }
	    var first = sources[0], remainder = sources.slice(1);
	    if (sources.length === 1 && isArray(first)) {
	        return onErrorResumeNext.apply(void 0, first);
	    }
	    return new Observable(function (subscriber) {
	        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
	        return from(first).subscribe({
	            next: function (value) { subscriber.next(value); },
	            error: subNext,
	            complete: subNext,
	        });
	    });
	}

	/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
	function pairs(obj, scheduler) {
	    if (!scheduler) {
	        return new Observable(function (subscriber) {
	            var keys = Object.keys(obj);
	            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
	                var key = keys[i];
	                if (obj.hasOwnProperty(key)) {
	                    subscriber.next([key, obj[key]]);
	                }
	            }
	            subscriber.complete();
	        });
	    }
	    else {
	        return new Observable(function (subscriber) {
	            var keys = Object.keys(obj);
	            var subscription = new Subscription();
	            subscription.add(scheduler.schedule(dispatch$5, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
	            return subscription;
	        });
	    }
	}
	function dispatch$5(state) {
	    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
	    if (!subscriber.closed) {
	        if (index < keys.length) {
	            var key = keys[index];
	            subscriber.next([key, obj[key]]);
	            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
	        }
	        else {
	            subscriber.complete();
	        }
	    }
	}

	/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function race() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    if (observables.length === 1) {
	        if (isArray(observables[0])) {
	            observables = observables[0];
	        }
	        else {
	            return observables[0];
	        }
	    }
	    return fromArray(observables, undefined).lift(new RaceOperator());
	}
	var RaceOperator = /*@__PURE__*/ (function () {
	    function RaceOperator() {
	    }
	    RaceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RaceSubscriber(subscriber));
	    };
	    return RaceOperator;
	}());
	var RaceSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(RaceSubscriber, _super);
	    function RaceSubscriber(destination) {
	        var _this = _super.call(this, destination) || this;
	        _this.hasFirst = false;
	        _this.observables = [];
	        _this.subscriptions = [];
	        return _this;
	    }
	    RaceSubscriber.prototype._next = function (observable) {
	        this.observables.push(observable);
	    };
	    RaceSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            for (var i = 0; i < len && !this.hasFirst; i++) {
	                var observable = observables[i];
	                var subscription = subscribeToResult(this, observable, observable, i);
	                if (this.subscriptions) {
	                    this.subscriptions.push(subscription);
	                }
	                this.add(subscription);
	            }
	            this.observables = null;
	        }
	    };
	    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (!this.hasFirst) {
	            this.hasFirst = true;
	            for (var i = 0; i < this.subscriptions.length; i++) {
	                if (i !== outerIndex) {
	                    var subscription = this.subscriptions[i];
	                    subscription.unsubscribe();
	                    this.remove(subscription);
	                }
	            }
	            this.subscriptions = null;
	        }
	        this.destination.next(innerValue);
	    };
	    return RaceSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
	function range(start, count, scheduler) {
	    if (start === void 0) {
	        start = 0;
	    }
	    return new Observable(function (subscriber) {
	        if (count === undefined) {
	            count = start;
	            start = 0;
	        }
	        var index = 0;
	        var current = start;
	        if (scheduler) {
	            return scheduler.schedule(dispatch$6, 0, {
	                index: index, count: count, start: start, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                if (index++ >= count) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(current++);
	                if (subscriber.closed) {
	                    break;
	                }
	            } while (true);
	        }
	        return undefined;
	    });
	}
	function dispatch$6(state) {
	    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
	    if (index >= count) {
	        subscriber.complete();
	        return;
	    }
	    subscriber.next(start);
	    if (subscriber.closed) {
	        return;
	    }
	    state.index = index + 1;
	    state.start = start + 1;
	    this.schedule(state);
	}

	/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
	function timer(dueTime, periodOrScheduler, scheduler) {
	    if (dueTime === void 0) {
	        dueTime = 0;
	    }
	    var period = -1;
	    if (isNumeric(periodOrScheduler)) {
	        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
	    }
	    else if (isScheduler(periodOrScheduler)) {
	        scheduler = periodOrScheduler;
	    }
	    if (!isScheduler(scheduler)) {
	        scheduler = async;
	    }
	    return new Observable(function (subscriber) {
	        var due = isNumeric(dueTime)
	            ? dueTime
	            : (+dueTime - scheduler.now());
	        return scheduler.schedule(dispatch$7, due, {
	            index: 0, period: period, subscriber: subscriber
	        });
	    });
	}
	function dispatch$7(state) {
	    var index = state.index, period = state.period, subscriber = state.subscriber;
	    subscriber.next(index);
	    if (subscriber.closed) {
	        return;
	    }
	    else if (period === -1) {
	        return subscriber.complete();
	    }
	    state.index = index + 1;
	    this.schedule(state, period);
	}

	/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
	function using(resourceFactory, observableFactory) {
	    return new Observable(function (subscriber) {
	        var resource;
	        try {
	            resource = resourceFactory();
	        }
	        catch (err) {
	            subscriber.error(err);
	            return undefined;
	        }
	        var result;
	        try {
	            result = observableFactory(resource);
	        }
	        catch (err) {
	            subscriber.error(err);
	            return undefined;
	        }
	        var source = result ? from(result) : EMPTY;
	        var subscription = source.subscribe(subscriber);
	        return function () {
	            subscription.unsubscribe();
	            if (resource) {
	                resource.unsubscribe();
	            }
	        };
	    });
	}

	/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
	function zip() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    var resultSelector = observables[observables.length - 1];
	    if (typeof resultSelector === 'function') {
	        observables.pop();
	    }
	    return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
	}
	var ZipOperator = /*@__PURE__*/ (function () {
	    function ZipOperator(resultSelector) {
	        this.resultSelector = resultSelector;
	    }
	    ZipOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
	    };
	    return ZipOperator;
	}());
	var ZipSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ZipSubscriber, _super);
	    function ZipSubscriber(destination, resultSelector, values) {
	        if (values === void 0) {
	            values = Object.create(null);
	        }
	        var _this = _super.call(this, destination) || this;
	        _this.iterators = [];
	        _this.active = 0;
	        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
	        _this.values = values;
	        return _this;
	    }
	    ZipSubscriber.prototype._next = function (value) {
	        var iterators = this.iterators;
	        if (isArray(value)) {
	            iterators.push(new StaticArrayIterator(value));
	        }
	        else if (typeof value[iterator] === 'function') {
	            iterators.push(new StaticIterator(value[iterator]()));
	        }
	        else {
	            iterators.push(new ZipBufferIterator(this.destination, this, value));
	        }
	    };
	    ZipSubscriber.prototype._complete = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        this.unsubscribe();
	        if (len === 0) {
	            this.destination.complete();
	            return;
	        }
	        this.active = len;
	        for (var i = 0; i < len; i++) {
	            var iterator$$1 = iterators[i];
	            if (iterator$$1.stillUnsubscribed) {
	                var destination = this.destination;
	                destination.add(iterator$$1.subscribe(iterator$$1, i));
	            }
	            else {
	                this.active--;
	            }
	        }
	    };
	    ZipSubscriber.prototype.notifyInactive = function () {
	        this.active--;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ZipSubscriber.prototype.checkIterators = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        var destination = this.destination;
	        for (var i = 0; i < len; i++) {
	            var iterator$$1 = iterators[i];
	            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
	                return;
	            }
	        }
	        var shouldComplete = false;
	        var args = [];
	        for (var i = 0; i < len; i++) {
	            var iterator$$1 = iterators[i];
	            var result = iterator$$1.next();
	            if (iterator$$1.hasCompleted()) {
	                shouldComplete = true;
	            }
	            if (result.done) {
	                destination.complete();
	                return;
	            }
	            args.push(result.value);
	        }
	        if (this.resultSelector) {
	            this._tryresultSelector(args);
	        }
	        else {
	            destination.next(args);
	        }
	        if (shouldComplete) {
	            destination.complete();
	        }
	    };
	    ZipSubscriber.prototype._tryresultSelector = function (args) {
	        var result;
	        try {
	            result = this.resultSelector.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return ZipSubscriber;
	}(Subscriber));
	var StaticIterator = /*@__PURE__*/ (function () {
	    function StaticIterator(iterator$$1) {
	        this.iterator = iterator$$1;
	        this.nextResult = iterator$$1.next();
	    }
	    StaticIterator.prototype.hasValue = function () {
	        return true;
	    };
	    StaticIterator.prototype.next = function () {
	        var result = this.nextResult;
	        this.nextResult = this.iterator.next();
	        return result;
	    };
	    StaticIterator.prototype.hasCompleted = function () {
	        var nextResult = this.nextResult;
	        return nextResult && nextResult.done;
	    };
	    return StaticIterator;
	}());
	var StaticArrayIterator = /*@__PURE__*/ (function () {
	    function StaticArrayIterator(array) {
	        this.array = array;
	        this.index = 0;
	        this.length = 0;
	        this.length = array.length;
	    }
	    StaticArrayIterator.prototype[iterator] = function () {
	        return this;
	    };
	    StaticArrayIterator.prototype.next = function (value) {
	        var i = this.index++;
	        var array = this.array;
	        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
	    };
	    StaticArrayIterator.prototype.hasValue = function () {
	        return this.array.length > this.index;
	    };
	    StaticArrayIterator.prototype.hasCompleted = function () {
	        return this.array.length === this.index;
	    };
	    return StaticArrayIterator;
	}());
	var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
	    __extends(ZipBufferIterator, _super);
	    function ZipBufferIterator(destination, parent, observable) {
	        var _this = _super.call(this, destination) || this;
	        _this.parent = parent;
	        _this.observable = observable;
	        _this.stillUnsubscribed = true;
	        _this.buffer = [];
	        _this.isComplete = false;
	        return _this;
	    }
	    ZipBufferIterator.prototype[iterator] = function () {
	        return this;
	    };
	    ZipBufferIterator.prototype.next = function () {
	        var buffer = this.buffer;
	        if (buffer.length === 0 && this.isComplete) {
	            return { value: null, done: true };
	        }
	        else {
	            return { value: buffer.shift(), done: false };
	        }
	    };
	    ZipBufferIterator.prototype.hasValue = function () {
	        return this.buffer.length > 0;
	    };
	    ZipBufferIterator.prototype.hasCompleted = function () {
	        return this.buffer.length === 0 && this.isComplete;
	    };
	    ZipBufferIterator.prototype.notifyComplete = function () {
	        if (this.buffer.length > 0) {
	            this.isComplete = true;
	            this.parent.notifyInactive();
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.buffer.push(innerValue);
	        this.parent.checkIterators();
	    };
	    ZipBufferIterator.prototype.subscribe = function (value, index) {
	        return subscribeToResult(this, this.observable, this, index);
	    };
	    return ZipBufferIterator;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	var rxjs_1 = /*#__PURE__*/Object.freeze({
		Observable: Observable,
		ConnectableObservable: ConnectableObservable,
		GroupedObservable: GroupedObservable,
		observable: observable,
		Subject: Subject,
		BehaviorSubject: BehaviorSubject,
		ReplaySubject: ReplaySubject,
		AsyncSubject: AsyncSubject,
		asapScheduler: asap,
		asyncScheduler: async,
		queueScheduler: queue,
		animationFrameScheduler: animationFrame,
		VirtualTimeScheduler: VirtualTimeScheduler,
		VirtualAction: VirtualAction,
		Scheduler: Scheduler,
		Subscription: Subscription,
		Subscriber: Subscriber,
		Notification: Notification,
		pipe: pipe,
		noop: noop,
		identity: identity,
		isObservable: isObservable,
		ArgumentOutOfRangeError: ArgumentOutOfRangeError,
		EmptyError: EmptyError,
		ObjectUnsubscribedError: ObjectUnsubscribedError,
		UnsubscriptionError: UnsubscriptionError,
		TimeoutError: TimeoutError,
		bindCallback: bindCallback,
		bindNodeCallback: bindNodeCallback,
		combineLatest: combineLatest,
		concat: concat,
		defer: defer,
		empty: empty$1,
		forkJoin: forkJoin,
		from: from,
		fromEvent: fromEvent,
		fromEventPattern: fromEventPattern,
		generate: generate,
		iif: iif,
		interval: interval,
		merge: merge,
		never: never,
		of: of,
		onErrorResumeNext: onErrorResumeNext,
		pairs: pairs,
		race: race,
		range: range,
		throwError: throwError,
		timer: timer,
		using: using,
		zip: zip,
		EMPTY: EMPTY,
		NEVER: NEVER,
		config: config
	});

	var cometd = createCommonjsModule(function (module, exports) {
	/*
	 * Copyright (c) 2008-2018 the original author or authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/* CometD Version 3.1.4 */

	(function(root, factory){
	    {
	        // CommonJS.
	        module.exports = factory();
	    }
	}(commonjsGlobal, function() {
	    /**
	     * Utility functions.
	     */
	    var Utils = {
	        isString: function(value) {
	            if (value === undefined || value === null) {
	                return false;
	            }
	            return typeof value === 'string' || value instanceof String;
	        },
	        isArray: function(value) {
	            if (value === undefined || value === null) {
	                return false;
	            }
	            return value instanceof Array;
	        },
	        /**
	         * Returns whether the given element is contained into the given array.
	         * @param element the element to check presence for
	         * @param array the array to check for the element presence
	         * @return the index of the element, if present, or a negative index if the element is not present
	         */
	        inArray: function(element, array) {
	            for (var i = 0; i < array.length; ++i) {
	                if (element === array[i]) {
	                    return i;
	                }
	            }
	            return -1;
	        },
	        setTimeout: function(cometd, funktion, delay) {
	            return window.setTimeout(function() {
	                try {
	                    cometd._debug('Invoking timed function', funktion);
	                    funktion();
	                } catch (x) {
	                    cometd._debug('Exception invoking timed function', funktion, x);
	                }
	            }, delay);
	        },
	        clearTimeout: function(timeoutHandle) {
	            window.clearTimeout(timeoutHandle);
	        }
	    };


	    /**
	     * A registry for transports used by the CometD object.
	     */
	    var TransportRegistry = function() {
	        var _types = [];
	        var _transports = {};

	        this.getTransportTypes = function() {
	            return _types.slice(0);
	        };

	        this.findTransportTypes = function(version, crossDomain, url) {
	            var result = [];
	            for (var i = 0; i < _types.length; ++i) {
	                var type = _types[i];
	                if (_transports[type].accept(version, crossDomain, url) === true) {
	                    result.push(type);
	                }
	            }
	            return result;
	        };

	        this.negotiateTransport = function(types, version, crossDomain, url) {
	            for (var i = 0; i < _types.length; ++i) {
	                var type = _types[i];
	                for (var j = 0; j < types.length; ++j) {
	                    if (type === types[j]) {
	                        var transport = _transports[type];
	                        if (transport.accept(version, crossDomain, url) === true) {
	                            return transport;
	                        }
	                    }
	                }
	            }
	            return null;
	        };

	        this.add = function(type, transport, index) {
	            var existing = false;
	            for (var i = 0; i < _types.length; ++i) {
	                if (_types[i] === type) {
	                    existing = true;
	                    break;
	                }
	            }

	            if (!existing) {
	                if (typeof index !== 'number') {
	                    _types.push(type);
	                } else {
	                    _types.splice(index, 0, type);
	                }
	                _transports[type] = transport;
	            }

	            return !existing;
	        };

	        this.find = function(type) {
	            for (var i = 0; i < _types.length; ++i) {
	                if (_types[i] === type) {
	                    return _transports[type];
	                }
	            }
	            return null;
	        };

	        this.remove = function(type) {
	            for (var i = 0; i < _types.length; ++i) {
	                if (_types[i] === type) {
	                    _types.splice(i, 1);
	                    var transport = _transports[type];
	                    delete _transports[type];
	                    return transport;
	                }
	            }
	            return null;
	        };

	        this.clear = function() {
	            _types = [];
	            _transports = {};
	        };

	        this.reset = function(init) {
	            for (var i = 0; i < _types.length; ++i) {
	                _transports[_types[i]].reset(init);
	            }
	        };
	    };


	    /**
	     * Base object with the common functionality for transports.
	     */
	    var Transport = function() {
	        var _type;
	        var _cometd;
	        var _url;

	        /**
	         * Function invoked just after a transport has been successfully registered.
	         * @param type the type of transport (for example 'long-polling')
	         * @param cometd the cometd object this transport has been registered to
	         * @see #unregistered()
	         */
	        this.registered = function(type, cometd) {
	            _type = type;
	            _cometd = cometd;
	        };

	        /**
	         * Function invoked just after a transport has been successfully unregistered.
	         * @see #registered(type, cometd)
	         */
	        this.unregistered = function() {
	            _type = null;
	            _cometd = null;
	        };

	        this._debug = function() {
	            _cometd._debug.apply(_cometd, arguments);
	        };

	        this._mixin = function() {
	            return _cometd._mixin.apply(_cometd, arguments);
	        };

	        this.getConfiguration = function() {
	            return _cometd.getConfiguration();
	        };

	        this.getAdvice = function() {
	            return _cometd.getAdvice();
	        };

	        this.setTimeout = function(funktion, delay) {
	            return Utils.setTimeout(_cometd, funktion, delay);
	        };

	        this.clearTimeout = function(handle) {
	            Utils.clearTimeout(handle);
	        };

	        /**
	         * Converts the given response into an array of bayeux messages
	         * @param response the response to convert
	         * @return an array of bayeux messages obtained by converting the response
	         */
	        this.convertToMessages = function(response) {
	            if (Utils.isString(response)) {
	                try {
	                    return JSON.parse(response);
	                } catch (x) {
	                    this._debug('Could not convert to JSON the following string', '"' + response + '"');
	                    throw x;
	                }
	            }
	            if (Utils.isArray(response)) {
	                return response;
	            }
	            if (response === undefined || response === null) {
	                return [];
	            }
	            if (response instanceof Object) {
	                return [response];
	            }
	            throw 'Conversion Error ' + response + ', typeof ' + (typeof response);
	        };

	        /**
	         * Returns whether this transport can work for the given version and cross domain communication case.
	         * @param version a string indicating the transport version
	         * @param crossDomain a boolean indicating whether the communication is cross domain
	         * @param url the URL to connect to
	         * @return true if this transport can work for the given version and cross domain communication case,
	         * false otherwise
	         */
	        this.accept = function(version, crossDomain, url) {
	            throw 'Abstract';
	        };

	        /**
	         * Returns the type of this transport.
	         * @see #registered(type, cometd)
	         */
	        this.getType = function() {
	            return _type;
	        };

	        this.getURL = function() {
	            return _url;
	        };

	        this.setURL = function(url) {
	            _url = url;
	        };

	        this.send = function(envelope, metaConnect) {
	            throw 'Abstract';
	        };

	        this.reset = function(init) {
	            this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');
	        };

	        this.abort = function() {
	            this._debug('Transport', _type, 'aborted');
	        };

	        this.toString = function() {
	            return this.getType();
	        };
	    };

	    Transport.derive = function(baseObject) {
	        function F() {
	        }

	        F.prototype = baseObject;
	        return new F();
	    };


	    /**
	     * Base object with the common functionality for transports based on requests.
	     * The key responsibility is to allow at most 2 outstanding requests to the server,
	     * to avoid that requests are sent behind a long poll.
	     * To achieve this, we have one reserved request for the long poll, and all other
	     * requests are serialized one after the other.
	     */
	    var RequestTransport = function() {
	        var _super = new Transport();
	        var _self = Transport.derive(_super);
	        var _requestIds = 0;
	        var _metaConnectRequest = null;
	        var _requests = [];
	        var _envelopes = [];

	        function _coalesceEnvelopes(envelope) {
	            while (_envelopes.length > 0) {
	                var envelopeAndRequest = _envelopes[0];
	                var newEnvelope = envelopeAndRequest[0];
	                var newRequest = envelopeAndRequest[1];
	                if (newEnvelope.url === envelope.url &&
	                    newEnvelope.sync === envelope.sync) {
	                    _envelopes.shift();
	                    envelope.messages = envelope.messages.concat(newEnvelope.messages);
	                    this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
	                    continue;
	                }
	                break;
	            }
	        }

	        function _transportSend(envelope, request) {
	            this.transportSend(envelope, request);
	            request.expired = false;

	            if (!envelope.sync) {
	                var maxDelay = this.getConfiguration().maxNetworkDelay;
	                var delay = maxDelay;
	                if (request.metaConnect === true) {
	                    delay += this.getAdvice().timeout;
	                }

	                this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);

	                var self = this;
	                request.timeout = this.setTimeout(function() {
	                    request.expired = true;
	                    var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
	                    var failure = {
	                        reason: errorMessage
	                    };
	                    var xhr = request.xhr;
	                    failure.httpCode = self.xhrStatus(xhr);
	                    self.abortXHR(xhr);
	                    self._debug(errorMessage);
	                    self.complete(request, false, request.metaConnect);
	                    envelope.onFailure(xhr, envelope.messages, failure);
	                }, delay);
	            }
	        }

	        function _queueSend(envelope) {
	            var requestId = ++_requestIds;
	            var request = {
	                id: requestId,
	                metaConnect: false,
	                envelope: envelope
	            };

	            // Consider the metaConnect requests which should always be present
	            if (_requests.length < this.getConfiguration().maxConnections - 1) {
	                _requests.push(request);
	                _transportSend.call(this, envelope, request);
	            } else {
	                this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
	                _envelopes.push([envelope, request]);
	            }
	        }

	        function _metaConnectComplete(request) {
	            var requestId = request.id;
	            this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
	            if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
	                throw 'Longpoll request mismatch, completing request ' + requestId;
	            }

	            // Reset metaConnect request
	            _metaConnectRequest = null;
	        }

	        function _complete(request, success) {
	            var index = Utils.inArray(request, _requests);
	            // The index can be negative if the request has been aborted
	            if (index >= 0) {
	                _requests.splice(index, 1);
	            }

	            if (_envelopes.length > 0) {
	                var envelopeAndRequest = _envelopes.shift();
	                var nextEnvelope = envelopeAndRequest[0];
	                var nextRequest = envelopeAndRequest[1];
	                this._debug('Transport dequeued request', nextRequest.id);
	                if (success) {
	                    if (this.getConfiguration().autoBatch) {
	                        _coalesceEnvelopes.call(this, nextEnvelope);
	                    }
	                    _queueSend.call(this, nextEnvelope);
	                    this._debug('Transport completed request', request.id, nextEnvelope);
	                } else {
	                    // Keep the semantic of calling response callbacks asynchronously after the request
	                    var self = this;
	                    this.setTimeout(function() {
	                        self.complete(nextRequest, false, nextRequest.metaConnect);
	                        var failure = {
	                            reason: 'Previous request failed'
	                        };
	                        var xhr = nextRequest.xhr;
	                        failure.httpCode = self.xhrStatus(xhr);
	                        nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
	                    }, 0);
	                }
	            }
	        }

	        _self.complete = function(request, success, metaConnect) {
	            if (metaConnect) {
	                _metaConnectComplete.call(this, request);
	            } else {
	                _complete.call(this, request, success);
	            }
	        };

	        /**
	         * Performs the actual send depending on the transport type details.
	         * @param envelope the envelope to send
	         * @param request the request information
	         */
	        _self.transportSend = function(envelope, request) {
	            throw 'Abstract';
	        };

	        _self.transportSuccess = function(envelope, request, responses) {
	            if (!request.expired) {
	                this.clearTimeout(request.timeout);
	                this.complete(request, true, request.metaConnect);
	                if (responses && responses.length > 0) {
	                    envelope.onSuccess(responses);
	                } else {
	                    envelope.onFailure(request.xhr, envelope.messages, {
	                        httpCode: 204
	                    });
	                }
	            }
	        };

	        _self.transportFailure = function(envelope, request, failure) {
	            if (!request.expired) {
	                this.clearTimeout(request.timeout);
	                this.complete(request, false, request.metaConnect);
	                envelope.onFailure(request.xhr, envelope.messages, failure);
	            }
	        };

	        function _metaConnectSend(envelope) {
	            if (_metaConnectRequest !== null) {
	                throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
	            }

	            var requestId = ++_requestIds;
	            this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
	            var request = {
	                id: requestId,
	                metaConnect: true,
	                envelope: envelope
	            };
	            _transportSend.call(this, envelope, request);
	            _metaConnectRequest = request;
	        }

	        _self.send = function(envelope, metaConnect) {
	            if (metaConnect) {
	                _metaConnectSend.call(this, envelope);
	            } else {
	                _queueSend.call(this, envelope);
	            }
	        };

	        _self.abort = function() {
	            _super.abort();
	            for (var i = 0; i < _requests.length; ++i) {
	                var request = _requests[i];
	                if (request) {
	                    this._debug('Aborting request', request);
	                    if (!this.abortXHR(request.xhr)) {
	                        this.transportFailure(request.envelope, request, {reason: 'abort'});
	                    }
	                }
	            }
	            var metaConnectRequest = _metaConnectRequest;
	            if (metaConnectRequest) {
	                this._debug('Aborting metaConnect request', metaConnectRequest);
	                if (!this.abortXHR(metaConnectRequest.xhr)) {
	                    this.transportFailure(metaConnectRequest.envelope, metaConnectRequest, {reason: 'abort'});
	                }
	            }
	            this.reset(true);
	        };

	        _self.reset = function(init) {
	            _super.reset(init);
	            _metaConnectRequest = null;
	            _requests = [];
	            _envelopes = [];
	        };

	        _self.abortXHR = function(xhr) {
	            if (xhr) {
	                try {
	                    var state = xhr.readyState;
	                    xhr.abort();
	                    return state !== window.XMLHttpRequest.UNSENT;
	                } catch (x) {
	                    this._debug(x);
	                }
	            }
	            return false;
	        };

	        _self.xhrStatus = function(xhr) {
	            if (xhr) {
	                try {
	                    return xhr.status;
	                } catch (x) {
	                    this._debug(x);
	                }
	            }
	            return -1;
	        };

	        return _self;
	    };


	    var LongPollingTransport = function() {
	        var _super = new RequestTransport();
	        var _self = Transport.derive(_super);
	        // By default, support cross domain
	        var _supportsCrossDomain = true;

	        _self.accept = function(version, crossDomain, url) {
	            return _supportsCrossDomain || !crossDomain;
	        };

	        _self.newXMLHttpRequest = function() {
	            return new window.XMLHttpRequest();
	        };

	        _self.xhrSend = function(packet) {
	            var xhr = _self.newXMLHttpRequest();
	            // Copy external context, to be used in other environments.
	            xhr.context = _self.context;
	            xhr.withCredentials = true;
	            xhr.open('POST', packet.url, packet.sync !== true);
	            var headers = packet.headers;
	            if (headers) {
	                for (var headerName in headers) {
	                    if (headers.hasOwnProperty(headerName)) {
	                        xhr.setRequestHeader(headerName, headers[headerName]);
	                    }
	                }
	            }
	            xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
	            xhr.onload = function() {
	                if (xhr.status === 200) {
	                    packet.onSuccess(xhr.responseText);
	                } else {
	                    packet.onError(xhr.statusText);
	                }
	            };
	            xhr.onerror = function() {
	                packet.onError(xhr.statusText);
	            };
	            xhr.send(packet.body);
	            return xhr;
	        };

	        _self.transportSend = function(envelope, request) {
	            this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);

	            var self = this;
	            try {
	                var sameStack = true;
	                request.xhr = this.xhrSend({
	                    transport: this,
	                    url: envelope.url,
	                    sync: envelope.sync,
	                    headers: this.getConfiguration().requestHeaders,
	                    body: JSON.stringify(envelope.messages),
	                    onSuccess: function(response) {
	                        self._debug('Transport', self.getType(), 'received response', response);
	                        var success = false;
	                        try {
	                            var received = self.convertToMessages(response);
	                            if (received.length === 0) {
	                                _supportsCrossDomain = false;
	                                self.transportFailure(envelope, request, {
	                                    httpCode: 204
	                                });
	                            } else {
	                                success = true;
	                                self.transportSuccess(envelope, request, received);
	                            }
	                        } catch (x) {
	                            self._debug(x);
	                            if (!success) {
	                                _supportsCrossDomain = false;
	                                var failure = {
	                                    exception: x
	                                };
	                                failure.httpCode = self.xhrStatus(request.xhr);
	                                self.transportFailure(envelope, request, failure);
	                            }
	                        }
	                    },
	                    onError: function(reason, exception) {
	                        self._debug('Transport', self.getType(), 'received error', reason, exception);
	                        _supportsCrossDomain = false;
	                        var failure = {
	                            reason: reason,
	                            exception: exception
	                        };
	                        failure.httpCode = self.xhrStatus(request.xhr);
	                        if (sameStack) {
	                            // Keep the semantic of calling response callbacks asynchronously after the request
	                            self.setTimeout(function() {
	                                self.transportFailure(envelope, request, failure);
	                            }, 0);
	                        } else {
	                            self.transportFailure(envelope, request, failure);
	                        }
	                    }
	                });
	                sameStack = false;
	            } catch (x) {
	                _supportsCrossDomain = false;
	                // Keep the semantic of calling response callbacks asynchronously after the request
	                this.setTimeout(function() {
	                    self.transportFailure(envelope, request, {
	                        exception: x
	                    });
	                }, 0);
	            }
	        };

	        _self.reset = function(init) {
	            _super.reset(init);
	            _supportsCrossDomain = true;
	        };

	        return _self;
	    };


	    var CallbackPollingTransport = function() {
	        var _super = new RequestTransport();
	        var _self = Transport.derive(_super);
	        var jsonp = 0;

	        _self.accept = function(version, crossDomain, url) {
	            return true;
	        };

	        _self.jsonpSend = function(packet) {
	            var head = document.getElementsByTagName('head')[0];
	            var script = document.createElement('script');

	            var callbackName = '_cometd_jsonp_' + jsonp++;
	            window[callbackName] = function(responseText) {
	                head.removeChild(script);
	                delete window[callbackName];
	                packet.onSuccess(responseText);
	            };

	            var url = packet.url;
	            url += url.indexOf('?') < 0 ? '?' : '&';
	            url += 'jsonp=' + callbackName;
	            url += '&message=' + encodeURIComponent(packet.body);
	            script.src = url;
	            script.async = packet.sync !== true;
	            script.type = 'application/javascript';
	            script.onerror = function(e) {
	                packet.onError('jsonp ' + e.type);
	            };
	            head.appendChild(script);
	        };

	        function _failTransportFn(envelope, request, x) {
	            var self = this;
	            return function() {
	                self.transportFailure(envelope, request, 'error', x);
	            };
	        }

	        _self.transportSend = function(envelope, request) {
	            var self = this;

	            // Microsoft Internet Explorer has a 2083 URL max length
	            // We must ensure that we stay within that length
	            var start = 0;
	            var length = envelope.messages.length;
	            var lengths = [];
	            while (length > 0) {
	                // Encode the messages because all brackets, quotes, commas, colons, etc
	                // present in the JSON will be URL encoded, taking many more characters
	                var json = JSON.stringify(envelope.messages.slice(start, start + length));
	                var urlLength = envelope.url.length + encodeURI(json).length;

	                var maxLength = this.getConfiguration().maxURILength;
	                if (urlLength > maxLength) {
	                    if (length === 1) {
	                        var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' +
	                            'for transport ' + this.getType();
	                        // Keep the semantic of calling response callbacks asynchronously after the request
	                        this.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);
	                        return;
	                    }

	                    --length;
	                    continue;
	                }

	                lengths.push(length);
	                start += length;
	                length = envelope.messages.length - start;
	            }

	            // Here we are sure that the messages can be sent within the URL limit

	            var envelopeToSend = envelope;
	            if (lengths.length > 1) {
	                var begin = 0;
	                var end = lengths[0];
	                this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
	                envelopeToSend = this._mixin(false, {}, envelope);
	                envelopeToSend.messages = envelope.messages.slice(begin, end);
	                envelopeToSend.onSuccess = envelope.onSuccess;
	                envelopeToSend.onFailure = envelope.onFailure;

	                for (var i = 1; i < lengths.length; ++i) {
	                    var nextEnvelope = this._mixin(false, {}, envelope);
	                    begin = end;
	                    end += lengths[i];
	                    nextEnvelope.messages = envelope.messages.slice(begin, end);
	                    nextEnvelope.onSuccess = envelope.onSuccess;
	                    nextEnvelope.onFailure = envelope.onFailure;
	                    this.send(nextEnvelope, request.metaConnect);
	                }
	            }

	            this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);

	            try {
	                var sameStack = true;
	                this.jsonpSend({
	                    transport: this,
	                    url: envelopeToSend.url,
	                    sync: envelopeToSend.sync,
	                    headers: this.getConfiguration().requestHeaders,
	                    body: JSON.stringify(envelopeToSend.messages),
	                    onSuccess: function(responses) {
	                        var success = false;
	                        try {
	                            var received = self.convertToMessages(responses);
	                            if (received.length === 0) {
	                                self.transportFailure(envelopeToSend, request, {
	                                    httpCode: 204
	                                });
	                            } else {
	                                success = true;
	                                self.transportSuccess(envelopeToSend, request, received);
	                            }
	                        } catch (x) {
	                            self._debug(x);
	                            if (!success) {
	                                self.transportFailure(envelopeToSend, request, {
	                                    exception: x
	                                });
	                            }
	                        }
	                    },
	                    onError: function(reason, exception) {
	                        var failure = {
	                            reason: reason,
	                            exception: exception
	                        };
	                        if (sameStack) {
	                            // Keep the semantic of calling response callbacks asynchronously after the request
	                            self.setTimeout(function() {
	                                self.transportFailure(envelopeToSend, request, failure);
	                            }, 0);
	                        } else {
	                            self.transportFailure(envelopeToSend, request, failure);
	                        }
	                    }
	                });
	                sameStack = false;
	            } catch (xx) {
	                // Keep the semantic of calling response callbacks asynchronously after the request
	                this.setTimeout(function() {
	                    self.transportFailure(envelopeToSend, request, {
	                        exception: xx
	                    });
	                }, 0);
	            }
	        };

	        return _self;
	    };


	    var WebSocketTransport = function() {
	        var _super = new Transport();
	        var _self = Transport.derive(_super);
	        var _cometd;
	        // By default WebSocket is supported
	        var _webSocketSupported = true;
	        // Whether we were able to establish a WebSocket connection
	        var _webSocketConnected = false;
	        var _stickyReconnect = true;
	        // The context contains the envelopes that have been sent
	        // and the timeouts for the messages that have been sent.
	        var _context = null;
	        var _connecting = null;
	        var _connected = false;
	        var _successCallback = null;

	        _self.reset = function(init) {
	            _super.reset(init);
	            _webSocketSupported = true;
	            if (init) {
	                _webSocketConnected = false;
	            }
	            _stickyReconnect = true;
	            _context = null;
	            _connecting = null;
	            _connected = false;
	        };

	        function _forceClose(context, event) {
	            if (context) {
	                this.webSocketClose(context, event.code, event.reason);
	                // Force immediate failure of pending messages to trigger reconnect.
	                // This is needed because the server may not reply to our close()
	                // and therefore the onclose function is never called.
	                this.onClose(context, event);
	            }
	        }

	        function _sameContext(context) {
	            return context === _connecting || context === _context;
	        }

	        function _storeEnvelope(context, envelope, metaConnect) {
	            var messageIds = [];
	            for (var i = 0; i < envelope.messages.length; ++i) {
	                var message = envelope.messages[i];
	                if (message.id) {
	                    messageIds.push(message.id);
	                }
	            }
	            context.envelopes[messageIds.join(',')] = [envelope, metaConnect];
	            this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);
	        }

	        function _websocketConnect(context) {
	            // We may have multiple attempts to open a WebSocket
	            // connection, for example a /meta/connect request that
	            // may take time, along with a user-triggered publish.
	            // Early return if we are already connecting.
	            if (_connecting) {
	                return;
	            }

	            // Mangle the URL, changing the scheme from 'http' to 'ws'.
	            var url = _cometd.getURL().replace(/^http/, 'ws');
	            this._debug('Transport', this.getType(), 'connecting to URL', url);

	            try {
	                var protocol = _cometd.getConfiguration().protocol;
	                context.webSocket = protocol ? new window.WebSocket(url, protocol) : new window.WebSocket(url);
	                _connecting = context;
	            } catch (x) {
	                _webSocketSupported = false;
	                this._debug('Exception while creating WebSocket object', x);
	                throw x;
	            }

	            // By default use sticky reconnects.
	            _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;

	            var self = this;
	            var connectTimeout = _cometd.getConfiguration().connectTimeout;
	            if (connectTimeout > 0) {
	                context.connectTimer = this.setTimeout(function() {
	                    _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
	                    // The connection was not opened, close anyway.
	                    _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});
	                }, connectTimeout);
	            }

	            var onopen = function() {
	                _cometd._debug('WebSocket onopen', context);
	                if (context.connectTimer) {
	                    self.clearTimeout(context.connectTimer);
	                }

	                if (_sameContext(context)) {
	                    _connecting = null;
	                    _context = context;
	                    _webSocketConnected = true;
	                    self.onOpen(context);
	                } else {
	                    // We have a valid connection already, close this one.
	                    _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);
	                    _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});
	                }
	            };

	            // This callback is invoked when the server sends the close frame.
	            // The close frame for a connection may arrive *after* another
	            // connection has been opened, so we must make sure that actions
	            // are performed only if it's the same connection.
	            var onclose = function(event) {
	                event = event || {code: 1000};
	                _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);

	                if (context.connectTimer) {
	                    self.clearTimeout(context.connectTimer);
	                }

	                self.onClose(context, event);
	            };

	            var onmessage = function(wsMessage) {
	                _cometd._debug('WebSocket onmessage', wsMessage, context);
	                self.onMessage(context, wsMessage);
	            };

	            context.webSocket.onopen = onopen;
	            context.webSocket.onclose = onclose;
	            context.webSocket.onerror = function() {
	                // Clients should call onclose(), but if they do not we do it here for safety.
	                onclose({code: 1000, reason: 'Error'});
	            };
	            context.webSocket.onmessage = onmessage;

	            this._debug('Transport', this.getType(), 'configured callbacks on', context);
	        }

	        function _webSocketSend(context, envelope, metaConnect) {
	            var json = JSON.stringify(envelope.messages);
	            context.webSocket.send(json);
	            this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);

	            // Manage the timeout waiting for the response.
	            var maxDelay = this.getConfiguration().maxNetworkDelay;
	            var delay = maxDelay;
	            if (metaConnect) {
	                delay += this.getAdvice().timeout;
	                _connected = true;
	            }

	            var self = this;
	            var messageIds = [];
	            for (var i = 0; i < envelope.messages.length; ++i) {
	                (function() {
	                    var message = envelope.messages[i];
	                    if (message.id) {
	                        messageIds.push(message.id);
	                        context.timeouts[message.id] = self.setTimeout(function() {
	                            _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);
	                            _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});
	                        }, delay);
	                    }
	                })();
	            }

	            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);
	        }

	        _self._notifySuccess = function(fn, messages) {
	            fn.call(this, messages);
	        };

	        _self._notifyFailure = function(fn, context, messages, failure) {
	            fn.call(this, context, messages, failure);
	        };

	        function _send(context, envelope, metaConnect) {
	            try {
	                if (context === null) {
	                    context = _connecting || {
	                            envelopes: {},
	                            timeouts: {}
	                        };
	                    _storeEnvelope.call(this, context, envelope, metaConnect);
	                    _websocketConnect.call(this, context);
	                } else {
	                    _storeEnvelope.call(this, context, envelope, metaConnect);
	                    _webSocketSend.call(this, context, envelope, metaConnect);
	                }
	            } catch (x) {
	                // Keep the semantic of calling response callbacks asynchronously after the request.
	                var self = this;
	                this.setTimeout(function() {
	                    _forceClose.call(self, context, {
	                        code: 1000,
	                        reason: 'Exception',
	                        exception: x
	                    });
	                }, 0);
	            }
	        }

	        _self.onOpen = function(context) {
	            var envelopes = context.envelopes;
	            this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);
	            for (var key in envelopes) {
	                if (envelopes.hasOwnProperty(key)) {
	                    var element = envelopes[key];
	                    var envelope = element[0];
	                    var metaConnect = element[1];
	                    // Store the success callback, which is independent from the envelope,
	                    // so that it can be used to notify arrival of messages.
	                    _successCallback = envelope.onSuccess;
	                    _webSocketSend.call(this, context, envelope, metaConnect);
	                }
	            }
	        };

	        _self.onMessage = function(context, wsMessage) {
	            this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);

	            var close = false;
	            var messages = this.convertToMessages(wsMessage.data);
	            var messageIds = [];
	            for (var i = 0; i < messages.length; ++i) {
	                var message = messages[i];

	                // Detect if the message is a response to a request we made.
	                // If it's a meta message, for sure it's a response; otherwise it's
	                // a publish message and publish responses don't have the data field.
	                if (/^\/meta\//.test(message.channel) || message.data === undefined) {
	                    if (message.id) {
	                        messageIds.push(message.id);

	                        var timeout = context.timeouts[message.id];
	                        if (timeout) {
	                            this.clearTimeout(timeout);
	                            delete context.timeouts[message.id];
	                            this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);
	                        }
	                    }
	                }

	                if ('/meta/connect' === message.channel) {
	                    _connected = false;
	                }
	                if ('/meta/disconnect' === message.channel && !_connected) {
	                    close = true;
	                }
	            }

	            // Remove the envelope corresponding to the messages.
	            var removed = false;
	            var envelopes = context.envelopes;
	            for (var j = 0; j < messageIds.length; ++j) {
	                var id = messageIds[j];
	                for (var key in envelopes) {
	                    if (envelopes.hasOwnProperty(key)) {
	                        var ids = key.split(',');
	                        var index = Utils.inArray(id, ids);
	                        if (index >= 0) {
	                            removed = true;
	                            ids.splice(index, 1);
	                            var envelope = envelopes[key][0];
	                            var metaConnect = envelopes[key][1];
	                            delete envelopes[key];
	                            if (ids.length > 0) {
	                                envelopes[ids.join(',')] = [envelope, metaConnect];
	                            }
	                            break;
	                        }
	                    }
	                }
	            }
	            if (removed) {
	                this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);
	            }

	            this._notifySuccess(_successCallback, messages);

	            if (close) {
	                this.webSocketClose(context, 1000, 'Disconnect');
	            }
	        };

	        _self.onClose = function(context, event) {
	            this._debug('Transport', this.getType(), 'closed', context, event);

	            if (_sameContext(context)) {
	                // Remember if we were able to connect.
	                // This close event could be due to server shutdown,
	                // and if it restarts we want to try websocket again.
	                _webSocketSupported = _stickyReconnect && _webSocketConnected;
	                _connecting = null;
	                _context = null;
	            }

	            var timeouts = context.timeouts;
	            context.timeouts = {};
	            for (var id in timeouts) {
	                if (timeouts.hasOwnProperty(id)) {
	                    this.clearTimeout(timeouts[id]);
	                }
	            }

	            var envelopes = context.envelopes;
	            context.envelopes = {};
	            for (var key in envelopes) {
	                if (envelopes.hasOwnProperty(key)) {
	                    var envelope = envelopes[key][0];
	                    var metaConnect = envelopes[key][1];
	                    if (metaConnect) {
	                        _connected = false;
	                    }
	                    var failure = {
	                        websocketCode: event.code,
	                        reason: event.reason
	                    };
	                    if (event.exception) {
	                        failure.exception = event.exception;
	                    }
	                    this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);
	                }
	            }
	        };

	        _self.registered = function(type, cometd) {
	            _super.registered(type, cometd);
	            _cometd = cometd;
	        };

	        _self.accept = function(version, crossDomain, url) {
	            this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);
	            // Using !! to return a boolean (and not the WebSocket object).
	            return _webSocketSupported && !!window.WebSocket && _cometd.websocketEnabled !== false;
	        };

	        _self.send = function(envelope, metaConnect) {
	            this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
	            _send.call(this, _context, envelope, metaConnect);
	        };

	        _self.webSocketClose = function(context, code, reason) {
	            try {
	                if (context.webSocket) {
	                    context.webSocket.close(code, reason);
	                }
	            } catch (x) {
	                this._debug(x);
	            }
	        };

	        _self.abort = function() {
	            _super.abort();
	            _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});
	            this.reset(true);
	        };

	        return _self;
	    };


	    /**
	     * The constructor for a CometD object, identified by an optional name.
	     * The default name is the string 'default'.
	     * @param name the optional name of this cometd object
	     */
	    var CometD = function (name) {
	        var _cometd = this;
	        var _name = name || 'default';
	        var _crossDomain = false;
	        var _transports = new TransportRegistry();
	        var _transport;
	        var _status = 'disconnected';
	        var _messageId = 0;
	        var _clientId = null;
	        var _batch = 0;
	        var _messageQueue = [];
	        var _internalBatch = false;
	        var _listenerId = 0;
	        var _listeners = {};
	        var _backoff = 0;
	        var _scheduledSend = null;
	        var _extensions = [];
	        var _advice = {};
	        var _handshakeProps;
	        var _handshakeCallback;
	        var _callbacks = {};
	        var _remoteCalls = {};
	        var _reestablish = false;
	        var _connected = false;
	        var _unconnectTime = 0;
	        var _handshakeMessages = 0;
	        var _config = {
	            protocol: null,
	            stickyReconnect: true,
	            connectTimeout: 0,
	            maxConnections: 2,
	            backoffIncrement: 1000,
	            maxBackoff: 60000,
	            logLevel: 'info',
	            maxNetworkDelay: 10000,
	            requestHeaders: {},
	            appendMessageTypeToURL: true,
	            autoBatch: false,
	            urls: {},
	            maxURILength: 2000,
	            advice: {
	                timeout: 60000,
	                interval: 0,
	                reconnect: undefined,
	                maxInterval: 0
	            }
	        };

	        function _fieldValue(object, name) {
	            try {
	                return object[name];
	            } catch (x) {
	                return undefined;
	            }
	        }

	        /**
	         * Mixes in the given objects into the target object by copying the properties.
	         * @param deep if the copy must be deep
	         * @param target the target object
	         * @param objects the objects whose properties are copied into the target
	         */
	        this._mixin = function(deep, target, objects) {
	            var result = target || {};

	            // Skip first 2 parameters (deep and target), and loop over the others
	            for (var i = 2; i < arguments.length; ++i) {
	                var object = arguments[i];

	                if (object === undefined || object === null) {
	                    continue;
	                }

	                for (var propName in object) {
	                    if (object.hasOwnProperty(propName)) {
	                        var prop = _fieldValue(object, propName);
	                        var targ = _fieldValue(result, propName);

	                        // Avoid infinite loops
	                        if (prop === target) {
	                            continue;
	                        }
	                        // Do not mixin undefined values
	                        if (prop === undefined) {
	                            continue;
	                        }

	                        if (deep && typeof prop === 'object' && prop !== null) {
	                            if (prop instanceof Array) {
	                                result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
	                            } else {
	                                var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
	                                result[propName] = this._mixin(deep, source, prop);
	                            }
	                        } else {
	                            result[propName] = prop;
	                        }
	                    }
	                }
	            }

	            return result;
	        };

	        function _isString(value) {
	            return Utils.isString(value);
	        }

	        function _isFunction(value) {
	            if (value === undefined || value === null) {
	                return false;
	            }
	            return typeof value === 'function';
	        }

	        function _zeroPad(value, length) {
	            var result = '';
	            while (--length > 0) {
	                if (value >= Math.pow(10, length)) {
	                    break;
	                }
	                result += '0';
	            }
	            result += value;
	            return result;
	        }

	        function _log(level, args) {
	            if (window.console) {
	                var logger = window.console[level];
	                if (_isFunction(logger)) {
	                    var now = new Date();
	                    [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +
	                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));
	                    logger.apply(window.console, args);
	                }
	            }
	        }

	        this._warn = function() {
	            _log('warn', arguments);
	        };

	        this._info = function() {
	            if (_config.logLevel !== 'warn') {
	                _log('info', arguments);
	            }
	        };

	        this._debug = function() {
	            if (_config.logLevel === 'debug') {
	                _log('debug', arguments);
	            }
	        };

	        function _splitURL(url) {
	            // [1] = protocol://,
	            // [2] = host:port,
	            // [3] = host,
	            // [4] = IPv6_host,
	            // [5] = IPv4_host,
	            // [6] = :port,
	            // [7] = port,
	            // [8] = uri,
	            // [9] = rest (query / fragment)
	            return /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
	        }

	        /**
	         * Returns whether the given hostAndPort is cross domain.
	         * The default implementation checks against window.location.host
	         * but this function can be overridden to make it work in non-browser
	         * environments.
	         *
	         * @param hostAndPort the host and port in format host:port
	         * @return whether the given hostAndPort is cross domain
	         */
	        this._isCrossDomain = function(hostAndPort) {
	            if (window.location && window.location.host) {
	                if (hostAndPort) {
	                    return hostAndPort !== window.location.host;
	                }
	            }
	            return false;
	        };

	        function _configure(configuration) {
	            _cometd._debug('Configuring cometd object with', configuration);
	            // Support old style param, where only the Bayeux server URL was passed
	            if (_isString(configuration)) {
	                configuration = { url: configuration };
	            }
	            if (!configuration) {
	                configuration = {};
	            }

	            _config = _cometd._mixin(false, _config, configuration);

	            var url = _cometd.getURL();
	            if (!url) {
	                throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
	            }

	            // Check if we're cross domain.
	            var urlParts = _splitURL(url);
	            var hostAndPort = urlParts[2];
	            var uri = urlParts[8];
	            var afterURI = urlParts[9];
	            _crossDomain = _cometd._isCrossDomain(hostAndPort);

	            // Check if appending extra path is supported
	            if (_config.appendMessageTypeToURL) {
	                if (afterURI !== undefined && afterURI.length > 0) {
	                    _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
	                    _config.appendMessageTypeToURL = false;
	                } else {
	                    var uriSegments = uri.split('/');
	                    var lastSegmentIndex = uriSegments.length - 1;
	                    if (uri.match(/\/$/)) {
	                        lastSegmentIndex -= 1;
	                    }
	                    if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {
	                        // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd
	                        // It will be difficult to add the extra path in this case
	                        _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
	                        _config.appendMessageTypeToURL = false;
	                    }
	                }
	            }
	        }

	        function _removeListener(subscription) {
	            if (subscription) {
	                var subscriptions = _listeners[subscription.channel];
	                if (subscriptions && subscriptions[subscription.id]) {
	                    delete subscriptions[subscription.id];
	                    _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
	                }
	            }
	        }

	        function _removeSubscription(subscription) {
	            if (subscription && !subscription.listener) {
	                _removeListener(subscription);
	            }
	        }

	        function _clearSubscriptions() {
	            for (var channel in _listeners) {
	                if (_listeners.hasOwnProperty(channel)) {
	                    var subscriptions = _listeners[channel];
	                    if (subscriptions) {
	                        for (var id in subscriptions) {
	                            if (subscriptions.hasOwnProperty(id)) {
	                                _removeSubscription(subscriptions[id]);
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        function _setStatus(newStatus) {
	            if (_status !== newStatus) {
	                _cometd._debug('Status', _status, '->', newStatus);
	                _status = newStatus;
	            }
	        }

	        function _isDisconnected() {
	            return _status === 'disconnecting' || _status === 'disconnected';
	        }

	        function _nextMessageId() {
	            var result = ++_messageId;
	            return '' + result;
	        }

	        function _applyExtension(scope, callback, name, message, outgoing) {
	            try {
	                return callback.call(scope, message);
	            } catch (x) {
	                var handler = _cometd.onExtensionException;
	                if (_isFunction(handler)) {
	                    _cometd._debug('Invoking extension exception handler', name, x);
	                    try {
	                        handler.call(_cometd, x, name, outgoing, message);
	                    } catch (xx) {
	                        _cometd._info('Exception during execution of extension exception handler', name, xx);
	                    }
	                } else {
	                    _cometd._info('Exception during execution of extension', name, x);
	                }
	                return message;
	            }
	        }

	        function _applyIncomingExtensions(message) {
	            for (var i = 0; i < _extensions.length; ++i) {
	                if (message === undefined || message === null) {
	                    break;
	                }

	                var extension = _extensions[i];
	                var callback = extension.extension.incoming;
	                if (_isFunction(callback)) {
	                    var result = _applyExtension(extension.extension, callback, extension.name, message, false);
	                    message = result === undefined ? message : result;
	                }
	            }
	            return message;
	        }

	        function _applyOutgoingExtensions(message) {
	            for (var i = _extensions.length - 1; i >= 0 ; --i) {
	                if (message === undefined || message === null) {
	                    break;
	                }

	                var extension = _extensions[i];
	                var callback = extension.extension.outgoing;
	                if (_isFunction(callback)) {
	                    var result = _applyExtension(extension.extension, callback, extension.name, message, true);
	                    message = result === undefined ? message : result;
	                }
	            }
	            return message;
	        }

	        function _notify(channel, message) {
	            var subscriptions = _listeners[channel];
	            if (subscriptions) {
	                for (var id in subscriptions) {
	                    if (subscriptions.hasOwnProperty(id)) {
	                        var subscription = subscriptions[id];
	                        // Subscriptions may come and go, so the array may have 'holes'
	                        if (subscription) {
	                            try {
	                                subscription.callback.call(subscription.scope, message);
	                            } catch (x) {
	                                var handler = _cometd.onListenerException;
	                                if (_isFunction(handler)) {
	                                    _cometd._debug('Invoking listener exception handler', subscription, x);
	                                    try {
	                                        handler.call(_cometd, x, subscription, subscription.listener, message);
	                                    } catch (xx) {
	                                        _cometd._info('Exception during execution of listener exception handler', subscription, xx);
	                                    }
	                                } else {
	                                    _cometd._info('Exception during execution of listener', subscription, message, x);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        function _notifyListeners(channel, message) {
	            // Notify direct listeners
	            _notify(channel, message);

	            // Notify the globbing listeners
	            var channelParts = channel.split('/');
	            var last = channelParts.length - 1;
	            for (var i = last; i > 0; --i) {
	                var channelPart = channelParts.slice(0, i).join('/') + '/*';
	                // We don't want to notify /foo/* if the channel is /foo/bar/baz,
	                // so we stop at the first non recursive globbing
	                if (i === last) {
	                    _notify(channelPart, message);
	                }
	                // Add the recursive globber and notify
	                channelPart += '*';
	                _notify(channelPart, message);
	            }
	        }

	        function _cancelDelayedSend() {
	            if (_scheduledSend !== null) {
	                Utils.clearTimeout(_scheduledSend);
	            }
	            _scheduledSend = null;
	        }

	        function _delayedSend(operation, delay) {
	            _cancelDelayedSend();
	            var time = _advice.interval + delay;
	            _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
	            _scheduledSend = Utils.setTimeout(_cometd, operation, time);
	        }

	        // Needed to break cyclic dependencies between function definitions
	        var _handleMessages;
	        var _handleFailure;

	        /**
	         * Delivers the messages to the CometD server
	         * @param sync whether the send is synchronous
	         * @param messages the array of messages to send
	         * @param metaConnect true if this send is on /meta/connect
	         * @param extraPath an extra path to append to the Bayeux server URL
	         */
	        function _send(sync, messages, metaConnect, extraPath) {
	            // We must be sure that the messages have a clientId.
	            // This is not guaranteed since the handshake may take time to return
	            // (and hence the clientId is not known yet) and the application
	            // may create other messages.
	            for (var i = 0; i < messages.length; ++i) {
	                var message = messages[i];
	                var messageId = message.id;

	                if (_clientId) {
	                    message.clientId = _clientId;
	                }

	                message = _applyOutgoingExtensions(message);
	                if (message !== undefined && message !== null) {
	                    // Extensions may have modified the message id, but we need to own it.
	                    message.id = messageId;
	                    messages[i] = message;
	                } else {
	                    delete _callbacks[messageId];
	                    messages.splice(i--, 1);
	                }
	            }

	            if (messages.length === 0) {
	                return;
	            }

	            var url = _cometd.getURL();
	            if (_config.appendMessageTypeToURL) {
	                // If url does not end with '/', then append it
	                if (!url.match(/\/$/)) {
	                    url = url + '/';
	                }
	                if (extraPath) {
	                    url = url + extraPath;
	                }
	            }

	            var envelope = {
	                url: url,
	                sync: sync,
	                messages: messages,
	                onSuccess: function(rcvdMessages) {
	                    try {
	                        _handleMessages.call(_cometd, rcvdMessages);
	                    } catch (x) {
	                        _cometd._info('Exception during handling of messages', x);
	                    }
	                },
	                onFailure: function(conduit, messages, failure) {
	                    try {
	                        var transport = _cometd.getTransport();
	                        failure.connectionType = transport ? transport.getType() : "unknown";
	                        _handleFailure.call(_cometd, conduit, messages, failure);
	                    } catch (x) {
	                        _cometd._info('Exception during handling of failure', x);
	                    }
	                }
	            };
	            _cometd._debug('Send', envelope);
	            _transport.send(envelope, metaConnect);
	        }

	        function _queueSend(message) {
	            if (_batch > 0 || _internalBatch === true) {
	                _messageQueue.push(message);
	            } else {
	                _send(false, [message], false);
	            }
	        }

	        /**
	         * Sends a complete bayeux message.
	         * This method is exposed as a public so that extensions may use it
	         * to send bayeux message directly, for example in case of re-sending
	         * messages that have already been sent but that for some reason must
	         * be resent.
	         */
	        this.send = _queueSend;

	        function _resetBackoff() {
	            _backoff = 0;
	        }

	        function _increaseBackoff() {
	            if (_backoff < _config.maxBackoff) {
	                _backoff += _config.backoffIncrement;
	            }
	            return _backoff;
	        }

	        /**
	         * Starts a the batch of messages to be sent in a single request.
	         * @see #_endBatch(sendMessages)
	         */
	        function _startBatch() {
	            ++_batch;
	            _cometd._debug('Starting batch, depth', _batch);
	        }

	        function _flushBatch() {
	            var messages = _messageQueue;
	            _messageQueue = [];
	            if (messages.length > 0) {
	                _send(false, messages, false);
	            }
	        }

	        /**
	         * Ends the batch of messages to be sent in a single request,
	         * optionally sending messages present in the message queue depending
	         * on the given argument.
	         * @see #_startBatch()
	         */
	        function _endBatch() {
	            --_batch;
	            _cometd._debug('Ending batch, depth', _batch);
	            if (_batch < 0) {
	                throw 'Calls to startBatch() and endBatch() are not paired';
	            }

	            if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
	                _flushBatch();
	            }
	        }

	        /**
	         * Sends the connect message
	         */
	        function _connect() {
	            if (!_isDisconnected()) {
	                var bayeuxMessage = {
	                    id: _nextMessageId(),
	                    channel: '/meta/connect',
	                    connectionType: _transport.getType()
	                };

	                // In case of reload or temporary loss of connection
	                // we want the next successful connect to return immediately
	                // instead of being held by the server, so that connect listeners
	                // can be notified that the connection has been re-established
	                if (!_connected) {
	                    bayeuxMessage.advice = { timeout: 0 };
	                }

	                _setStatus('connecting');
	                _cometd._debug('Connect sent', bayeuxMessage);
	                _send(false, [bayeuxMessage], true, 'connect');
	                _setStatus('connected');
	            }
	        }

	        function _delayedConnect(delay) {
	            _setStatus('connecting');
	            _delayedSend(function() {
	                _connect();
	            }, delay);
	        }

	        function _updateAdvice(newAdvice) {
	            if (newAdvice) {
	                _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
	                _cometd._debug('New advice', _advice);
	            }
	        }

	        function _disconnect(abort) {
	            _cancelDelayedSend();
	            if (abort && _transport) {
	                _transport.abort();
	            }
	            _clientId = null;
	            _setStatus('disconnected');
	            _batch = 0;
	            _resetBackoff();
	            _transport = null;
	            _reestablish = false;
	            _connected = false;

	            // Fail any existing queued message
	            if (_messageQueue.length > 0) {
	                var messages = _messageQueue;
	                _messageQueue = [];
	                _handleFailure.call(_cometd, undefined, messages, {
	                    reason: 'Disconnected'
	                });
	            }
	        }

	        function _notifyTransportException(oldTransport, newTransport, failure) {
	            var handler = _cometd.onTransportException;
	            if (_isFunction(handler)) {
	                _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);
	                try {
	                    handler.call(_cometd, failure, oldTransport, newTransport);
	                } catch (x) {
	                    _cometd._info('Exception during execution of transport exception handler', x);
	                }
	            }
	        }

	        /**
	         * Sends the initial handshake message
	         */
	        function _handshake(handshakeProps, handshakeCallback) {
	            if (_isFunction(handshakeProps)) {
	                handshakeCallback = handshakeProps;
	                handshakeProps = undefined;
	            }

	            _clientId = null;

	            _clearSubscriptions();

	            // Reset the transports if we're not retrying the handshake
	            if (_isDisconnected()) {
	                _transports.reset(true);
	            }

	            // Reset the advice.
	            _updateAdvice({});

	            _batch = 0;

	            // Mark the start of an internal batch.
	            // This is needed because handshake and connect are async.
	            // It may happen that the application calls init() then subscribe()
	            // and the subscribe message is sent before the connect message, if
	            // the subscribe message is not held until the connect message is sent.
	            // So here we start a batch to hold temporarily any message until
	            // the connection is fully established.
	            _internalBatch = true;

	            // Save the properties provided by the user, so that
	            // we can reuse them during automatic re-handshake
	            _handshakeProps = handshakeProps;
	            _handshakeCallback = handshakeCallback;

	            var version = '1.0';

	            // Figure out the transports to send to the server
	            var url = _cometd.getURL();
	            var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);

	            var bayeuxMessage = {
	                id: _nextMessageId(),
	                version: version,
	                minimumVersion: version,
	                channel: '/meta/handshake',
	                supportedConnectionTypes: transportTypes,
	                advice: {
	                    timeout: _advice.timeout,
	                    interval: _advice.interval
	                }
	            };
	            // Do not allow the user to override important fields.
	            var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);

	            // Save the callback.
	            _cometd._putCallback(message.id, handshakeCallback);

	            // Pick up the first available transport as initial transport
	            // since we don't know if the server supports it
	            if (!_transport) {
	                _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
	                if (!_transport) {
	                    var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
	                    _cometd._warn(failure);
	                    throw failure;
	                }
	            }

	            _cometd._debug('Initial transport is', _transport.getType());

	            // We started a batch to hold the application messages,
	            // so here we must bypass it and send immediately.
	            _setStatus('handshaking');
	            _cometd._debug('Handshake sent', message);
	            _send(false, [message], false, 'handshake');
	        }

	        function _delayedHandshake(delay) {
	            _setStatus('handshaking');

	            // We will call _handshake() which will reset _clientId, but we want to avoid
	            // that between the end of this method and the call to _handshake() someone may
	            // call publish() (or other methods that call _queueSend()).
	            _internalBatch = true;

	            _delayedSend(function() {
	                _handshake(_handshakeProps, _handshakeCallback);
	            }, delay);
	        }

	        function _notifyCallback(callback, message) {
	            try {
	                callback.call(_cometd, message);
	            } catch (x) {
	                var handler = _cometd.onCallbackException;
	                if (_isFunction(handler)) {
	                    _cometd._debug('Invoking callback exception handler', x);
	                    try {
	                        handler.call(_cometd, x, message);
	                    } catch (xx) {
	                        _cometd._info('Exception during execution of callback exception handler', xx);
	                    }
	                } else {
	                    _cometd._info('Exception during execution of message callback', x);
	                }
	            }
	        }

	        this._getCallback = function(messageId) {
	            return _callbacks[messageId];
	        };

	        this._putCallback = function(messageId, callback) {
	            var result = this._getCallback(messageId);
	            if (_isFunction(callback)) {
	                _callbacks[messageId] = callback;
	            }
	            return result;
	        };

	        function _handleCallback(message) {
	            var callback = _cometd._getCallback([message.id]);
	            if (_isFunction(callback)) {
	                delete _callbacks[message.id];
	                _notifyCallback(callback, message);
	            }
	        }

	        function _handleRemoteCall(message) {
	            var context = _remoteCalls[message.id];
	            delete _remoteCalls[message.id];
	            if (context) {
	                _cometd._debug('Handling remote call response for', message, 'with context', context);

	                // Clear the timeout, if present.
	                var timeout = context.timeout;
	                if (timeout) {
	                    Utils.clearTimeout(timeout);
	                }

	                var callback = context.callback;
	                if (_isFunction(callback)) {
	                    _notifyCallback(callback, message);
	                    return true;
	                }
	            }
	            return false;
	        }

	        this.onTransportFailure = function(message, failureInfo, failureHandler) {
	            this._debug('Transport failure', failureInfo, 'for', message);

	            var transports = this.getTransportRegistry();
	            var url = this.getURL();
	            var crossDomain = this._isCrossDomain(_splitURL(url)[2]);
	            var version = '1.0';
	            var transportTypes = transports.findTransportTypes(version, crossDomain, url);

	            if (failureInfo.action === 'none') {
	                if (message.channel === '/meta/handshake') {
	                    if (!failureInfo.transport) {
	                        var failure = 'Could not negotiate transport, client=[' + transportTypes + '], server=[' + message.supportedConnectionTypes + ']';
	                        this._warn(failure);
	                        _notifyTransportException(_transport.getType(), null, {
	                            reason: failure,
	                            connectionType: _transport.getType(),
	                            transport: _transport
	                        });
	                    }
	                }
	            } else {
	                failureInfo.delay = this.getBackoffPeriod();
	                // Different logic depending on whether we are handshaking or connecting.
	                if (message.channel === '/meta/handshake') {
	                    if (!failureInfo.transport) {
	                        // The transport is invalid, try to negotiate again.
	                        var newTransport = transports.negotiateTransport(transportTypes, version, crossDomain, url);
	                        if (!newTransport) {
	                            this._warn('Could not negotiate transport, client=[' + transportTypes + ']');
	                            _notifyTransportException(_transport.getType(), null, message.failure);
	                            failureInfo.action = 'none';
	                        } else {
	                            this._debug('Transport', _transport.getType(), '->', newTransport.getType());
	                            _notifyTransportException(_transport.getType(), newTransport.getType(), message.failure);
	                            failureInfo.action = 'handshake';
	                            failureInfo.transport = newTransport;
	                        }
	                    }

	                    if (failureInfo.action !== 'none') {
	                        this.increaseBackoffPeriod();
	                    }
	                } else {
	                    var now = new Date().getTime();

	                    if (_unconnectTime === 0) {
	                        _unconnectTime = now;
	                    }

	                    if (failureInfo.action === 'retry') {
	                        failureInfo.delay = this.increaseBackoffPeriod();
	                        // Check whether we may switch to handshaking.
	                        var maxInterval = _advice.maxInterval;
	                        if (maxInterval > 0) {
	                            var expiration = _advice.timeout + _advice.interval + maxInterval;
	                            var unconnected = now - _unconnectTime;
	                            if (unconnected + _backoff > expiration) {
	                                failureInfo.action = 'handshake';
	                            }
	                        }
	                    }

	                    if (failureInfo.action === 'handshake') {
	                        failureInfo.delay = 0;
	                        transports.reset(false);
	                        this.resetBackoffPeriod();
	                    }
	                }
	            }

	            failureHandler.call(_cometd, failureInfo);
	        };

	        function _handleTransportFailure(failureInfo) {
	            _cometd._debug('Transport failure handling', failureInfo);

	            if (failureInfo.transport) {
	                _transport = failureInfo.transport;
	            }

	            if (failureInfo.url) {
	                _transport.setURL(failureInfo.url);
	            }

	            var action = failureInfo.action;
	            var delay = failureInfo.delay || 0;
	            switch (action) {
	                case 'handshake':
	                    _delayedHandshake(delay);
	                    break;
	                case 'retry':
	                    _delayedConnect(delay);
	                    break;
	                case 'none':
	                    _disconnect(true);
	                    break;
	                default:
	                    throw 'Unknown action ' + action;
	            }
	        }

	        function _failHandshake(message, failureInfo) {
	            _handleCallback(message);
	            _notifyListeners('/meta/handshake', message);
	            _notifyListeners('/meta/unsuccessful', message);

	            // The listeners may have disconnected.
	            if (_isDisconnected()) {
	                failureInfo.action = 'none';
	            }

	            _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);
	        }

	        function _handshakeResponse(message) {
	            var url = _cometd.getURL();
	            if (message.successful) {
	                var crossDomain = _cometd._isCrossDomain(_splitURL(url)[2]);
	                var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, crossDomain, url);
	                if (newTransport === null) {
	                    message.successful = false;
	                    _failHandshake(message, {
	                        cause: 'negotiation',
	                        action: 'none',
	                        transport: null
	                    });
	                    return;
	                } else if (_transport !== newTransport) {
	                    _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
	                    _transport = newTransport;
	                }

	                _clientId = message.clientId;

	                // End the internal batch and allow held messages from the application
	                // to go to the server (see _handshake() where we start the internal batch).
	                _internalBatch = false;
	                _flushBatch();

	                // Here the new transport is in place, as well as the clientId, so
	                // the listeners can perform a publish() if they want.
	                // Notify the listeners before the connect below.
	                message.reestablish = _reestablish;
	                _reestablish = true;

	                _handleCallback(message);
	                _notifyListeners('/meta/handshake', message);

	                _handshakeMessages = message['x-messages'] || 0;

	                var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';
	                switch (action) {
	                    case 'retry':
	                        _resetBackoff();
	                        if (_handshakeMessages === 0) {
	                            _delayedConnect(0);
	                        } else {
	                            _cometd._debug('Processing', _handshakeMessages, 'handshake-delivered messages');
	                        }
	                        break;
	                    case 'none':
	                        _disconnect(true);
	                        break;
	                    default:
	                        throw 'Unrecognized advice action ' + action;
	                }
	            } else {
	                _failHandshake(message, {
	                    cause: 'unsuccessful',
	                    action: _advice.reconnect || 'handshake',
	                    transport: _transport
	                });
	            }
	        }

	        function _handshakeFailure(message) {
	            _failHandshake(message, {
	                cause: 'failure',
	                action: 'handshake',
	                transport: null
	            });
	        }

	        function _failConnect(message, failureInfo) {
	            // Notify the listeners after the status change but before the next action.
	            _notifyListeners('/meta/connect', message);
	            _notifyListeners('/meta/unsuccessful', message);

	            // The listeners may have disconnected.
	            if (_isDisconnected()) {
	                failureInfo.action = 'none';
	            }

	            _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);
	        }

	        function _connectResponse(message) {
	            _connected = message.successful;

	            if (_connected) {
	                _notifyListeners('/meta/connect', message);

	                // Normally, the advice will say "reconnect: 'retry', interval: 0"
	                // and the server will hold the request, so when a response returns
	                // we immediately call the server again (long polling).
	                // Listeners can call disconnect(), so check the state after they run.
	                var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';
	                switch (action) {
	                    case 'retry':
	                        _resetBackoff();
	                        _delayedConnect(_backoff);
	                        break;
	                    case 'none':
	                        _disconnect(false);
	                        break;
	                    default:
	                        throw 'Unrecognized advice action ' + action;
	                }
	            } else {
	                _failConnect(message, {
	                    cause: 'unsuccessful',
	                    action: _advice.reconnect || 'retry',
	                    transport: _transport
	                });
	            }
	        }

	        function _connectFailure(message) {
	            _connected = false;

	            _failConnect(message, {
	                cause: 'failure',
	                action: 'retry',
	                transport: null
	            });
	        }

	        function _failDisconnect(message) {
	            _disconnect(true);
	            _handleCallback(message);
	            _notifyListeners('/meta/disconnect', message);
	            _notifyListeners('/meta/unsuccessful', message);
	        }

	        function _disconnectResponse(message) {
	            if (message.successful) {
	                // Wait for the /meta/connect to arrive.
	                _disconnect(false);
	                _handleCallback(message);
	                _notifyListeners('/meta/disconnect', message);
	            } else {
	                _failDisconnect(message);
	            }
	        }

	        function _disconnectFailure(message) {
	            _failDisconnect(message);
	        }

	        function _failSubscribe(message) {
	            var subscriptions = _listeners[message.subscription];
	            if (subscriptions) {
	                for (var id in subscriptions) {
	                    if (subscriptions.hasOwnProperty(id)) {
	                        var subscription = subscriptions[id];
	                        if (subscription && !subscription.listener) {
	                            delete subscriptions[id];
	                            _cometd._debug('Removed failed subscription', subscription);
	                        }
	                    }
	                }
	            }
	            _handleCallback(message);
	            _notifyListeners('/meta/subscribe', message);
	            _notifyListeners('/meta/unsuccessful', message);
	        }

	        function _subscribeResponse(message) {
	            if (message.successful) {
	                _handleCallback(message);
	                _notifyListeners('/meta/subscribe', message);
	            } else {
	                _failSubscribe(message);
	            }
	        }

	        function _subscribeFailure(message) {
	            _failSubscribe(message);
	        }

	        function _failUnsubscribe(message) {
	            _handleCallback(message);
	            _notifyListeners('/meta/unsubscribe', message);
	            _notifyListeners('/meta/unsuccessful', message);
	        }

	        function _unsubscribeResponse(message) {
	            if (message.successful) {
	                _handleCallback(message);
	                _notifyListeners('/meta/unsubscribe', message);
	            } else {
	                _failUnsubscribe(message);
	            }
	        }

	        function _unsubscribeFailure(message) {
	            _failUnsubscribe(message);
	        }

	        function _failMessage(message) {
	            if (!_handleRemoteCall(message)) {
	                _handleCallback(message);
	                _notifyListeners('/meta/publish', message);
	                _notifyListeners('/meta/unsuccessful', message);
	            }
	        }

	        function _messageResponse(message) {
	            if (message.data !== undefined) {
	                if (!_handleRemoteCall(message)) {
	                    _notifyListeners(message.channel, message);
	                    if (_handshakeMessages > 0) {
	                        --_handshakeMessages;
	                        if (_handshakeMessages === 0) {
	                            _cometd._debug('Processed last handshake-delivered message');
	                            _delayedConnect(0);
	                        }
	                    }
	                }
	            } else {
	                if (message.successful === undefined) {
	                    _cometd._warn('Unknown Bayeux Message', message);
	                } else {
	                    if (message.successful) {
	                        _handleCallback(message);
	                        _notifyListeners('/meta/publish', message);
	                    } else {
	                        _failMessage(message);
	                    }
	                }
	            }
	        }

	        function _messageFailure(failure) {
	            _failMessage(failure);
	        }

	        function _receive(message) {
	            _unconnectTime = 0;

	            message = _applyIncomingExtensions(message);
	            if (message === undefined || message === null) {
	                return;
	            }

	            _updateAdvice(message.advice);

	            var channel = message.channel;
	            switch (channel) {
	                case '/meta/handshake':
	                    _handshakeResponse(message);
	                    break;
	                case '/meta/connect':
	                    _connectResponse(message);
	                    break;
	                case '/meta/disconnect':
	                    _disconnectResponse(message);
	                    break;
	                case '/meta/subscribe':
	                    _subscribeResponse(message);
	                    break;
	                case '/meta/unsubscribe':
	                    _unsubscribeResponse(message);
	                    break;
	                default:
	                    _messageResponse(message);
	                    break;
	            }
	        }

	        /**
	         * Receives a message.
	         * This method is exposed as a public so that extensions may inject
	         * messages simulating that they had been received.
	         */
	        this.receive = _receive;

	        _handleMessages = function(rcvdMessages) {
	            _cometd._debug('Received', rcvdMessages);

	            for (var i = 0; i < rcvdMessages.length; ++i) {
	                var message = rcvdMessages[i];
	                _receive(message);
	            }
	        };

	        _handleFailure = function(conduit, messages, failure) {
	            _cometd._debug('handleFailure', conduit, messages, failure);

	            failure.transport = conduit;
	            for (var i = 0; i < messages.length; ++i) {
	                var message = messages[i];
	                var failureMessage = {
	                    id: message.id,
	                    successful: false,
	                    channel: message.channel,
	                    failure: failure
	                };
	                failure.message = message;
	                switch (message.channel) {
	                    case '/meta/handshake':
	                        _handshakeFailure(failureMessage);
	                        break;
	                    case '/meta/connect':
	                        _connectFailure(failureMessage);
	                        break;
	                    case '/meta/disconnect':
	                        _disconnectFailure(failureMessage);
	                        break;
	                    case '/meta/subscribe':
	                        failureMessage.subscription = message.subscription;
	                        _subscribeFailure(failureMessage);
	                        break;
	                    case '/meta/unsubscribe':
	                        failureMessage.subscription = message.subscription;
	                        _unsubscribeFailure(failureMessage);
	                        break;
	                    default:
	                        _messageFailure(failureMessage);
	                        break;
	                }
	            }
	        };

	        function _hasSubscriptions(channel) {
	            var subscriptions = _listeners[channel];
	            if (subscriptions) {
	                for (var id in subscriptions) {
	                    if (subscriptions.hasOwnProperty(id)) {
	                        if (subscriptions[id]) {
	                            return true;
	                        }
	                    }
	                }
	            }
	            return false;
	        }

	        function _resolveScopedCallback(scope, callback) {
	            var delegate = {
	                scope: scope,
	                method: callback
	            };
	            if (_isFunction(scope)) {
	                delegate.scope = undefined;
	                delegate.method = scope;
	            } else {
	                if (_isString(callback)) {
	                    if (!scope) {
	                        throw 'Invalid scope ' + scope;
	                    }
	                    delegate.method = scope[callback];
	                    if (!_isFunction(delegate.method)) {
	                        throw 'Invalid callback ' + callback + ' for scope ' + scope;
	                    }
	                } else if (!_isFunction(callback)) {
	                    throw 'Invalid callback ' + callback;
	                }
	            }
	            return delegate;
	        }

	        function _addListener(channel, scope, callback, isListener) {
	            // The data structure is a map<channel, subscription[]>, where each subscription
	            // holds the callback to be called and its scope.

	            var delegate = _resolveScopedCallback(scope, callback);
	            _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);

	            var id = ++_listenerId;
	            var subscription = {
	                id: id,
	                channel: channel,
	                scope: delegate.scope,
	                callback: delegate.method,
	                listener: isListener
	            };

	            var subscriptions = _listeners[channel];
	            if (!subscriptions) {
	                subscriptions = {};
	                _listeners[channel] = subscriptions;
	            }

	            subscriptions[id] = subscription;

	            _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);

	            return subscription;
	        }

	        //
	        // PUBLIC API
	        //

	        /**
	         * Registers the given transport under the given transport type.
	         * The optional index parameter specifies the "priority" at which the
	         * transport is registered (where 0 is the max priority).
	         * If a transport with the same type is already registered, this function
	         * does nothing and returns false.
	         * @param type the transport type
	         * @param transport the transport object
	         * @param index the index at which this transport is to be registered
	         * @return true if the transport has been registered, false otherwise
	         * @see #unregisterTransport(type)
	         */
	        this.registerTransport = function(type, transport, index) {
	            var result = _transports.add(type, transport, index);
	            if (result) {
	                this._debug('Registered transport', type);

	                if (_isFunction(transport.registered)) {
	                    transport.registered(type, this);
	                }
	            }
	            return result;
	        };

	        /**
	         * Unregisters the transport with the given transport type.
	         * @param type the transport type to unregister
	         * @return the transport that has been unregistered,
	         * or null if no transport was previously registered under the given transport type
	         */
	        this.unregisterTransport = function(type) {
	            var transport = _transports.remove(type);
	            if (transport !== null) {
	                this._debug('Unregistered transport', type);

	                if (_isFunction(transport.unregistered)) {
	                    transport.unregistered();
	                }
	            }
	            return transport;
	        };

	        this.unregisterTransports = function() {
	            _transports.clear();
	        };

	        /**
	         * @return an array of all registered transport types
	         */
	        this.getTransportTypes = function() {
	            return _transports.getTransportTypes();
	        };

	        this.findTransport = function(name) {
	            return _transports.find(name);
	        };

	        /**
	         * @returns the TransportRegistry object
	         */
	        this.getTransportRegistry = function() {
	            return _transports;
	        };

	        /**
	         * Configures the initial Bayeux communication with the Bayeux server.
	         * Configuration is passed via an object that must contain a mandatory field <code>url</code>
	         * of type string containing the URL of the Bayeux server.
	         * @param configuration the configuration object
	         */
	        this.configure = function(configuration) {
	            _configure.call(this, configuration);
	        };

	        /**
	         * Configures and establishes the Bayeux communication with the Bayeux server
	         * via a handshake and a subsequent connect.
	         * @param configuration the configuration object
	         * @param handshakeProps an object to be merged with the handshake message
	         * @see #configure(configuration)
	         * @see #handshake(handshakeProps)
	         */
	        this.init = function(configuration, handshakeProps) {
	            this.configure(configuration);
	            this.handshake(handshakeProps);
	        };

	        /**
	         * Establishes the Bayeux communication with the Bayeux server
	         * via a handshake and a subsequent connect.
	         * @param handshakeProps an object to be merged with the handshake message
	         * @param handshakeCallback a function to be invoked when the handshake is acknowledged
	         */
	        this.handshake = function(handshakeProps, handshakeCallback) {
	            if (_status !== 'disconnected') {
	                throw 'Illegal state: handshaken';
	            }
	            _handshake(handshakeProps, handshakeCallback);
	        };

	        /**
	         * Disconnects from the Bayeux server.
	         * It is possible to suggest to attempt a synchronous disconnect, but this feature
	         * may only be available in certain transports (for example, long-polling may support
	         * it, callback-polling certainly does not).
	         * @param sync whether attempt to perform a synchronous disconnect
	         * @param disconnectProps an object to be merged with the disconnect message
	         * @param disconnectCallback a function to be invoked when the disconnect is acknowledged
	         */
	        this.disconnect = function(sync, disconnectProps, disconnectCallback) {
	            if (_isDisconnected()) {
	                return;
	            }

	            if (typeof sync !== 'boolean') {
	                disconnectCallback = disconnectProps;
	                disconnectProps = sync;
	                sync = false;
	            }
	            if (_isFunction(disconnectProps)) {
	                disconnectCallback = disconnectProps;
	                disconnectProps = undefined;
	            }

	            var bayeuxMessage = {
	                id: _nextMessageId(),
	                channel: '/meta/disconnect'
	            };
	            // Do not allow the user to override important fields.
	            var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);

	            // Save the callback.
	            _cometd._putCallback(message.id, disconnectCallback);

	            _setStatus('disconnecting');
	            _send(sync === true, [message], false, 'disconnect');
	        };

	        /**
	         * Marks the start of a batch of application messages to be sent to the server
	         * in a single request, obtaining a single response containing (possibly) many
	         * application reply messages.
	         * Messages are held in a queue and not sent until {@link #endBatch()} is called.
	         * If startBatch() is called multiple times, then an equal number of endBatch()
	         * calls must be made to close and send the batch of messages.
	         * @see #endBatch()
	         */
	        this.startBatch = function() {
	            _startBatch();
	        };

	        /**
	         * Marks the end of a batch of application messages to be sent to the server
	         * in a single request.
	         * @see #startBatch()
	         */
	        this.endBatch = function() {
	            _endBatch();
	        };

	        /**
	         * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}
	         * and {@link #endBatch()} calls.
	         * @param scope the scope of the callback, may be omitted
	         * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls
	         */
	        this.batch = function(scope, callback) {
	            var delegate = _resolveScopedCallback(scope, callback);
	            this.startBatch();
	            try {
	                delegate.method.call(delegate.scope);
	                this.endBatch();
	            } catch (x) {
	                this._info('Exception during execution of batch', x);
	                this.endBatch();
	                throw x;
	            }
	        };

	        /**
	         * Adds a listener for bayeux messages, performing the given callback in the given scope
	         * when a message for the given channel arrives.
	         * @param channel the channel the listener is interested to
	         * @param scope the scope of the callback, may be omitted
	         * @param callback the callback to call when a message is sent to the channel
	         * @returns the subscription handle to be passed to {@link #removeListener(object)}
	         * @see #removeListener(subscription)
	         */
	        this.addListener = function(channel, scope, callback) {
	            if (arguments.length < 2) {
	                throw 'Illegal arguments number: required 2, got ' + arguments.length;
	            }
	            if (!_isString(channel)) {
	                throw 'Illegal argument type: channel must be a string';
	            }

	            return _addListener(channel, scope, callback, true);
	        };

	        /**
	         * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.
	         * @param subscription the subscription to unsubscribe.
	         * @see #addListener(channel, scope, callback)
	         */
	        this.removeListener = function(subscription) {
	            // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id
	            if (!subscription || !subscription.channel || !("id" in subscription)) {
	                throw 'Invalid argument: expected subscription, not ' + subscription;
	            }

	            _removeListener(subscription);
	        };

	        /**
	         * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or
	         * {@link #subscribe(channel, scope, callback)}.
	         */
	        this.clearListeners = function() {
	            _listeners = {};
	        };

	        /**
	         * Subscribes to the given channel, performing the given callback in the given scope
	         * when a message for the channel arrives.
	         * @param channel the channel to subscribe to
	         * @param scope the scope of the callback, may be omitted
	         * @param callback the callback to call when a message is sent to the channel
	         * @param subscribeProps an object to be merged with the subscribe message
	         * @param subscribeCallback a function to be invoked when the subscription is acknowledged
	         * @return the subscription handle to be passed to {@link #unsubscribe(object)}
	         */
	        this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
	            if (arguments.length < 2) {
	                throw 'Illegal arguments number: required 2, got ' + arguments.length;
	            }
	            if (!_isString(channel)) {
	                throw 'Illegal argument type: channel must be a string';
	            }
	            if (_isDisconnected()) {
	                throw 'Illegal state: disconnected';
	            }

	            // Normalize arguments
	            if (_isFunction(scope)) {
	                subscribeCallback = subscribeProps;
	                subscribeProps = callback;
	                callback = scope;
	                scope = undefined;
	            }
	            if (_isFunction(subscribeProps)) {
	                subscribeCallback = subscribeProps;
	                subscribeProps = undefined;
	            }

	            // Only send the message to the server if this client has not yet subscribed to the channel
	            var send = !_hasSubscriptions(channel);

	            var subscription = _addListener(channel, scope, callback, false);

	            if (send) {
	                // Send the subscription message after the subscription registration to avoid
	                // races where the server would send a message to the subscribers, but here
	                // on the client the subscription has not been added yet to the data structures
	                var bayeuxMessage = {
	                    id: _nextMessageId(),
	                    channel: '/meta/subscribe',
	                    subscription: channel
	                };
	                // Do not allow the user to override important fields.
	                var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);

	                // Save the callback.
	                _cometd._putCallback(message.id, subscribeCallback);

	                _queueSend(message);
	            }

	            return subscription;
	        };

	        /**
	         * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.
	         * @param subscription the subscription to unsubscribe.
	         * @param unsubscribeProps an object to be merged with the unsubscribe message
	         * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged
	         */
	        this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
	            if (arguments.length < 1) {
	                throw 'Illegal arguments number: required 1, got ' + arguments.length;
	            }
	            if (_isDisconnected()) {
	                throw 'Illegal state: disconnected';
	            }

	            if (_isFunction(unsubscribeProps)) {
	                unsubscribeCallback = unsubscribeProps;
	                unsubscribeProps = undefined;
	            }

	            // Remove the local listener before sending the message
	            // This ensures that if the server fails, this client does not get notifications
	            this.removeListener(subscription);

	            var channel = subscription.channel;
	            // Only send the message to the server if this client unsubscribes the last subscription
	            if (!_hasSubscriptions(channel)) {
	                var bayeuxMessage = {
	                    id: _nextMessageId(),
	                    channel: '/meta/unsubscribe',
	                    subscription: channel
	                };
	                // Do not allow the user to override important fields.
	                var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);

	                // Save the callback.
	                _cometd._putCallback(message.id, unsubscribeCallback);

	                _queueSend(message);
	            }
	        };

	        this.resubscribe = function(subscription, subscribeProps) {
	            _removeSubscription(subscription);
	            if (subscription) {
	                return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
	            }
	            return undefined;
	        };

	        /**
	         * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},
	         * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.
	         */
	        this.clearSubscriptions = function() {
	            _clearSubscriptions();
	        };

	        /**
	         * Publishes a message on the given channel, containing the given content.
	         * @param channel the channel to publish the message to
	         * @param content the content of the message
	         * @param publishProps an object to be merged with the publish message
	         * @param publishCallback a function to be invoked when the publish is acknowledged by the server
	         */
	        this.publish = function(channel, content, publishProps, publishCallback) {
	            if (arguments.length < 1) {
	                throw 'Illegal arguments number: required 1, got ' + arguments.length;
	            }
	            if (!_isString(channel)) {
	                throw 'Illegal argument type: channel must be a string';
	            }
	            if (/^\/meta\//.test(channel)) {
	                throw 'Illegal argument: cannot publish to meta channels';
	            }
	            if (_isDisconnected()) {
	                throw 'Illegal state: disconnected';
	            }

	            if (_isFunction(content)) {
	                publishCallback = content;
	                content = {};
	                publishProps = undefined;
	            } else if (_isFunction(publishProps)) {
	                publishCallback = publishProps;
	                publishProps = undefined;
	            }

	            var bayeuxMessage = {
	                id: _nextMessageId(),
	                channel: channel,
	                data: content
	            };
	            // Do not allow the user to override important fields.
	            var message = this._mixin(false, {}, publishProps, bayeuxMessage);

	            // Save the callback.
	            _cometd._putCallback(message.id, publishCallback);

	            _queueSend(message);
	        };

	        /**
	         * Publishes a message with binary data on the given channel.
	         * The binary data chunk may be an ArrayBuffer, a DataView, a TypedArray
	         * (such as Uint8Array) or a plain integer array.
	         * The meta data object may contain additional application data such as
	         * a file name, a mime type, etc.
	         * @param channel the channel to publish the message to
	         * @param data the binary data to publish
	         * @param last whether the binary data chunk is the last
	         * @param meta an object containing meta data associated to the binary chunk
	         * @param callback a function to be invoked when the publish is acknowledged by the server
	         */
	        this.publishBinary = function(channel, data, last, meta, callback) {
	            if (_isFunction(data)) {
	                callback = data;
	                data = new ArrayBuffer(0);
	                last = true;
	                meta = undefined;
	            } else if (_isFunction(last)) {
	                callback = last;
	                last = true;
	                meta = undefined;
	            } else if (_isFunction(meta)) {
	                callback = meta;
	                meta = undefined;
	            }
	            var content = {
	                meta: meta,
	                data: data,
	                last: last
	            };
	            var ext = {
	                ext: {
	                    binary: {
	                    }
	                }
	            };
	            this.publish(channel, content, ext, callback);
	        };

	        this.remoteCall = function(target, content, timeout, callProps, callback) {
	            if (arguments.length < 1) {
	                throw 'Illegal arguments number: required 1, got ' + arguments.length;
	            }
	            if (!_isString(target)) {
	                throw 'Illegal argument type: target must be a string';
	            }
	            if (_isDisconnected()) {
	                throw 'Illegal state: disconnected';
	            }

	            if (_isFunction(content)) {
	                callback = content;
	                content = {};
	                timeout = _config.maxNetworkDelay;
	                callProps = undefined;
	            } else if (_isFunction(timeout)) {
	                callback = timeout;
	                timeout = _config.maxNetworkDelay;
	                callProps = undefined;
	            } else if (_isFunction(callProps)) {
	                callback = callProps;
	                callProps = undefined;
	            }

	            if (typeof timeout !== 'number') {
	                throw 'Illegal argument type: timeout must be a number';
	            }

	            if (!target.match(/^\//)) {
	                target = '/' + target;
	            }
	            var channel = '/service' + target;

	            var bayeuxMessage = {
	                id: _nextMessageId(),
	                channel: channel,
	                data: content
	            };
	            var message = this._mixin(false, {}, callProps, bayeuxMessage);

	            var context = {
	                callback: callback
	            };
	            if (timeout > 0) {
	                context.timeout = Utils.setTimeout(_cometd, function() {
	                    _cometd._debug('Timing out remote call', message, 'after', timeout, 'ms');
	                    _failMessage({
	                        id: message.id,
	                        error: '406::timeout',
	                        successful: false,
	                        failure: {
	                            message : message,
	                            reason: 'Remote Call Timeout'
	                        }
	                    });
	                }, timeout);
	                _cometd._debug('Scheduled remote call timeout', message, 'in', timeout, 'ms');
	            }
	            _remoteCalls[message.id] = context;

	            _queueSend(message);
	        };

	        this.remoteCallBinary = function(target, data, last, meta, timeout, callback) {
	            if (_isFunction(data)) {
	                callback = data;
	                data = new ArrayBuffer(0);
	                last = true;
	                meta = undefined;
	                timeout = _config.maxNetworkDelay;
	            } else if (_isFunction(last)) {
	                callback = last;
	                last = true;
	                meta = undefined;
	                timeout = _config.maxNetworkDelay;
	            } else if (_isFunction(meta)) {
	                callback = meta;
	                meta = undefined;
	                timeout = _config.maxNetworkDelay;
	            } else if (_isFunction(timeout)) {
	                callback = timeout;
	                timeout = _config.maxNetworkDelay;
	            }

	            var content = {
	                meta: meta,
	                data: data,
	                last: last
	            };
	            var ext = {
	                ext: {
	                    binary: {
	                    }
	                }
	            };

	            this.remoteCall(target, content, timeout, ext, callback);
	        };

	        /**
	         * Returns a string representing the status of the bayeux communication with the Bayeux server.
	         */
	        this.getStatus = function() {
	            return _status;
	        };

	        /**
	         * Returns whether this instance has been disconnected.
	         */
	        this.isDisconnected = _isDisconnected;

	        /**
	         * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
	         * Default value is 1 second, which means if there is a persistent failure the retries will happen
	         * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of
	         * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).
	         * @param period the backoff period to set
	         * @see #getBackoffIncrement()
	         */
	        this.setBackoffIncrement = function(period) {
	            _config.backoffIncrement = period;
	        };

	        /**
	         * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
	         * @see #setBackoffIncrement(period)
	         */
	        this.getBackoffIncrement = function() {
	            return _config.backoffIncrement;
	        };

	        /**
	         * Returns the backoff period to wait before retrying an unsuccessful or failed message.
	         */
	        this.getBackoffPeriod = function() {
	            return _backoff;
	        };

	        /**
	         * Increases the backoff period up to the maximum value configured.
	         * @returns the backoff period after increment
	         * @see getBackoffIncrement
	         */
	        this.increaseBackoffPeriod = function() {
	            return _increaseBackoff();
	        };

	        /**
	         * Resets the backoff period to zero.
	         */
	        this.resetBackoffPeriod = function() {
	            _resetBackoff();
	        };

	        /**
	         * Sets the log level for console logging.
	         * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
	         * less verbose to more verbose.
	         * @param level the log level string
	         */
	        this.setLogLevel = function(level) {
	            _config.logLevel = level;
	        };

	        /**
	         * Registers an extension whose callbacks are called for every incoming message
	         * (that comes from the server to this client implementation) and for every
	         * outgoing message (that originates from this client implementation for the
	         * server).
	         * The format of the extension object is the following:
	         * <pre>
	         * {
	     *     incoming: function(message) { ... },
	     *     outgoing: function(message) { ... }
	     * }
	         * </pre>
	         * Both properties are optional, but if they are present they will be called
	         * respectively for each incoming message and for each outgoing message.
	         * @param name the name of the extension
	         * @param extension the extension to register
	         * @return true if the extension was registered, false otherwise
	         * @see #unregisterExtension(name)
	         */
	        this.registerExtension = function(name, extension) {
	            if (arguments.length < 2) {
	                throw 'Illegal arguments number: required 2, got ' + arguments.length;
	            }
	            if (!_isString(name)) {
	                throw 'Illegal argument type: extension name must be a string';
	            }

	            var existing = false;
	            for (var i = 0; i < _extensions.length; ++i) {
	                var existingExtension = _extensions[i];
	                if (existingExtension.name === name) {
	                    existing = true;
	                    break;
	                }
	            }
	            if (!existing) {
	                _extensions.push({
	                    name: name,
	                    extension: extension
	                });
	                this._debug('Registered extension', name);

	                // Callback for extensions
	                if (_isFunction(extension.registered)) {
	                    extension.registered(name, this);
	                }

	                return true;
	            } else {
	                this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
	                return false;
	            }
	        };

	        /**
	         * Unregister an extension previously registered with
	         * {@link #registerExtension(name, extension)}.
	         * @param name the name of the extension to unregister.
	         * @return true if the extension was unregistered, false otherwise
	         */
	        this.unregisterExtension = function(name) {
	            if (!_isString(name)) {
	                throw 'Illegal argument type: extension name must be a string';
	            }

	            var unregistered = false;
	            for (var i = 0; i < _extensions.length; ++i) {
	                var extension = _extensions[i];
	                if (extension.name === name) {
	                    _extensions.splice(i, 1);
	                    unregistered = true;
	                    this._debug('Unregistered extension', name);

	                    // Callback for extensions
	                    var ext = extension.extension;
	                    if (_isFunction(ext.unregistered)) {
	                        ext.unregistered();
	                    }

	                    break;
	                }
	            }
	            return unregistered;
	        };

	        /**
	         * Find the extension registered with the given name.
	         * @param name the name of the extension to find
	         * @return the extension found or null if no extension with the given name has been registered
	         */
	        this.getExtension = function(name) {
	            for (var i = 0; i < _extensions.length; ++i) {
	                var extension = _extensions[i];
	                if (extension.name === name) {
	                    return extension.extension;
	                }
	            }
	            return null;
	        };

	        /**
	         * Returns the name assigned to this CometD object, or the string 'default'
	         * if no name has been explicitly passed as parameter to the constructor.
	         */
	        this.getName = function() {
	            return _name;
	        };

	        /**
	         * Returns the clientId assigned by the Bayeux server during handshake.
	         */
	        this.getClientId = function() {
	            return _clientId;
	        };

	        /**
	         * Returns the URL of the Bayeux server.
	         */
	        this.getURL = function() {
	            if (_transport) {
	                var url = _transport.getURL();
	                if (url) {
	                    return url;
	                }
	                url = _config.urls[_transport.getType()];
	                if (url) {
	                    return url;
	                }
	            }
	            return _config.url;
	        };

	        this.getTransport = function() {
	            return _transport;
	        };

	        this.getConfiguration = function() {
	            return this._mixin(true, {}, _config);
	        };

	        this.getAdvice = function() {
	            return this._mixin(true, {}, _advice);
	        };

	        // Initialize transports.
	        if (window.WebSocket) {
	            this.registerTransport('websocket', new WebSocketTransport());
	        }
	        this.registerTransport('long-polling', new LongPollingTransport());
	        this.registerTransport('callback-polling', new CallbackPollingTransport());
	    };

	    var _z85EncodeTable = [
	        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
	        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
	        'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
	        'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
	        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
	        'Y', 'Z', '.', '-', ':', '+', '=', '^', '!', '/',
	        '*', '?', '&', '<', '>', '(', ')', '[', ']', '{',
	        '}', '@', '%', '$', '#'
	    ];
	    var _z85DecodeTable = [
	        0x00, 0x44, 0x00, 0x54, 0x53, 0x52, 0x48, 0x00,
	        0x4B, 0x4C, 0x46, 0x41, 0x00, 0x3F, 0x3E, 0x45,
	        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	        0x08, 0x09, 0x40, 0x00, 0x49, 0x42, 0x4A, 0x47,
	        0x51, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,
	        0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,
	        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A,
	        0x3B, 0x3C, 0x3D, 0x4D, 0x00, 0x4E, 0x43, 0x00,
	        0x00, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
	        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
	        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
	        0x21, 0x22, 0x23, 0x4F, 0x00, 0x50, 0x00, 0x00
	    ];
	    var Z85 = {
	        encode: function(bytes) {
	            var buffer = null;
	            if (bytes instanceof ArrayBuffer) {
	                buffer = bytes;
	            } else if (bytes.buffer instanceof ArrayBuffer) {
	                buffer = bytes.buffer;
	            } else if (Array.isArray(bytes)) {
	                buffer = new Uint8Array(bytes).buffer;
	            }
	            if (buffer == null) {
	                throw 'Cannot Z85 encode ' + bytes;
	            }

	            var length = buffer.byteLength;
	            var remainder = length % 4;
	            var padding = 4 - (remainder === 0 ? 4 : remainder);
	            var view = new DataView(buffer);
	            var result = '';
	            var value = 0;
	            for (var i = 0; i < length + padding; ++i) {
	                var isPadding = i >= length;
	                value = value * 256 + (isPadding ? 0 : view.getUint8(i));
	                if ((i + 1) % 4 === 0) {
	                    var divisor = 85 * 85 * 85 * 85;
	                    for (var j = 5; j > 0; --j) {
	                        if (!isPadding || j > padding) {
	                            var code = Math.floor(value / divisor) % 85;
	                            result += _z85EncodeTable[code];
	                        }
	                        divisor /= 85;
	                    }
	                    value = 0;
	                }
	            }

	            return result;
	        },
	        decode: function(string) {
	            var remainder = string.length % 5;
	            var padding = 5 - (remainder === 0 ? 5 : remainder);
	            for (var p = 0; p < padding; ++p) {
	                string += _z85EncodeTable[_z85EncodeTable.length - 1];
	            }
	            var length = string.length;

	            var buffer = new ArrayBuffer((length * 4 / 5) - padding);
	            var view = new DataView(buffer);
	            var value = 0;
	            var charIdx = 0;
	            var byteIdx = 0;
	            for (var i = 0; i < length; ++i) {
	                var code = string.charCodeAt(charIdx++) - 32;
	                value = value * 85 + _z85DecodeTable[code];
	                if (charIdx % 5 === 0) {
	                    var divisor = 256 * 256 * 256;
	                    while (divisor >= 1) {
	                        if (byteIdx < view.byteLength) {
	                            view.setUint8(byteIdx++, Math.floor(value / divisor) % 256);
	                        }
	                        divisor /= 256;
	                    }
	                    value = 0;
	                }
	            }

	            return buffer;
	        }
	    };

	    return {
	        CometD: CometD,
	        Transport: Transport,
	        RequestTransport: RequestTransport,
	        LongPollingTransport: LongPollingTransport,
	        CallbackPollingTransport: CallbackPollingTransport,
	        WebSocketTransport: WebSocketTransport,
	        Utils: Utils,
	        Z85: Z85
	    };
	}));
	});

	var browser = {
	  CometD: cometd.CometD,
	  default: cometd
	};

	var MetaChannel_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (MetaChannel) {
	    MetaChannel["HANDSHAKE"] = "/meta/handshake";
	    MetaChannel["CONNECT"] = "/meta/connect";
	    MetaChannel["SUBSCRIBE"] = "/meta/subscribe";
	    MetaChannel["UNSUBSCRIBE"] = "/meta/unsubscribe";
	})(exports.MetaChannel || (exports.MetaChannel = {}));

	});

	unwrapExports(MetaChannel_1);
	MetaChannel_1.MetaChannel;

	var Realtime_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	var Realtime = /** @class */ (function () {
	    /**
	     * Allows to set up a realtime (websocket or long-polling) connection to the platform.
	     * @param client The fetch client instance to use
	     * @param url The URL to connect to
	     * @param handshakeCallback A function which is called on succeeded or failed handshake
	     */
	    function Realtime(client, url, handshakeCallback) {
	        if (url === void 0) { url = '/cep/realtime'; }
	        this.client = client;
	        this.url = url;
	        this.cometd = new browser.CometD();
	        this.metaHandshake = function (msg) {
	            if (!msg.successful) {
	                throw new Error('Handshake failed');
	            }
	        };
	        this.cometd.websocketEnabled = true;
	        this.cometd.addListener(MetaChannel_1.MetaChannel.HANDSHAKE, handshakeCallback || this.metaHandshake);
	    }
	    /**
	     * Subscribes to a realtime channel to listen for data.
	     * @param channel The channel to connect to
	     * @param callback A function to call when data is received
	     */
	    Realtime.prototype.subscribe = function (channel, callback) {
	        this.checkConnection();
	        return this.cometd.subscribe(channel, callback);
	    };
	    /**
	     * Cancels the listening to a channel.
	     * @param subscription The subscription object returned by subscribe()
	     */
	    Realtime.prototype.unsubscribe = function (subscription) {
	        return this.cometd.unsubscribe(subscription);
	    };
	    /**
	     * Returns an observable which subscribes/unsubscribes automatically.
	     * @param channel The name of the channel you want to connect to.
	     */
	    Realtime.prototype.observable = function (channel) {
	        var _this = this;
	        return rxjs_1.Observable.create(function (observer) {
	            var subscription = _this.subscribe(channel, function (msg) {
	                var data = {
	                    channel: msg.channel,
	                    data: msg.data.data,
	                    id: msg.id,
	                    realtimeAction: msg.data.realtimeAction,
	                };
	                return observer.next(data);
	            });
	            return function () { return _this.unsubscribe(subscription); };
	        });
	    };
	    /**
	     * Disconnects the current connection.
	     */
	    Realtime.prototype.disconnect = function () {
	        this.cometd.disconnect();
	    };
	    Realtime.prototype.checkConnection = function () {
	        var _a = this, cometd = _a.cometd, client = _a.client, url = _a.url;
	        if (cometd.isDisconnected()) {
	            var headers = client.getFetchOptions().headers;
	            var config = {
	                url: client.getUrl(url),
	                requestHeaders: headers
	            };
	            cometd.configure(config);
	            this.handshake(client.getCometdHandshake());
	        }
	    };
	    Realtime.prototype.handshake = function (config) {
	        this.cometd.handshake(config);
	    };
	    return Realtime;
	}());
	exports.Realtime = Realtime;

	});

	unwrapExports(Realtime_1);
	Realtime_1.Realtime;

	var realtime = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(Realtime_1);

	});

	unwrapExports(realtime);

	var Paging_1 = createCommonjsModule(function (module, exports) {
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * Paging allows you to query the next and previous data chunks
	 * in a convenient way. You can also go to a specific page or just read
	 * page information about the current data chunk.
	 * Note that page numbers are generated by backend
	 * and may be used as offset rather than a continuous range of positive numbers
	 * (e.g. in case of users with restricted permissions).
	 */
	var Paging = /** @class */ (function () {
	    function Paging(service, statistics, filter) {
	        this.filter = filter;
	        this.service = service;
	        this.currentPage = statistics.currentPage;
	        this.nextPage = statistics.nextPage;
	        this.prevPage = statistics.prevPage;
	        this.pageSize = statistics.pageSize;
	        this.totalPages = statistics.totalPages;
	    }
	    /**
	     * Gets the next page of available data from the server.
	     * @param filter
	     */
	    Paging.prototype.next = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.service.list(this.getFilter(filter, this.nextPage))];
	            });
	        });
	    };
	    /**
	     * Gets the previous page of available data from server.
	     * @param filter
	     */
	    Paging.prototype.prev = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.service.list(this.getFilter(filter, this.prevPage))];
	            });
	        });
	    };
	    /**
	     * Goes to the page that you define as page parameter.
	     * @param page
	     * @param filter
	     */
	    Paging.prototype.goto = function (page, filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.service.list(this.getFilter(filter, page))];
	            });
	        });
	    };
	    Paging.prototype.getFilter = function (filter, page) {
	        return Object.assign(filter, this.filter, { currentPage: page });
	    };
	    return Paging;
	}());
	exports.Paging = Paging;

	});

	unwrapExports(Paging_1);
	Paging_1.Paging;

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function audit(durationSelector) {
	    return function auditOperatorFunction(source) {
	        return source.lift(new AuditOperator(durationSelector));
	    };
	}
	var AuditOperator = /*@__PURE__*/ (function () {
	    function AuditOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    AuditOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
	    };
	    return AuditOperator;
	}());
	var AuditSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(AuditSubscriber, _super);
	    function AuditSubscriber(destination, durationSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.durationSelector = durationSelector;
	        _this.hasValue = false;
	        return _this;
	    }
	    AuditSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            var duration = void 0;
	            try {
	                var durationSelector = this.durationSelector;
	                duration = durationSelector(value);
	            }
	            catch (err) {
	                return this.destination.error(err);
	            }
	            var innerSubscription = subscribeToResult(this, duration);
	            if (!innerSubscription || innerSubscription.closed) {
	                this.clearThrottle();
	            }
	            else {
	                this.add(this.throttled = innerSubscription);
	            }
	        }
	    };
	    AuditSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        this.clearThrottle();
	    };
	    AuditSubscriber.prototype.notifyComplete = function () {
	        this.clearThrottle();
	    };
	    return AuditSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */
	function auditTime(duration, scheduler) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    return audit(function () { return timer(duration, scheduler); });
	}

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function buffer(closingNotifier) {
	    return function bufferOperatorFunction(source) {
	        return source.lift(new BufferOperator(closingNotifier));
	    };
	}
	var BufferOperator = /*@__PURE__*/ (function () {
	    function BufferOperator(closingNotifier) {
	        this.closingNotifier = closingNotifier;
	    }
	    BufferOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
	    };
	    return BufferOperator;
	}());
	var BufferSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(BufferSubscriber, _super);
	    function BufferSubscriber(destination, closingNotifier) {
	        var _this = _super.call(this, destination) || this;
	        _this.buffer = [];
	        _this.add(subscribeToResult(_this, closingNotifier));
	        return _this;
	    }
	    BufferSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var buffer = this.buffer;
	        this.buffer = [];
	        this.destination.next(buffer);
	    };
	    return BufferSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function bufferCount(bufferSize, startBufferEvery) {
	    if (startBufferEvery === void 0) {
	        startBufferEvery = null;
	    }
	    return function bufferCountOperatorFunction(source) {
	        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
	    };
	}
	var BufferCountOperator = /*@__PURE__*/ (function () {
	    function BufferCountOperator(bufferSize, startBufferEvery) {
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        if (!startBufferEvery || bufferSize === startBufferEvery) {
	            this.subscriberClass = BufferCountSubscriber;
	        }
	        else {
	            this.subscriberClass = BufferSkipCountSubscriber;
	        }
	    }
	    BufferCountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
	    };
	    return BufferCountOperator;
	}());
	var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(BufferCountSubscriber, _super);
	    function BufferCountSubscriber(destination, bufferSize) {
	        var _this = _super.call(this, destination) || this;
	        _this.bufferSize = bufferSize;
	        _this.buffer = [];
	        return _this;
	    }
	    BufferCountSubscriber.prototype._next = function (value) {
	        var buffer = this.buffer;
	        buffer.push(value);
	        if (buffer.length == this.bufferSize) {
	            this.destination.next(buffer);
	            this.buffer = [];
	        }
	    };
	    BufferCountSubscriber.prototype._complete = function () {
	        var buffer = this.buffer;
	        if (buffer.length > 0) {
	            this.destination.next(buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    return BufferCountSubscriber;
	}(Subscriber));
	var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(BufferSkipCountSubscriber, _super);
	    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
	        var _this = _super.call(this, destination) || this;
	        _this.bufferSize = bufferSize;
	        _this.startBufferEvery = startBufferEvery;
	        _this.buffers = [];
	        _this.count = 0;
	        return _this;
	    }
	    BufferSkipCountSubscriber.prototype._next = function (value) {
	        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
	        this.count++;
	        if (count % startBufferEvery === 0) {
	            buffers.push([]);
	        }
	        for (var i = buffers.length; i--;) {
	            var buffer = buffers[i];
	            buffer.push(value);
	            if (buffer.length === bufferSize) {
	                buffers.splice(i, 1);
	                this.destination.next(buffer);
	            }
	        }
	    };
	    BufferSkipCountSubscriber.prototype._complete = function () {
	        var _a = this, buffers = _a.buffers, destination = _a.destination;
	        while (buffers.length > 0) {
	            var buffer = buffers.shift();
	            if (buffer.length > 0) {
	                destination.next(buffer);
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    return BufferSkipCountSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */
	function bufferTime(bufferTimeSpan) {
	    var length = arguments.length;
	    var scheduler = async;
	    if (isScheduler(arguments[arguments.length - 1])) {
	        scheduler = arguments[arguments.length - 1];
	        length--;
	    }
	    var bufferCreationInterval = null;
	    if (length >= 2) {
	        bufferCreationInterval = arguments[1];
	    }
	    var maxBufferSize = Number.POSITIVE_INFINITY;
	    if (length >= 3) {
	        maxBufferSize = arguments[2];
	    }
	    return function bufferTimeOperatorFunction(source) {
	        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
	    };
	}
	var BufferTimeOperator = /*@__PURE__*/ (function () {
	    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.maxBufferSize = maxBufferSize;
	        this.scheduler = scheduler;
	    }
	    BufferTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
	    };
	    return BufferTimeOperator;
	}());
	var Context = /*@__PURE__*/ (function () {
	    function Context() {
	        this.buffer = [];
	    }
	    return Context;
	}());
	var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(BufferTimeSubscriber, _super);
	    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	        var _this = _super.call(this, destination) || this;
	        _this.bufferTimeSpan = bufferTimeSpan;
	        _this.bufferCreationInterval = bufferCreationInterval;
	        _this.maxBufferSize = maxBufferSize;
	        _this.scheduler = scheduler;
	        _this.contexts = [];
	        var context = _this.openContext();
	        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
	        if (_this.timespanOnly) {
	            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
	            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	        else {
	            var closeState = { subscriber: _this, context: context };
	            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
	            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
	            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
	        }
	        return _this;
	    }
	    BufferTimeSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        var filledBufferContext;
	        for (var i = 0; i < len; i++) {
	            var context_1 = contexts[i];
	            var buffer = context_1.buffer;
	            buffer.push(value);
	            if (buffer.length == this.maxBufferSize) {
	                filledBufferContext = context_1;
	            }
	        }
	        if (filledBufferContext) {
	            this.onBufferFull(filledBufferContext);
	        }
	    };
	    BufferTimeSubscriber.prototype._error = function (err) {
	        this.contexts.length = 0;
	        _super.prototype._error.call(this, err);
	    };
	    BufferTimeSubscriber.prototype._complete = function () {
	        var _a = this, contexts = _a.contexts, destination = _a.destination;
	        while (contexts.length > 0) {
	            var context_2 = contexts.shift();
	            destination.next(context_2.buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferTimeSubscriber.prototype._unsubscribe = function () {
	        this.contexts = null;
	    };
	    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
	        this.closeContext(context);
	        var closeAction = context.closeAction;
	        closeAction.unsubscribe();
	        this.remove(closeAction);
	        if (!this.closed && this.timespanOnly) {
	            context = this.openContext();
	            var bufferTimeSpan = this.bufferTimeSpan;
	            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
	            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	    };
	    BufferTimeSubscriber.prototype.openContext = function () {
	        var context = new Context();
	        this.contexts.push(context);
	        return context;
	    };
	    BufferTimeSubscriber.prototype.closeContext = function (context) {
	        this.destination.next(context.buffer);
	        var contexts = this.contexts;
	        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
	        if (spliceIndex >= 0) {
	            contexts.splice(contexts.indexOf(context), 1);
	        }
	    };
	    return BufferTimeSubscriber;
	}(Subscriber));
	function dispatchBufferTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var prevContext = state.context;
	    if (prevContext) {
	        subscriber.closeContext(prevContext);
	    }
	    if (!subscriber.closed) {
	        state.context = subscriber.openContext();
	        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
	    }
	}
	function dispatchBufferCreation(state) {
	    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
	    var context = subscriber.openContext();
	    var action = this;
	    if (!subscriber.closed) {
	        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
	        action.schedule(state, bufferCreationInterval);
	    }
	}
	function dispatchBufferClose(arg) {
	    var subscriber = arg.subscriber, context = arg.context;
	    subscriber.closeContext(context);
	}

	/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
	function bufferToggle(openings, closingSelector) {
	    return function bufferToggleOperatorFunction(source) {
	        return source.lift(new BufferToggleOperator(openings, closingSelector));
	    };
	}
	var BufferToggleOperator = /*@__PURE__*/ (function () {
	    function BufferToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    BufferToggleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return BufferToggleOperator;
	}());
	var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(BufferToggleSubscriber, _super);
	    function BufferToggleSubscriber(destination, openings, closingSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.openings = openings;
	        _this.closingSelector = closingSelector;
	        _this.contexts = [];
	        _this.add(subscribeToResult(_this, openings));
	        return _this;
	    }
	    BufferToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        for (var i = 0; i < len; i++) {
	            contexts[i].buffer.push(value);
	        }
	    };
	    BufferToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context_1 = contexts.shift();
	            context_1.subscription.unsubscribe();
	            context_1.buffer = null;
	            context_1.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._error.call(this, err);
	    };
	    BufferToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context_2 = contexts.shift();
	            this.destination.next(context_2.buffer);
	            context_2.subscription.unsubscribe();
	            context_2.buffer = null;
	            context_2.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._complete.call(this);
	    };
	    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
	    };
	    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.closeBuffer(innerSub.context);
	    };
	    BufferToggleSubscriber.prototype.openBuffer = function (value) {
	        try {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = closingSelector.call(this, value);
	            if (closingNotifier) {
	                this.trySubscribe(closingNotifier);
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
	        var contexts = this.contexts;
	        if (contexts && context) {
	            var buffer = context.buffer, subscription = context.subscription;
	            this.destination.next(buffer);
	            contexts.splice(contexts.indexOf(context), 1);
	            this.remove(subscription);
	            subscription.unsubscribe();
	        }
	    };
	    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
	        var contexts = this.contexts;
	        var buffer = [];
	        var subscription = new Subscription();
	        var context = { buffer: buffer, subscription: subscription };
	        contexts.push(context);
	        var innerSubscription = subscribeToResult(this, closingNotifier, context);
	        if (!innerSubscription || innerSubscription.closed) {
	            this.closeBuffer(context);
	        }
	        else {
	            innerSubscription.context = context;
	            this.add(innerSubscription);
	            subscription.add(innerSubscription);
	        }
	    };
	    return BufferToggleSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function bufferWhen(closingSelector) {
	    return function (source) {
	        return source.lift(new BufferWhenOperator(closingSelector));
	    };
	}
	var BufferWhenOperator = /*@__PURE__*/ (function () {
	    function BufferWhenOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    BufferWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
	    };
	    return BufferWhenOperator;
	}());
	var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(BufferWhenSubscriber, _super);
	    function BufferWhenSubscriber(destination, closingSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.closingSelector = closingSelector;
	        _this.subscribing = false;
	        _this.openBuffer();
	        return _this;
	    }
	    BufferWhenSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferWhenSubscriber.prototype._complete = function () {
	        var buffer = this.buffer;
	        if (buffer) {
	            this.destination.next(buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferWhenSubscriber.prototype._unsubscribe = function () {
	        this.buffer = null;
	        this.subscribing = false;
	    };
	    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openBuffer();
	    };
	    BufferWhenSubscriber.prototype.notifyComplete = function () {
	        if (this.subscribing) {
	            this.complete();
	        }
	        else {
	            this.openBuffer();
	        }
	    };
	    BufferWhenSubscriber.prototype.openBuffer = function () {
	        var closingSubscription = this.closingSubscription;
	        if (closingSubscription) {
	            this.remove(closingSubscription);
	            closingSubscription.unsubscribe();
	        }
	        var buffer = this.buffer;
	        if (this.buffer) {
	            this.destination.next(buffer);
	        }
	        this.buffer = [];
	        var closingNotifier;
	        try {
	            var closingSelector = this.closingSelector;
	            closingNotifier = closingSelector();
	        }
	        catch (err) {
	            return this.error(err);
	        }
	        closingSubscription = new Subscription();
	        this.closingSubscription = closingSubscription;
	        this.add(closingSubscription);
	        this.subscribing = true;
	        closingSubscription.add(subscribeToResult(this, closingNotifier));
	        this.subscribing = false;
	    };
	    return BufferWhenSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function catchError(selector) {
	    return function catchErrorOperatorFunction(source) {
	        var operator = new CatchOperator(selector);
	        var caught = source.lift(operator);
	        return (operator.caught = caught);
	    };
	}
	var CatchOperator = /*@__PURE__*/ (function () {
	    function CatchOperator(selector) {
	        this.selector = selector;
	    }
	    CatchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
	    };
	    return CatchOperator;
	}());
	var CatchSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(CatchSubscriber, _super);
	    function CatchSubscriber(destination, selector, caught) {
	        var _this = _super.call(this, destination) || this;
	        _this.selector = selector;
	        _this.caught = caught;
	        return _this;
	    }
	    CatchSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var result = void 0;
	            try {
	                result = this.selector(err, this.caught);
	            }
	            catch (err2) {
	                _super.prototype.error.call(this, err2);
	                return;
	            }
	            this._unsubscribeAndRecycle();
	            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	            this.add(innerSubscriber);
	            subscribeToResult(this, result, undefined, undefined, innerSubscriber);
	        }
	    };
	    return CatchSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */
	function combineAll(project) {
	    return function (source) { return source.lift(new CombineLatestOperator(project)); };
	}

	/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */
	function combineLatest$1() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    var project = null;
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    if (observables.length === 1 && isArray(observables[0])) {
	        observables = observables[0].slice();
	    }
	    return function (source) { return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project)); };
	}

	/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */
	function concat$1() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    return function (source) { return source.lift.call(concat.apply(void 0, [source].concat(observables))); };
	}

	/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
	function concatMap(project, resultSelector) {
	    return mergeMap(project, resultSelector, 1);
	}

	/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */
	function concatMapTo(innerObservable, resultSelector) {
	    return concatMap(function () { return innerObservable; }, resultSelector);
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function count(predicate) {
	    return function (source) { return source.lift(new CountOperator(predicate, source)); };
	}
	var CountOperator = /*@__PURE__*/ (function () {
	    function CountOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    CountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
	    };
	    return CountOperator;
	}());
	var CountSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(CountSubscriber, _super);
	    function CountSubscriber(destination, predicate, source) {
	        var _this = _super.call(this, destination) || this;
	        _this.predicate = predicate;
	        _this.source = source;
	        _this.count = 0;
	        _this.index = 0;
	        return _this;
	    }
	    CountSubscriber.prototype._next = function (value) {
	        if (this.predicate) {
	            this._tryPredicate(value);
	        }
	        else {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._tryPredicate = function (value) {
	        var result;
	        try {
	            result = this.predicate(value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._complete = function () {
	        this.destination.next(this.count);
	        this.destination.complete();
	    };
	    return CountSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function debounce(durationSelector) {
	    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
	}
	var DebounceOperator = /*@__PURE__*/ (function () {
	    function DebounceOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    DebounceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
	    };
	    return DebounceOperator;
	}());
	var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(DebounceSubscriber, _super);
	    function DebounceSubscriber(destination, durationSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.durationSelector = durationSelector;
	        _this.hasValue = false;
	        _this.durationSubscription = null;
	        return _this;
	    }
	    DebounceSubscriber.prototype._next = function (value) {
	        try {
	            var result = this.durationSelector.call(this, value);
	            if (result) {
	                this._tryNext(value, result);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DebounceSubscriber.prototype._complete = function () {
	        this.emitValue();
	        this.destination.complete();
	    };
	    DebounceSubscriber.prototype._tryNext = function (value, duration) {
	        var subscription = this.durationSubscription;
	        this.value = value;
	        this.hasValue = true;
	        if (subscription) {
	            subscription.unsubscribe();
	            this.remove(subscription);
	        }
	        subscription = subscribeToResult(this, duration);
	        if (subscription && !subscription.closed) {
	            this.add(this.durationSubscription = subscription);
	        }
	    };
	    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            var value = this.value;
	            var subscription = this.durationSubscription;
	            if (subscription) {
	                this.durationSubscription = null;
	                subscription.unsubscribe();
	                this.remove(subscription);
	            }
	            this.value = null;
	            this.hasValue = false;
	            _super.prototype._next.call(this, value);
	        }
	    };
	    return DebounceSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
	function debounceTime(dueTime, scheduler) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
	}
	var DebounceTimeOperator = /*@__PURE__*/ (function () {
	    function DebounceTimeOperator(dueTime, scheduler) {
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }
	    DebounceTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
	    };
	    return DebounceTimeOperator;
	}());
	var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(DebounceTimeSubscriber, _super);
	    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	        var _this = _super.call(this, destination) || this;
	        _this.dueTime = dueTime;
	        _this.scheduler = scheduler;
	        _this.debouncedSubscription = null;
	        _this.lastValue = null;
	        _this.hasValue = false;
	        return _this;
	    }
	    DebounceTimeSubscriber.prototype._next = function (value) {
	        this.clearDebounce();
	        this.lastValue = value;
	        this.hasValue = true;
	        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$2, this.dueTime, this));
	    };
	    DebounceTimeSubscriber.prototype._complete = function () {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	    DebounceTimeSubscriber.prototype.debouncedNext = function () {
	        this.clearDebounce();
	        if (this.hasValue) {
	            var lastValue = this.lastValue;
	            this.lastValue = null;
	            this.hasValue = false;
	            this.destination.next(lastValue);
	        }
	    };
	    DebounceTimeSubscriber.prototype.clearDebounce = function () {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            debouncedSubscription.unsubscribe();
	            this.debouncedSubscription = null;
	        }
	    };
	    return DebounceTimeSubscriber;
	}(Subscriber));
	function dispatchNext$2(subscriber) {
	    subscriber.debouncedNext();
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function defaultIfEmpty(defaultValue) {
	    if (defaultValue === void 0) {
	        defaultValue = null;
	    }
	    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
	}
	var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        this.defaultValue = defaultValue;
	    }
	    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
	    };
	    return DefaultIfEmptyOperator;
	}());
	var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(DefaultIfEmptySubscriber, _super);
	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        var _this = _super.call(this, destination) || this;
	        _this.defaultValue = defaultValue;
	        _this.isEmpty = true;
	        return _this;
	    }
	    DefaultIfEmptySubscriber.prototype._next = function (value) {
	        this.isEmpty = false;
	        this.destination.next(value);
	    };
	    DefaultIfEmptySubscriber.prototype._complete = function () {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };
	    return DefaultIfEmptySubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function isDate(value) {
	    return value instanceof Date && !isNaN(+value);
	}

	/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
	function delay(delay, scheduler) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    var absoluteDelay = isDate(delay);
	    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
	    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
	}
	var DelayOperator = /*@__PURE__*/ (function () {
	    function DelayOperator(delay, scheduler) {
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	    DelayOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
	    };
	    return DelayOperator;
	}());
	var DelaySubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(DelaySubscriber, _super);
	    function DelaySubscriber(destination, delay, scheduler) {
	        var _this = _super.call(this, destination) || this;
	        _this.delay = delay;
	        _this.scheduler = scheduler;
	        _this.queue = [];
	        _this.active = false;
	        _this.errored = false;
	        return _this;
	    }
	    DelaySubscriber.dispatch = function (state) {
	        var source = state.source;
	        var queue = source.queue;
	        var scheduler = state.scheduler;
	        var destination = state.destination;
	        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
	            queue.shift().notification.observe(destination);
	        }
	        if (queue.length > 0) {
	            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
	            this.schedule(state, delay_1);
	        }
	        else {
	            this.unsubscribe();
	            source.active = false;
	        }
	    };
	    DelaySubscriber.prototype._schedule = function (scheduler) {
	        this.active = true;
	        var destination = this.destination;
	        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	            source: this, destination: this.destination, scheduler: scheduler
	        }));
	    };
	    DelaySubscriber.prototype.scheduleNotification = function (notification) {
	        if (this.errored === true) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        var message = new DelayMessage(scheduler.now() + this.delay, notification);
	        this.queue.push(message);
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };
	    DelaySubscriber.prototype._next = function (value) {
	        this.scheduleNotification(Notification.createNext(value));
	    };
	    DelaySubscriber.prototype._error = function (err) {
	        this.errored = true;
	        this.queue = [];
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    DelaySubscriber.prototype._complete = function () {
	        this.scheduleNotification(Notification.createComplete());
	        this.unsubscribe();
	    };
	    return DelaySubscriber;
	}(Subscriber));
	var DelayMessage = /*@__PURE__*/ (function () {
	    function DelayMessage(time, notification) {
	        this.time = time;
	        this.notification = notification;
	    }
	    return DelayMessage;
	}());

	/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function delayWhen(delayDurationSelector, subscriptionDelay) {
	    if (subscriptionDelay) {
	        return function (source) {
	            return new SubscriptionDelayObservable(source, subscriptionDelay)
	                .lift(new DelayWhenOperator(delayDurationSelector));
	        };
	    }
	    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
	}
	var DelayWhenOperator = /*@__PURE__*/ (function () {
	    function DelayWhenOperator(delayDurationSelector) {
	        this.delayDurationSelector = delayDurationSelector;
	    }
	    DelayWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
	    };
	    return DelayWhenOperator;
	}());
	var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(DelayWhenSubscriber, _super);
	    function DelayWhenSubscriber(destination, delayDurationSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.delayDurationSelector = delayDurationSelector;
	        _this.completed = false;
	        _this.delayNotifierSubscriptions = [];
	        _this.index = 0;
	        return _this;
	    }
	    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(outerValue);
	        this.removeSubscription(innerSub);
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	        var value = this.removeSubscription(innerSub);
	        if (value) {
	            this.destination.next(value);
	        }
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        try {
	            var delayNotifier = this.delayDurationSelector(value, index);
	            if (delayNotifier) {
	                this.tryDelay(delayNotifier, value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DelayWhenSubscriber.prototype._complete = function () {
	        this.completed = true;
	        this.tryComplete();
	        this.unsubscribe();
	    };
	    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
	        subscription.unsubscribe();
	        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
	        if (subscriptionIdx !== -1) {
	            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
	        }
	        return subscription.outerValue;
	    };
	    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
	        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
	        if (notifierSubscription && !notifierSubscription.closed) {
	            var destination = this.destination;
	            destination.add(notifierSubscription);
	            this.delayNotifierSubscriptions.push(notifierSubscription);
	        }
	    };
	    DelayWhenSubscriber.prototype.tryComplete = function () {
	        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
	            this.destination.complete();
	        }
	    };
	    return DelayWhenSubscriber;
	}(OuterSubscriber));
	var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
	    __extends(SubscriptionDelayObservable, _super);
	    function SubscriptionDelayObservable(source, subscriptionDelay) {
	        var _this = _super.call(this) || this;
	        _this.source = source;
	        _this.subscriptionDelay = subscriptionDelay;
	        return _this;
	    }
	    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
	        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
	    };
	    return SubscriptionDelayObservable;
	}(Observable));
	var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SubscriptionDelaySubscriber, _super);
	    function SubscriptionDelaySubscriber(parent, source) {
	        var _this = _super.call(this) || this;
	        _this.parent = parent;
	        _this.source = source;
	        _this.sourceSubscribed = false;
	        return _this;
	    }
	    SubscriptionDelaySubscriber.prototype._next = function (unused) {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype._error = function (err) {
	        this.unsubscribe();
	        this.parent.error(err);
	    };
	    SubscriptionDelaySubscriber.prototype._complete = function () {
	        this.unsubscribe();
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
	        if (!this.sourceSubscribed) {
	            this.sourceSubscribed = true;
	            this.unsubscribe();
	            this.source.subscribe(this.parent);
	        }
	    };
	    return SubscriptionDelaySubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function dematerialize() {
	    return function dematerializeOperatorFunction(source) {
	        return source.lift(new DeMaterializeOperator());
	    };
	}
	var DeMaterializeOperator = /*@__PURE__*/ (function () {
	    function DeMaterializeOperator() {
	    }
	    DeMaterializeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DeMaterializeSubscriber(subscriber));
	    };
	    return DeMaterializeOperator;
	}());
	var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(DeMaterializeSubscriber, _super);
	    function DeMaterializeSubscriber(destination) {
	        return _super.call(this, destination) || this;
	    }
	    DeMaterializeSubscriber.prototype._next = function (value) {
	        value.observe(this.destination);
	    };
	    return DeMaterializeSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function distinct(keySelector, flushes) {
	    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
	}
	var DistinctOperator = /*@__PURE__*/ (function () {
	    function DistinctOperator(keySelector, flushes) {
	        this.keySelector = keySelector;
	        this.flushes = flushes;
	    }
	    DistinctOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
	    };
	    return DistinctOperator;
	}());
	var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(DistinctSubscriber, _super);
	    function DistinctSubscriber(destination, keySelector, flushes) {
	        var _this = _super.call(this, destination) || this;
	        _this.keySelector = keySelector;
	        _this.values = new Set();
	        if (flushes) {
	            _this.add(subscribeToResult(_this, flushes));
	        }
	        return _this;
	    }
	    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values.clear();
	    };
	    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DistinctSubscriber.prototype._next = function (value) {
	        if (this.keySelector) {
	            this._useKeySelector(value);
	        }
	        else {
	            this._finalizeNext(value, value);
	        }
	    };
	    DistinctSubscriber.prototype._useKeySelector = function (value) {
	        var key;
	        var destination = this.destination;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this._finalizeNext(key, value);
	    };
	    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
	        var values = this.values;
	        if (!values.has(key)) {
	            values.add(key);
	            this.destination.next(value);
	        }
	    };
	    return DistinctSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function distinctUntilChanged(compare, keySelector) {
	    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
	}
	var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
	    function DistinctUntilChangedOperator(compare, keySelector) {
	        this.compare = compare;
	        this.keySelector = keySelector;
	    }
	    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
	    };
	    return DistinctUntilChangedOperator;
	}());
	var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(DistinctUntilChangedSubscriber, _super);
	    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.keySelector = keySelector;
	        _this.hasKey = false;
	        if (typeof compare === 'function') {
	            _this.compare = compare;
	        }
	        return _this;
	    }
	    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
	        return x === y;
	    };
	    DistinctUntilChangedSubscriber.prototype._next = function (value) {
	        var key;
	        try {
	            var keySelector = this.keySelector;
	            key = keySelector ? keySelector(value) : value;
	        }
	        catch (err) {
	            return this.destination.error(err);
	        }
	        var result = false;
	        if (this.hasKey) {
	            try {
	                var compare = this.compare;
	                result = compare(this.key, key);
	            }
	            catch (err) {
	                return this.destination.error(err);
	            }
	        }
	        else {
	            this.hasKey = true;
	        }
	        if (!result) {
	            this.key = key;
	            this.destination.next(value);
	        }
	    };
	    return DistinctUntilChangedSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */
	function distinctUntilKeyChanged(key, compare) {
	    return distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function filter(predicate, thisArg) {
	    return function filterOperatorFunction(source) {
	        return source.lift(new FilterOperator(predicate, thisArg));
	    };
	}
	var FilterOperator = /*@__PURE__*/ (function () {
	    function FilterOperator(predicate, thisArg) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	    }
	    FilterOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
	    };
	    return FilterOperator;
	}());
	var FilterSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(FilterSubscriber, _super);
	    function FilterSubscriber(destination, predicate, thisArg) {
	        var _this = _super.call(this, destination) || this;
	        _this.predicate = predicate;
	        _this.thisArg = thisArg;
	        _this.count = 0;
	        return _this;
	    }
	    FilterSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.destination.next(value);
	        }
	    };
	    return FilterSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
	function tap(nextOrObserver, error, complete) {
	    return function tapOperatorFunction(source) {
	        return source.lift(new DoOperator(nextOrObserver, error, complete));
	    };
	}
	var DoOperator = /*@__PURE__*/ (function () {
	    function DoOperator(nextOrObserver, error, complete) {
	        this.nextOrObserver = nextOrObserver;
	        this.error = error;
	        this.complete = complete;
	    }
	    DoOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
	    };
	    return DoOperator;
	}());
	var TapSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(TapSubscriber, _super);
	    function TapSubscriber(destination, observerOrNext, error, complete) {
	        var _this = _super.call(this, destination) || this;
	        _this._tapNext = noop;
	        _this._tapError = noop;
	        _this._tapComplete = noop;
	        _this._tapError = error || noop;
	        _this._tapComplete = complete || noop;
	        if (isFunction(observerOrNext)) {
	            _this._context = _this;
	            _this._tapNext = observerOrNext;
	        }
	        else if (observerOrNext) {
	            _this._context = observerOrNext;
	            _this._tapNext = observerOrNext.next || noop;
	            _this._tapError = observerOrNext.error || noop;
	            _this._tapComplete = observerOrNext.complete || noop;
	        }
	        return _this;
	    }
	    TapSubscriber.prototype._next = function (value) {
	        try {
	            this._tapNext.call(this._context, value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(value);
	    };
	    TapSubscriber.prototype._error = function (err) {
	        try {
	            this._tapError.call(this._context, err);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.error(err);
	    };
	    TapSubscriber.prototype._complete = function () {
	        try {
	            this._tapComplete.call(this._context);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        return this.destination.complete();
	    };
	    return TapSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */
	var throwIfEmpty = function (errorFactory) {
	    if (errorFactory === void 0) {
	        errorFactory = defaultErrorFactory;
	    }
	    return tap({
	        hasValue: false,
	        next: function () { this.hasValue = true; },
	        complete: function () {
	            if (!this.hasValue) {
	                throw errorFactory();
	            }
	        }
	    });
	};
	function defaultErrorFactory() {
	    return new EmptyError();
	}

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
	function take(count) {
	    return function (source) {
	        if (count === 0) {
	            return empty$1();
	        }
	        else {
	            return source.lift(new TakeOperator(count));
	        }
	    };
	}
	var TakeOperator = /*@__PURE__*/ (function () {
	    function TakeOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError;
	        }
	    }
	    TakeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeSubscriber(subscriber, this.total));
	    };
	    return TakeOperator;
	}());
	var TakeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(TakeSubscriber, _super);
	    function TakeSubscriber(destination, total) {
	        var _this = _super.call(this, destination) || this;
	        _this.total = total;
	        _this.count = 0;
	        return _this;
	    }
	    TakeSubscriber.prototype._next = function (value) {
	        var total = this.total;
	        var count = ++this.count;
	        if (count <= total) {
	            this.destination.next(value);
	            if (count === total) {
	                this.destination.complete();
	                this.unsubscribe();
	            }
	        }
	    };
	    return TakeSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */
	function elementAt(index, defaultValue) {
	    if (index < 0) {
	        throw new ArgumentOutOfRangeError();
	    }
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(filter(function (v, i) { return i === index; }), take(1), hasDefaultValue
	            ? defaultIfEmpty(defaultValue)
	            : throwIfEmpty(function () { return new ArgumentOutOfRangeError(); }));
	    };
	}

	/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
	function endWith() {
	    var array = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        array[_i] = arguments[_i];
	    }
	    return function (source) {
	        var scheduler = array[array.length - 1];
	        if (isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len === 1 && !scheduler) {
	            return concat(source, scalar(array[0]));
	        }
	        else if (len > 0) {
	            return concat(source, fromArray(array, scheduler));
	        }
	        else {
	            return concat(source, empty$1(scheduler));
	        }
	    };
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function every(predicate, thisArg) {
	    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
	}
	var EveryOperator = /*@__PURE__*/ (function () {
	    function EveryOperator(predicate, thisArg, source) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	    EveryOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
	    };
	    return EveryOperator;
	}());
	var EverySubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(EverySubscriber, _super);
	    function EverySubscriber(destination, predicate, thisArg, source) {
	        var _this = _super.call(this, destination) || this;
	        _this.predicate = predicate;
	        _this.thisArg = thisArg;
	        _this.source = source;
	        _this.index = 0;
	        _this.thisArg = thisArg || _this;
	        return _this;
	    }
	    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
	        this.destination.next(everyValueMatch);
	        this.destination.complete();
	    };
	    EverySubscriber.prototype._next = function (value) {
	        var result = false;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (!result) {
	            this.notifyComplete(false);
	        }
	    };
	    EverySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return EverySubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function exhaust() {
	    return function (source) { return source.lift(new SwitchFirstOperator()); };
	}
	var SwitchFirstOperator = /*@__PURE__*/ (function () {
	    function SwitchFirstOperator() {
	    }
	    SwitchFirstOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchFirstSubscriber(subscriber));
	    };
	    return SwitchFirstOperator;
	}());
	var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SwitchFirstSubscriber, _super);
	    function SwitchFirstSubscriber(destination) {
	        var _this = _super.call(this, destination) || this;
	        _this.hasCompleted = false;
	        _this.hasSubscription = false;
	        return _this;
	    }
	    SwitchFirstSubscriber.prototype._next = function (value) {
	        if (!this.hasSubscription) {
	            this.hasSubscription = true;
	            this.add(subscribeToResult(this, value));
	        }
	    };
	    SwitchFirstSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (!this.hasSubscription) {
	            this.destination.complete();
	        }
	    };
	    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.hasSubscription = false;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return SwitchFirstSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
	function exhaustMap(project, resultSelector) {
	    if (resultSelector) {
	        return function (source) { return source.pipe(exhaustMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
	    }
	    return function (source) {
	        return source.lift(new ExhaustMapOperator(project));
	    };
	}
	var ExhaustMapOperator = /*@__PURE__*/ (function () {
	    function ExhaustMapOperator(project) {
	        this.project = project;
	    }
	    ExhaustMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
	    };
	    return ExhaustMapOperator;
	}());
	var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ExhaustMapSubscriber, _super);
	    function ExhaustMapSubscriber(destination, project) {
	        var _this = _super.call(this, destination) || this;
	        _this.project = project;
	        _this.hasSubscription = false;
	        _this.hasCompleted = false;
	        _this.index = 0;
	        return _this;
	    }
	    ExhaustMapSubscriber.prototype._next = function (value) {
	        if (!this.hasSubscription) {
	            this.tryNext(value);
	        }
	    };
	    ExhaustMapSubscriber.prototype.tryNext = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.hasSubscription = true;
	        this._innerSub(result, value, index);
	    };
	    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	        var destination = this.destination;
	        destination.add(innerSubscriber);
	        subscribeToResult(this, result, value, index, innerSubscriber);
	    };
	    ExhaustMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (!this.hasSubscription) {
	            this.destination.complete();
	        }
	        this.unsubscribe();
	    };
	    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    ExhaustMapSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var destination = this.destination;
	        destination.remove(innerSub);
	        this.hasSubscription = false;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return ExhaustMapSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function expand(project, concurrent, scheduler) {
	    if (concurrent === void 0) {
	        concurrent = Number.POSITIVE_INFINITY;
	    }
	    if (scheduler === void 0) {
	        scheduler = undefined;
	    }
	    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
	    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
	}
	var ExpandOperator = /*@__PURE__*/ (function () {
	    function ExpandOperator(project, concurrent, scheduler) {
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	    }
	    ExpandOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
	    };
	    return ExpandOperator;
	}());
	var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ExpandSubscriber, _super);
	    function ExpandSubscriber(destination, project, concurrent, scheduler) {
	        var _this = _super.call(this, destination) || this;
	        _this.project = project;
	        _this.concurrent = concurrent;
	        _this.scheduler = scheduler;
	        _this.index = 0;
	        _this.active = 0;
	        _this.hasCompleted = false;
	        if (concurrent < Number.POSITIVE_INFINITY) {
	            _this.buffer = [];
	        }
	        return _this;
	    }
	    ExpandSubscriber.dispatch = function (arg) {
	        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
	        subscriber.subscribeToProjection(result, value, index);
	    };
	    ExpandSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (destination.closed) {
	            this._complete();
	            return;
	        }
	        var index = this.index++;
	        if (this.active < this.concurrent) {
	            destination.next(value);
	            try {
	                var project = this.project;
	                var result = project(value, index);
	                if (!this.scheduler) {
	                    this.subscribeToProjection(result, value, index);
	                }
	                else {
	                    var state = { subscriber: this, result: result, value: value, index: index };
	                    var destination_1 = this.destination;
	                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
	                }
	            }
	            catch (e) {
	                destination.error(e);
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
	        this.active++;
	        var destination = this.destination;
	        destination.add(subscribeToResult(this, result, value, index));
	    };
	    ExpandSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	        this.unsubscribe();
	    };
	    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._next(innerValue);
	    };
	    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        var destination = this.destination;
	        destination.remove(innerSub);
	        this.active--;
	        if (buffer && buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return ExpandSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
	function finalize(callback) {
	    return function (source) { return source.lift(new FinallyOperator(callback)); };
	}
	var FinallyOperator = /*@__PURE__*/ (function () {
	    function FinallyOperator(callback) {
	        this.callback = callback;
	    }
	    FinallyOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
	    };
	    return FinallyOperator;
	}());
	var FinallySubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(FinallySubscriber, _super);
	    function FinallySubscriber(destination, callback) {
	        var _this = _super.call(this, destination) || this;
	        _this.add(new Subscription(callback));
	        return _this;
	    }
	    return FinallySubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function find(predicate, thisArg) {
	    if (typeof predicate !== 'function') {
	        throw new TypeError('predicate is not a function');
	    }
	    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
	}
	var FindValueOperator = /*@__PURE__*/ (function () {
	    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
	        this.predicate = predicate;
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	    }
	    FindValueOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
	    };
	    return FindValueOperator;
	}());
	var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(FindValueSubscriber, _super);
	    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
	        var _this = _super.call(this, destination) || this;
	        _this.predicate = predicate;
	        _this.source = source;
	        _this.yieldIndex = yieldIndex;
	        _this.thisArg = thisArg;
	        _this.index = 0;
	        return _this;
	    }
	    FindValueSubscriber.prototype.notifyComplete = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	        this.unsubscribe();
	    };
	    FindValueSubscriber.prototype._next = function (value) {
	        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
	        var index = this.index++;
	        try {
	            var result = predicate.call(thisArg || this, value, index, this.source);
	            if (result) {
	                this.notifyComplete(this.yieldIndex ? index : value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    FindValueSubscriber.prototype._complete = function () {
	        this.notifyComplete(this.yieldIndex ? -1 : undefined);
	    };
	    return FindValueSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */
	function findIndex(predicate, thisArg) {
	    return function (source) { return source.lift(new FindValueOperator(predicate, source, true, thisArg)); };
	}

	/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
	function first(predicate, defaultValue) {
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function ignoreElements() {
	    return function ignoreElementsOperatorFunction(source) {
	        return source.lift(new IgnoreElementsOperator());
	    };
	}
	var IgnoreElementsOperator = /*@__PURE__*/ (function () {
	    function IgnoreElementsOperator() {
	    }
	    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
	    };
	    return IgnoreElementsOperator;
	}());
	var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(IgnoreElementsSubscriber, _super);
	    function IgnoreElementsSubscriber() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    IgnoreElementsSubscriber.prototype._next = function (unused) {
	    };
	    return IgnoreElementsSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function isEmpty() {
	    return function (source) { return source.lift(new IsEmptyOperator()); };
	}
	var IsEmptyOperator = /*@__PURE__*/ (function () {
	    function IsEmptyOperator() {
	    }
	    IsEmptyOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new IsEmptySubscriber(observer));
	    };
	    return IsEmptyOperator;
	}());
	var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(IsEmptySubscriber, _super);
	    function IsEmptySubscriber(destination) {
	        return _super.call(this, destination) || this;
	    }
	    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
	        var destination = this.destination;
	        destination.next(isEmpty);
	        destination.complete();
	    };
	    IsEmptySubscriber.prototype._next = function (value) {
	        this.notifyComplete(false);
	    };
	    IsEmptySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return IsEmptySubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
	function takeLast(count) {
	    return function takeLastOperatorFunction(source) {
	        if (count === 0) {
	            return empty$1();
	        }
	        else {
	            return source.lift(new TakeLastOperator(count));
	        }
	    };
	}
	var TakeLastOperator = /*@__PURE__*/ (function () {
	    function TakeLastOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError;
	        }
	    }
	    TakeLastOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
	    };
	    return TakeLastOperator;
	}());
	var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(TakeLastSubscriber, _super);
	    function TakeLastSubscriber(destination, total) {
	        var _this = _super.call(this, destination) || this;
	        _this.total = total;
	        _this.ring = new Array();
	        _this.count = 0;
	        return _this;
	    }
	    TakeLastSubscriber.prototype._next = function (value) {
	        var ring = this.ring;
	        var total = this.total;
	        var count = this.count++;
	        if (ring.length < total) {
	            ring.push(value);
	        }
	        else {
	            var index = count % total;
	            ring[index] = value;
	        }
	    };
	    TakeLastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        var count = this.count;
	        if (count > 0) {
	            var total = this.count >= this.total ? this.total : this.count;
	            var ring = this.ring;
	            for (var i = 0; i < total; i++) {
	                var idx = (count++) % total;
	                destination.next(ring[idx]);
	            }
	        }
	        destination.complete();
	    };
	    return TakeLastSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */
	function last(predicate, defaultValue) {
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function mapTo(value) {
	    return function (source) { return source.lift(new MapToOperator(value)); };
	}
	var MapToOperator = /*@__PURE__*/ (function () {
	    function MapToOperator(value) {
	        this.value = value;
	    }
	    MapToOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapToSubscriber(subscriber, this.value));
	    };
	    return MapToOperator;
	}());
	var MapToSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(MapToSubscriber, _super);
	    function MapToSubscriber(destination, value) {
	        var _this = _super.call(this, destination) || this;
	        _this.value = value;
	        return _this;
	    }
	    MapToSubscriber.prototype._next = function (x) {
	        this.destination.next(this.value);
	    };
	    return MapToSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
	function materialize() {
	    return function materializeOperatorFunction(source) {
	        return source.lift(new MaterializeOperator());
	    };
	}
	var MaterializeOperator = /*@__PURE__*/ (function () {
	    function MaterializeOperator() {
	    }
	    MaterializeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MaterializeSubscriber(subscriber));
	    };
	    return MaterializeOperator;
	}());
	var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(MaterializeSubscriber, _super);
	    function MaterializeSubscriber(destination) {
	        return _super.call(this, destination) || this;
	    }
	    MaterializeSubscriber.prototype._next = function (value) {
	        this.destination.next(Notification.createNext(value));
	    };
	    MaterializeSubscriber.prototype._error = function (err) {
	        var destination = this.destination;
	        destination.next(Notification.createError(err));
	        destination.complete();
	    };
	    MaterializeSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        destination.next(Notification.createComplete());
	        destination.complete();
	    };
	    return MaterializeSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function scan(accumulator, seed) {
	    var hasSeed = false;
	    if (arguments.length >= 2) {
	        hasSeed = true;
	    }
	    return function scanOperatorFunction(source) {
	        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
	    };
	}
	var ScanOperator = /*@__PURE__*/ (function () {
	    function ScanOperator(accumulator, seed, hasSeed) {
	        if (hasSeed === void 0) {
	            hasSeed = false;
	        }
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.hasSeed = hasSeed;
	    }
	    ScanOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
	    };
	    return ScanOperator;
	}());
	var ScanSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ScanSubscriber, _super);
	    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
	        var _this = _super.call(this, destination) || this;
	        _this.accumulator = accumulator;
	        _this._seed = _seed;
	        _this.hasSeed = hasSeed;
	        _this.index = 0;
	        return _this;
	    }
	    Object.defineProperty(ScanSubscriber.prototype, "seed", {
	        get: function () {
	            return this._seed;
	        },
	        set: function (value) {
	            this.hasSeed = true;
	            this._seed = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ScanSubscriber.prototype._next = function (value) {
	        if (!this.hasSeed) {
	            this.seed = value;
	            this.destination.next(value);
	        }
	        else {
	            return this._tryNext(value);
	        }
	    };
	    ScanSubscriber.prototype._tryNext = function (value) {
	        var index = this.index++;
	        var result;
	        try {
	            result = this.accumulator(this.seed, value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	        this.seed = result;
	        this.destination.next(result);
	    };
	    return ScanSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */
	function reduce(accumulator, seed) {
	    if (arguments.length >= 2) {
	        return function reduceOperatorFunctionWithSeed(source) {
	            return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
	        };
	    }
	    return function reduceOperatorFunction(source) {
	        return pipe(scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast(1))(source);
	    };
	}

	/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
	function max(comparer) {
	    var max = (typeof comparer === 'function')
	        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
	        : function (x, y) { return x > y ? x : y; };
	    return reduce(max);
	}

	/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */
	function merge$1() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    return function (source) { return source.lift.call(merge.apply(void 0, [source].concat(observables))); };
	}

	/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
	function mergeMapTo(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) {
	        concurrent = Number.POSITIVE_INFINITY;
	    }
	    if (typeof resultSelector === 'function') {
	        return mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
	    }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	    }
	    return mergeMap(function () { return innerObservable; }, concurrent);
	}

	/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */
	function mergeScan(accumulator, seed, concurrent) {
	    if (concurrent === void 0) {
	        concurrent = Number.POSITIVE_INFINITY;
	    }
	    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
	}
	var MergeScanOperator = /*@__PURE__*/ (function () {
	    function MergeScanOperator(accumulator, seed, concurrent) {
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.concurrent = concurrent;
	    }
	    MergeScanOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
	    };
	    return MergeScanOperator;
	}());
	var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(MergeScanSubscriber, _super);
	    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
	        var _this = _super.call(this, destination) || this;
	        _this.accumulator = accumulator;
	        _this.acc = acc;
	        _this.concurrent = concurrent;
	        _this.hasValue = false;
	        _this.hasCompleted = false;
	        _this.buffer = [];
	        _this.active = 0;
	        _this.index = 0;
	        return _this;
	    }
	    MergeScanSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var index = this.index++;
	            var destination = this.destination;
	            var ish = void 0;
	            try {
	                var accumulator = this.accumulator;
	                ish = accumulator(this.acc, value, index);
	            }
	            catch (e) {
	                return destination.error(e);
	            }
	            this.active++;
	            this._innerSub(ish, value, index);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
	        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	        var destination = this.destination;
	        destination.add(innerSubscriber);
	        subscribeToResult(this, ish, value, index, innerSubscriber);
	    };
	    MergeScanSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            if (this.hasValue === false) {
	                this.destination.next(this.acc);
	            }
	            this.destination.complete();
	        }
	        this.unsubscribe();
	    };
	    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var destination = this.destination;
	        this.acc = innerValue;
	        this.hasValue = true;
	        destination.next(innerValue);
	    };
	    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        var destination = this.destination;
	        destination.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            if (this.hasValue === false) {
	                this.destination.next(this.acc);
	            }
	            this.destination.complete();
	        }
	    };
	    return MergeScanSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
	function min(comparer) {
	    var min = (typeof comparer === 'function')
	        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
	        : function (x, y) { return x < y ? x : y; };
	    return reduce(min);
	}

	/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
	function multicast(subjectOrSubjectFactory, selector) {
	    return function multicastOperatorFunction(source) {
	        var subjectFactory;
	        if (typeof subjectOrSubjectFactory === 'function') {
	            subjectFactory = subjectOrSubjectFactory;
	        }
	        else {
	            subjectFactory = function subjectFactory() {
	                return subjectOrSubjectFactory;
	            };
	        }
	        if (typeof selector === 'function') {
	            return source.lift(new MulticastOperator(subjectFactory, selector));
	        }
	        var connectable = Object.create(source, connectableObservableDescriptor);
	        connectable.source = source;
	        connectable.subjectFactory = subjectFactory;
	        return connectable;
	    };
	}
	var MulticastOperator = /*@__PURE__*/ (function () {
	    function MulticastOperator(subjectFactory, selector) {
	        this.subjectFactory = subjectFactory;
	        this.selector = selector;
	    }
	    MulticastOperator.prototype.call = function (subscriber, source) {
	        var selector = this.selector;
	        var subject = this.subjectFactory();
	        var subscription = selector(subject).subscribe(subscriber);
	        subscription.add(source.subscribe(subject));
	        return subscription;
	    };
	    return MulticastOperator;
	}());

	/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function onErrorResumeNext$1() {
	    var nextSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        nextSources[_i] = arguments[_i];
	    }
	    if (nextSources.length === 1 && isArray(nextSources[0])) {
	        nextSources = nextSources[0];
	    }
	    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
	}
	var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
	    function OnErrorResumeNextOperator(nextSources) {
	        this.nextSources = nextSources;
	    }
	    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
	    };
	    return OnErrorResumeNextOperator;
	}());
	var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(OnErrorResumeNextSubscriber, _super);
	    function OnErrorResumeNextSubscriber(destination, nextSources) {
	        var _this = _super.call(this, destination) || this;
	        _this.destination = destination;
	        _this.nextSources = nextSources;
	        return _this;
	    }
	    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype._error = function (err) {
	        this.subscribeToNextSource();
	        this.unsubscribe();
	    };
	    OnErrorResumeNextSubscriber.prototype._complete = function () {
	        this.subscribeToNextSource();
	        this.unsubscribe();
	    };
	    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
	        var next = this.nextSources.shift();
	        if (!!next) {
	            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	            var destination = this.destination;
	            destination.add(innerSubscriber);
	            subscribeToResult(this, next, undefined, undefined, innerSubscriber);
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return OnErrorResumeNextSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function pairwise() {
	    return function (source) { return source.lift(new PairwiseOperator()); };
	}
	var PairwiseOperator = /*@__PURE__*/ (function () {
	    function PairwiseOperator() {
	    }
	    PairwiseOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new PairwiseSubscriber(subscriber));
	    };
	    return PairwiseOperator;
	}());
	var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(PairwiseSubscriber, _super);
	    function PairwiseSubscriber(destination) {
	        var _this = _super.call(this, destination) || this;
	        _this.hasPrev = false;
	        return _this;
	    }
	    PairwiseSubscriber.prototype._next = function (value) {
	        if (this.hasPrev) {
	            this.destination.next([this.prev, value]);
	        }
	        else {
	            this.hasPrev = true;
	        }
	        this.prev = value;
	    };
	    return PairwiseSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */
	function not(pred, thisArg) {
	    function notPred() {
	        return !(notPred.pred.apply(notPred.thisArg, arguments));
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}

	/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */
	function partition(predicate, thisArg) {
	    return function (source) {
	        return [
	            filter(predicate, thisArg)(source),
	            filter(not(predicate, thisArg))(source)
	        ];
	    };
	}

	/** PURE_IMPORTS_START _map PURE_IMPORTS_END */
	function pluck() {
	    var properties = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        properties[_i] = arguments[_i];
	    }
	    var length = properties.length;
	    if (length === 0) {
	        throw new Error('list of properties cannot be empty.');
	    }
	    return function (source) { return map(plucker(properties, length))(source); };
	}
	function plucker(props, length) {
	    var mapper = function (x) {
	        var currentProp = x;
	        for (var i = 0; i < length; i++) {
	            var p = currentProp[props[i]];
	            if (typeof p !== 'undefined') {
	                currentProp = p;
	            }
	            else {
	                return undefined;
	            }
	        }
	        return currentProp;
	    };
	    return mapper;
	}

	/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
	function publish(selector) {
	    return selector ?
	        multicast(function () { return new Subject(); }, selector) :
	        multicast(new Subject());
	}

	/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */
	function publishBehavior(value) {
	    return function (source) { return multicast(new BehaviorSubject(value))(source); };
	}

	/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */
	function publishLast() {
	    return function (source) { return multicast(new AsyncSubject())(source); };
	}

	/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */
	function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
	    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
	        scheduler = selectorOrScheduler;
	    }
	    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
	    var subject = new ReplaySubject(bufferSize, windowTime, scheduler);
	    return function (source) { return multicast(function () { return subject; }, selector)(source); };
	}

	/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */
	function race$1() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    return function raceOperatorFunction(source) {
	        if (observables.length === 1 && isArray(observables[0])) {
	            observables = observables[0];
	        }
	        return source.lift.call(race.apply(void 0, [source].concat(observables)));
	    };
	}

	/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
	function repeat(count) {
	    if (count === void 0) {
	        count = -1;
	    }
	    return function (source) {
	        if (count === 0) {
	            return empty$1();
	        }
	        else if (count < 0) {
	            return source.lift(new RepeatOperator(-1, source));
	        }
	        else {
	            return source.lift(new RepeatOperator(count - 1, source));
	        }
	    };
	}
	var RepeatOperator = /*@__PURE__*/ (function () {
	    function RepeatOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RepeatOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
	    };
	    return RepeatOperator;
	}());
	var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(RepeatSubscriber, _super);
	    function RepeatSubscriber(destination, count, source) {
	        var _this = _super.call(this, destination) || this;
	        _this.count = count;
	        _this.source = source;
	        return _this;
	    }
	    RepeatSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.complete.call(this);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            source.subscribe(this._unsubscribeAndRecycle());
	        }
	    };
	    return RepeatSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function repeatWhen(notifier) {
	    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
	}
	var RepeatWhenOperator = /*@__PURE__*/ (function () {
	    function RepeatWhenOperator(notifier) {
	        this.notifier = notifier;
	    }
	    RepeatWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
	    };
	    return RepeatWhenOperator;
	}());
	var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(RepeatWhenSubscriber, _super);
	    function RepeatWhenSubscriber(destination, notifier, source) {
	        var _this = _super.call(this, destination) || this;
	        _this.notifier = notifier;
	        _this.source = source;
	        _this.sourceIsBeingSubscribedTo = true;
	        return _this;
	    }
	    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.sourceIsBeingSubscribedTo = true;
	        this.source.subscribe(this);
	    };
	    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	        if (this.sourceIsBeingSubscribedTo === false) {
	            return _super.prototype.complete.call(this);
	        }
	    };
	    RepeatWhenSubscriber.prototype.complete = function () {
	        this.sourceIsBeingSubscribedTo = false;
	        if (!this.isStopped) {
	            if (!this.retries) {
	                this.subscribeToRetries();
	            }
	            if (!this.retriesSubscription || this.retriesSubscription.closed) {
	                return _super.prototype.complete.call(this);
	            }
	            this._unsubscribeAndRecycle();
	            this.notifications.next();
	        }
	    };
	    RepeatWhenSubscriber.prototype._unsubscribe = function () {
	        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
	        if (notifications) {
	            notifications.unsubscribe();
	            this.notifications = null;
	        }
	        if (retriesSubscription) {
	            retriesSubscription.unsubscribe();
	            this.retriesSubscription = null;
	        }
	        this.retries = null;
	    };
	    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
	        var _unsubscribe = this._unsubscribe;
	        this._unsubscribe = null;
	        _super.prototype._unsubscribeAndRecycle.call(this);
	        this._unsubscribe = _unsubscribe;
	        return this;
	    };
	    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
	        this.notifications = new Subject();
	        var retries;
	        try {
	            var notifier = this.notifier;
	            retries = notifier(this.notifications);
	        }
	        catch (e) {
	            return _super.prototype.complete.call(this);
	        }
	        this.retries = retries;
	        this.retriesSubscription = subscribeToResult(this, retries);
	    };
	    return RepeatWhenSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function retry(count) {
	    if (count === void 0) {
	        count = -1;
	    }
	    return function (source) { return source.lift(new RetryOperator(count, source)); };
	}
	var RetryOperator = /*@__PURE__*/ (function () {
	    function RetryOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RetryOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
	    };
	    return RetryOperator;
	}());
	var RetrySubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(RetrySubscriber, _super);
	    function RetrySubscriber(destination, count, source) {
	        var _this = _super.call(this, destination) || this;
	        _this.count = count;
	        _this.source = source;
	        return _this;
	    }
	    RetrySubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.error.call(this, err);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            source.subscribe(this._unsubscribeAndRecycle());
	        }
	    };
	    return RetrySubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function retryWhen(notifier) {
	    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
	}
	var RetryWhenOperator = /*@__PURE__*/ (function () {
	    function RetryWhenOperator(notifier, source) {
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RetryWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
	    };
	    return RetryWhenOperator;
	}());
	var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(RetryWhenSubscriber, _super);
	    function RetryWhenSubscriber(destination, notifier, source) {
	        var _this = _super.call(this, destination) || this;
	        _this.notifier = notifier;
	        _this.source = source;
	        return _this;
	    }
	    RetryWhenSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var errors = this.errors;
	            var retries = this.retries;
	            var retriesSubscription = this.retriesSubscription;
	            if (!retries) {
	                errors = new Subject();
	                try {
	                    var notifier = this.notifier;
	                    retries = notifier(errors);
	                }
	                catch (e) {
	                    return _super.prototype.error.call(this, e);
	                }
	                retriesSubscription = subscribeToResult(this, retries);
	            }
	            else {
	                this.errors = null;
	                this.retriesSubscription = null;
	            }
	            this._unsubscribeAndRecycle();
	            this.errors = errors;
	            this.retries = retries;
	            this.retriesSubscription = retriesSubscription;
	            errors.next(err);
	        }
	    };
	    RetryWhenSubscriber.prototype._unsubscribe = function () {
	        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
	        if (errors) {
	            errors.unsubscribe();
	            this.errors = null;
	        }
	        if (retriesSubscription) {
	            retriesSubscription.unsubscribe();
	            this.retriesSubscription = null;
	        }
	        this.retries = null;
	    };
	    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _unsubscribe = this._unsubscribe;
	        this._unsubscribe = null;
	        this._unsubscribeAndRecycle();
	        this._unsubscribe = _unsubscribe;
	        this.source.subscribe(this);
	    };
	    return RetryWhenSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function sample(notifier) {
	    return function (source) { return source.lift(new SampleOperator(notifier)); };
	}
	var SampleOperator = /*@__PURE__*/ (function () {
	    function SampleOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SampleOperator.prototype.call = function (subscriber, source) {
	        var sampleSubscriber = new SampleSubscriber(subscriber);
	        var subscription = source.subscribe(sampleSubscriber);
	        subscription.add(subscribeToResult(sampleSubscriber, this.notifier));
	        return subscription;
	    };
	    return SampleOperator;
	}());
	var SampleSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SampleSubscriber, _super);
	    function SampleSubscriber() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.hasValue = false;
	        return _this;
	    }
	    SampleSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	    };
	    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.value);
	        }
	    };
	    return SampleSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
	function sampleTime(period, scheduler) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
	}
	var SampleTimeOperator = /*@__PURE__*/ (function () {
	    function SampleTimeOperator(period, scheduler) {
	        this.period = period;
	        this.scheduler = scheduler;
	    }
	    SampleTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
	    };
	    return SampleTimeOperator;
	}());
	var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SampleTimeSubscriber, _super);
	    function SampleTimeSubscriber(destination, period, scheduler) {
	        var _this = _super.call(this, destination) || this;
	        _this.period = period;
	        _this.scheduler = scheduler;
	        _this.hasValue = false;
	        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
	        return _this;
	    }
	    SampleTimeSubscriber.prototype._next = function (value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };
	    SampleTimeSubscriber.prototype.notifyNext = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.lastValue);
	        }
	    };
	    return SampleTimeSubscriber;
	}(Subscriber));
	function dispatchNotification(state) {
	    var subscriber = state.subscriber, period = state.period;
	    subscriber.notifyNext();
	    this.schedule(state, period);
	}

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function sequenceEqual(compareTo, comparator) {
	    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
	}
	var SequenceEqualOperator = /*@__PURE__*/ (function () {
	    function SequenceEqualOperator(compareTo, comparator) {
	        this.compareTo = compareTo;
	        this.comparator = comparator;
	    }
	    SequenceEqualOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
	    };
	    return SequenceEqualOperator;
	}());
	var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SequenceEqualSubscriber, _super);
	    function SequenceEqualSubscriber(destination, compareTo, comparator) {
	        var _this = _super.call(this, destination) || this;
	        _this.compareTo = compareTo;
	        _this.comparator = comparator;
	        _this._a = [];
	        _this._b = [];
	        _this._oneComplete = false;
	        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
	        return _this;
	    }
	    SequenceEqualSubscriber.prototype._next = function (value) {
	        if (this._oneComplete && this._b.length === 0) {
	            this.emit(false);
	        }
	        else {
	            this._a.push(value);
	            this.checkValues();
	        }
	    };
	    SequenceEqualSubscriber.prototype._complete = function () {
	        if (this._oneComplete) {
	            this.emit(this._a.length === 0 && this._b.length === 0);
	        }
	        else {
	            this._oneComplete = true;
	        }
	        this.unsubscribe();
	    };
	    SequenceEqualSubscriber.prototype.checkValues = function () {
	        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
	        while (_a.length > 0 && _b.length > 0) {
	            var a = _a.shift();
	            var b = _b.shift();
	            var areEqual = false;
	            try {
	                areEqual = comparator ? comparator(a, b) : a === b;
	            }
	            catch (e) {
	                this.destination.error(e);
	            }
	            if (!areEqual) {
	                this.emit(false);
	            }
	        }
	    };
	    SequenceEqualSubscriber.prototype.emit = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	    };
	    SequenceEqualSubscriber.prototype.nextB = function (value) {
	        if (this._oneComplete && this._a.length === 0) {
	            this.emit(false);
	        }
	        else {
	            this._b.push(value);
	            this.checkValues();
	        }
	    };
	    SequenceEqualSubscriber.prototype.completeB = function () {
	        if (this._oneComplete) {
	            this.emit(this._a.length === 0 && this._b.length === 0);
	        }
	        else {
	            this._oneComplete = true;
	        }
	    };
	    return SequenceEqualSubscriber;
	}(Subscriber));
	var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SequenceEqualCompareToSubscriber, _super);
	    function SequenceEqualCompareToSubscriber(destination, parent) {
	        var _this = _super.call(this, destination) || this;
	        _this.parent = parent;
	        return _this;
	    }
	    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
	        this.parent.nextB(value);
	    };
	    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
	        this.parent.error(err);
	        this.unsubscribe();
	    };
	    SequenceEqualCompareToSubscriber.prototype._complete = function () {
	        this.parent.completeB();
	        this.unsubscribe();
	    };
	    return SequenceEqualCompareToSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
	function shareSubjectFactory() {
	    return new Subject();
	}
	function share() {
	    return function (source) { return refCount()(multicast(shareSubjectFactory)(source)); };
	}

	/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */
	function shareReplay(configOrBufferSize, windowTime, scheduler) {
	    var config;
	    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
	        config = configOrBufferSize;
	    }
	    else {
	        config = {
	            bufferSize: configOrBufferSize,
	            windowTime: windowTime,
	            refCount: false,
	            scheduler: scheduler
	        };
	    }
	    return function (source) { return source.lift(shareReplayOperator(config)); };
	}
	function shareReplayOperator(_a) {
	    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
	    var subject;
	    var refCount = 0;
	    var subscription;
	    var hasError = false;
	    var isComplete = false;
	    return function shareReplayOperation(source) {
	        refCount++;
	        if (!subject || hasError) {
	            hasError = false;
	            subject = new ReplaySubject(bufferSize, windowTime, scheduler);
	            subscription = source.subscribe({
	                next: function (value) { subject.next(value); },
	                error: function (err) {
	                    hasError = true;
	                    subject.error(err);
	                },
	                complete: function () {
	                    isComplete = true;
	                    subject.complete();
	                },
	            });
	        }
	        var innerSub = subject.subscribe(this);
	        this.add(function () {
	            refCount--;
	            innerSub.unsubscribe();
	            if (subscription && !isComplete && useRefCount && refCount === 0) {
	                subscription.unsubscribe();
	                subscription = undefined;
	                subject = undefined;
	            }
	        });
	    };
	}

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */
	function single(predicate) {
	    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
	}
	var SingleOperator = /*@__PURE__*/ (function () {
	    function SingleOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    SingleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
	    };
	    return SingleOperator;
	}());
	var SingleSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SingleSubscriber, _super);
	    function SingleSubscriber(destination, predicate, source) {
	        var _this = _super.call(this, destination) || this;
	        _this.predicate = predicate;
	        _this.source = source;
	        _this.seenValue = false;
	        _this.index = 0;
	        return _this;
	    }
	    SingleSubscriber.prototype.applySingleValue = function (value) {
	        if (this.seenValue) {
	            this.destination.error('Sequence contains more than one element');
	        }
	        else {
	            this.seenValue = true;
	            this.singleValue = value;
	        }
	    };
	    SingleSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this.tryNext(value, index);
	        }
	        else {
	            this.applySingleValue(value);
	        }
	    };
	    SingleSubscriber.prototype.tryNext = function (value, index) {
	        try {
	            if (this.predicate(value, index, this.source)) {
	                this.applySingleValue(value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    SingleSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.index > 0) {
	            destination.next(this.seenValue ? this.singleValue : undefined);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError);
	        }
	    };
	    return SingleSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function skip(count) {
	    return function (source) { return source.lift(new SkipOperator(count)); };
	}
	var SkipOperator = /*@__PURE__*/ (function () {
	    function SkipOperator(total) {
	        this.total = total;
	    }
	    SkipOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipSubscriber(subscriber, this.total));
	    };
	    return SkipOperator;
	}());
	var SkipSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SkipSubscriber, _super);
	    function SkipSubscriber(destination, total) {
	        var _this = _super.call(this, destination) || this;
	        _this.total = total;
	        _this.count = 0;
	        return _this;
	    }
	    SkipSubscriber.prototype._next = function (x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };
	    return SkipSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */
	function skipLast(count) {
	    return function (source) { return source.lift(new SkipLastOperator(count)); };
	}
	var SkipLastOperator = /*@__PURE__*/ (function () {
	    function SkipLastOperator(_skipCount) {
	        this._skipCount = _skipCount;
	        if (this._skipCount < 0) {
	            throw new ArgumentOutOfRangeError;
	        }
	    }
	    SkipLastOperator.prototype.call = function (subscriber, source) {
	        if (this._skipCount === 0) {
	            return source.subscribe(new Subscriber(subscriber));
	        }
	        else {
	            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
	        }
	    };
	    return SkipLastOperator;
	}());
	var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SkipLastSubscriber, _super);
	    function SkipLastSubscriber(destination, _skipCount) {
	        var _this = _super.call(this, destination) || this;
	        _this._skipCount = _skipCount;
	        _this._count = 0;
	        _this._ring = new Array(_skipCount);
	        return _this;
	    }
	    SkipLastSubscriber.prototype._next = function (value) {
	        var skipCount = this._skipCount;
	        var count = this._count++;
	        if (count < skipCount) {
	            this._ring[count] = value;
	        }
	        else {
	            var currentIndex = count % skipCount;
	            var ring = this._ring;
	            var oldValue = ring[currentIndex];
	            ring[currentIndex] = value;
	            this.destination.next(oldValue);
	        }
	    };
	    return SkipLastSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function skipUntil(notifier) {
	    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
	}
	var SkipUntilOperator = /*@__PURE__*/ (function () {
	    function SkipUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SkipUntilOperator.prototype.call = function (destination, source) {
	        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
	    };
	    return SkipUntilOperator;
	}());
	var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SkipUntilSubscriber, _super);
	    function SkipUntilSubscriber(destination, notifier) {
	        var _this = _super.call(this, destination) || this;
	        _this.hasValue = false;
	        var innerSubscriber = new InnerSubscriber(_this, undefined, undefined);
	        _this.add(innerSubscriber);
	        _this.innerSubscription = innerSubscriber;
	        subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
	        return _this;
	    }
	    SkipUntilSubscriber.prototype._next = function (value) {
	        if (this.hasValue) {
	            _super.prototype._next.call(this, value);
	        }
	    };
	    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.hasValue = true;
	        if (this.innerSubscription) {
	            this.innerSubscription.unsubscribe();
	        }
	    };
	    SkipUntilSubscriber.prototype.notifyComplete = function () {
	    };
	    return SkipUntilSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function skipWhile(predicate) {
	    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
	}
	var SkipWhileOperator = /*@__PURE__*/ (function () {
	    function SkipWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    SkipWhileOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
	    };
	    return SkipWhileOperator;
	}());
	var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SkipWhileSubscriber, _super);
	    function SkipWhileSubscriber(destination, predicate) {
	        var _this = _super.call(this, destination) || this;
	        _this.predicate = predicate;
	        _this.skipping = true;
	        _this.index = 0;
	        return _this;
	    }
	    SkipWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (this.skipping) {
	            this.tryCallPredicate(value);
	        }
	        if (!this.skipping) {
	            destination.next(value);
	        }
	    };
	    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
	        try {
	            var result = this.predicate(value, this.index++);
	            this.skipping = Boolean(result);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    return SkipWhileSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
	function startWith() {
	    var array = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        array[_i] = arguments[_i];
	    }
	    return function (source) {
	        var scheduler = array[array.length - 1];
	        if (isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len === 1 && !scheduler) {
	            return concat(scalar(array[0]), source);
	        }
	        else if (len > 0) {
	            return concat(fromArray(array, scheduler), source);
	        }
	        else {
	            return concat(empty$1(scheduler), source);
	        }
	    };
	}

	/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
	var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
	    __extends(SubscribeOnObservable, _super);
	    function SubscribeOnObservable(source, delayTime, scheduler) {
	        if (delayTime === void 0) {
	            delayTime = 0;
	        }
	        if (scheduler === void 0) {
	            scheduler = asap;
	        }
	        var _this = _super.call(this) || this;
	        _this.source = source;
	        _this.delayTime = delayTime;
	        _this.scheduler = scheduler;
	        if (!isNumeric(delayTime) || delayTime < 0) {
	            _this.delayTime = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            _this.scheduler = asap;
	        }
	        return _this;
	    }
	    SubscribeOnObservable.create = function (source, delay, scheduler) {
	        if (delay === void 0) {
	            delay = 0;
	        }
	        if (scheduler === void 0) {
	            scheduler = asap;
	        }
	        return new SubscribeOnObservable(source, delay, scheduler);
	    };
	    SubscribeOnObservable.dispatch = function (arg) {
	        var source = arg.source, subscriber = arg.subscriber;
	        return this.add(source.subscribe(subscriber));
	    };
	    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
	        var delay = this.delayTime;
	        var source = this.source;
	        var scheduler = this.scheduler;
	        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	            source: source, subscriber: subscriber
	        });
	    };
	    return SubscribeOnObservable;
	}(Observable));

	/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */
	function subscribeOn(scheduler, delay) {
	    if (delay === void 0) {
	        delay = 0;
	    }
	    return function subscribeOnOperatorFunction(source) {
	        return source.lift(new SubscribeOnOperator(scheduler, delay));
	    };
	}
	var SubscribeOnOperator = /*@__PURE__*/ (function () {
	    function SubscribeOnOperator(scheduler, delay) {
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    SubscribeOnOperator.prototype.call = function (subscriber, source) {
	        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
	    };
	    return SubscribeOnOperator;
	}());

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
	function switchMap(project, resultSelector) {
	    if (typeof resultSelector === 'function') {
	        return function (source) { return source.pipe(switchMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
	    }
	    return function (source) { return source.lift(new SwitchMapOperator(project)); };
	}
	var SwitchMapOperator = /*@__PURE__*/ (function () {
	    function SwitchMapOperator(project) {
	        this.project = project;
	    }
	    SwitchMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
	    };
	    return SwitchMapOperator;
	}());
	var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(SwitchMapSubscriber, _super);
	    function SwitchMapSubscriber(destination, project) {
	        var _this = _super.call(this, destination) || this;
	        _this.project = project;
	        _this.index = 0;
	        return _this;
	    }
	    SwitchMapSubscriber.prototype._next = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (error) {
	            this.destination.error(error);
	            return;
	        }
	        this._innerSub(result, value, index);
	    };
	    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	        var destination = this.destination;
	        destination.add(innerSubscriber);
	        this.innerSubscription = subscribeToResult(this, result, value, index, innerSubscriber);
	    };
	    SwitchMapSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.closed) {
	            _super.prototype._complete.call(this);
	        }
	        this.unsubscribe();
	    };
	    SwitchMapSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var destination = this.destination;
	        destination.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    return SwitchMapSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */
	function switchAll() {
	    return switchMap(identity);
	}

	/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */
	function switchMapTo(innerObservable, resultSelector) {
	    return resultSelector ? switchMap(function () { return innerObservable; }, resultSelector) : switchMap(function () { return innerObservable; });
	}

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function takeUntil(notifier) {
	    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
	}
	var TakeUntilOperator = /*@__PURE__*/ (function () {
	    function TakeUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    TakeUntilOperator.prototype.call = function (subscriber, source) {
	        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
	        var notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
	        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
	            takeUntilSubscriber.add(notifierSubscription);
	            return source.subscribe(takeUntilSubscriber);
	        }
	        return takeUntilSubscriber;
	    };
	    return TakeUntilOperator;
	}());
	var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(TakeUntilSubscriber, _super);
	    function TakeUntilSubscriber(destination) {
	        var _this = _super.call(this, destination) || this;
	        _this.seenValue = false;
	        return _this;
	    }
	    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.seenValue = true;
	        this.complete();
	    };
	    TakeUntilSubscriber.prototype.notifyComplete = function () {
	    };
	    return TakeUntilSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
	function takeWhile(predicate, inclusive) {
	    if (inclusive === void 0) {
	        inclusive = false;
	    }
	    return function (source) {
	        return source.lift(new TakeWhileOperator(predicate, inclusive));
	    };
	}
	var TakeWhileOperator = /*@__PURE__*/ (function () {
	    function TakeWhileOperator(predicate, inclusive) {
	        this.predicate = predicate;
	        this.inclusive = inclusive;
	    }
	    TakeWhileOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
	    };
	    return TakeWhileOperator;
	}());
	var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(TakeWhileSubscriber, _super);
	    function TakeWhileSubscriber(destination, predicate, inclusive) {
	        var _this = _super.call(this, destination) || this;
	        _this.predicate = predicate;
	        _this.inclusive = inclusive;
	        _this.index = 0;
	        return _this;
	    }
	    TakeWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        var result;
	        try {
	            result = this.predicate(value, this.index++);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this.nextOrComplete(value, result);
	    };
	    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
	        var destination = this.destination;
	        if (Boolean(predicateResult)) {
	            destination.next(value);
	        }
	        else {
	            if (this.inclusive) {
	                destination.next(value);
	            }
	            destination.complete();
	        }
	    };
	    return TakeWhileSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	var defaultThrottleConfig = {
	    leading: true,
	    trailing: false
	};
	function throttle(durationSelector, config) {
	    if (config === void 0) {
	        config = defaultThrottleConfig;
	    }
	    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
	}
	var ThrottleOperator = /*@__PURE__*/ (function () {
	    function ThrottleOperator(durationSelector, leading, trailing) {
	        this.durationSelector = durationSelector;
	        this.leading = leading;
	        this.trailing = trailing;
	    }
	    ThrottleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
	    };
	    return ThrottleOperator;
	}());
	var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ThrottleSubscriber, _super);
	    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
	        var _this = _super.call(this, destination) || this;
	        _this.destination = destination;
	        _this.durationSelector = durationSelector;
	        _this._leading = _leading;
	        _this._trailing = _trailing;
	        _this._hasValue = false;
	        return _this;
	    }
	    ThrottleSubscriber.prototype._next = function (value) {
	        this._hasValue = true;
	        this._sendValue = value;
	        if (!this._throttled) {
	            if (this._leading) {
	                this.send();
	            }
	            else {
	                this.throttle(value);
	            }
	        }
	    };
	    ThrottleSubscriber.prototype.send = function () {
	        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
	        if (_hasValue) {
	            this.destination.next(_sendValue);
	            this.throttle(_sendValue);
	        }
	        this._hasValue = false;
	        this._sendValue = null;
	    };
	    ThrottleSubscriber.prototype.throttle = function (value) {
	        var duration = this.tryDurationSelector(value);
	        if (!!duration) {
	            this.add(this._throttled = subscribeToResult(this, duration));
	        }
	    };
	    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
	        try {
	            return this.durationSelector(value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return null;
	        }
	    };
	    ThrottleSubscriber.prototype.throttlingDone = function () {
	        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
	        if (_throttled) {
	            _throttled.unsubscribe();
	        }
	        this._throttled = null;
	        if (_trailing) {
	            this.send();
	        }
	    };
	    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.throttlingDone();
	    };
	    ThrottleSubscriber.prototype.notifyComplete = function () {
	        this.throttlingDone();
	    };
	    return ThrottleSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
	function throttleTime(duration, scheduler, config) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    if (config === void 0) {
	        config = defaultThrottleConfig;
	    }
	    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
	}
	var ThrottleTimeOperator = /*@__PURE__*/ (function () {
	    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	        this.leading = leading;
	        this.trailing = trailing;
	    }
	    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
	    };
	    return ThrottleTimeOperator;
	}());
	var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(ThrottleTimeSubscriber, _super);
	    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
	        var _this = _super.call(this, destination) || this;
	        _this.duration = duration;
	        _this.scheduler = scheduler;
	        _this.leading = leading;
	        _this.trailing = trailing;
	        _this._hasTrailingValue = false;
	        _this._trailingValue = null;
	        return _this;
	    }
	    ThrottleTimeSubscriber.prototype._next = function (value) {
	        if (this.throttled) {
	            if (this.trailing) {
	                this._trailingValue = value;
	                this._hasTrailingValue = true;
	            }
	        }
	        else {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext$3, this.duration, { subscriber: this }));
	            if (this.leading) {
	                this.destination.next(value);
	            }
	        }
	    };
	    ThrottleTimeSubscriber.prototype._complete = function () {
	        if (this._hasTrailingValue) {
	            this.destination.next(this._trailingValue);
	            this.destination.complete();
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
	        var throttled = this.throttled;
	        if (throttled) {
	            if (this.trailing && this._hasTrailingValue) {
	                this.destination.next(this._trailingValue);
	                this._trailingValue = null;
	                this._hasTrailingValue = false;
	            }
	            throttled.unsubscribe();
	            this.remove(throttled);
	            this.throttled = null;
	        }
	    };
	    return ThrottleTimeSubscriber;
	}(Subscriber));
	function dispatchNext$3(arg) {
	    var subscriber = arg.subscriber;
	    subscriber.clearThrottle();
	}

	/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */
	function timeInterval(scheduler) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    return function (source) {
	        return defer(function () {
	            return source.pipe(scan(function (_a, value) {
	                var current = _a.current;
	                return ({ value: value, current: scheduler.now(), last: current });
	            }, { current: scheduler.now(), value: undefined, last: undefined }), map(function (_a) {
	                var current = _a.current, last = _a.last, value = _a.value;
	                return new TimeInterval(value, current - last);
	            }));
	        });
	    };
	}
	var TimeInterval = /*@__PURE__*/ (function () {
	    function TimeInterval(value, interval) {
	        this.value = value;
	        this.interval = interval;
	    }
	    return TimeInterval;
	}());

	/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function timeoutWith(due, withObservable, scheduler) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    return function (source) {
	        var absoluteTimeout = isDate(due);
	        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
	    };
	}
	var TimeoutWithOperator = /*@__PURE__*/ (function () {
	    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	    }
	    TimeoutWithOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
	    };
	    return TimeoutWithOperator;
	}());
	var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(TimeoutWithSubscriber, _super);
	    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
	        var _this = _super.call(this, destination) || this;
	        _this.absoluteTimeout = absoluteTimeout;
	        _this.waitFor = waitFor;
	        _this.withObservable = withObservable;
	        _this.scheduler = scheduler;
	        _this.action = null;
	        _this.scheduleTimeout();
	        return _this;
	    }
	    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
	        var withObservable = subscriber.withObservable;
	        subscriber._unsubscribeAndRecycle();
	        subscriber.add(subscribeToResult(subscriber, withObservable));
	    };
	    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
	        var action = this.action;
	        if (action) {
	            this.action = action.schedule(this, this.waitFor);
	        }
	        else {
	            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
	        }
	    };
	    TimeoutWithSubscriber.prototype._next = function (value) {
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	        _super.prototype._next.call(this, value);
	    };
	    TimeoutWithSubscriber.prototype._unsubscribe = function () {
	        this.action = null;
	        this.scheduler = null;
	        this.withObservable = null;
	    };
	    return TimeoutWithSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
	function timeout(due, scheduler) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    return timeoutWith(due, throwError(new TimeoutError()), scheduler);
	}

	/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */
	function timestamp(scheduler) {
	    if (scheduler === void 0) {
	        scheduler = async;
	    }
	    return map(function (value) { return new Timestamp(value, scheduler.now()); });
	}
	var Timestamp = /*@__PURE__*/ (function () {
	    function Timestamp(value, timestamp) {
	        this.value = value;
	        this.timestamp = timestamp;
	    }
	    return Timestamp;
	}());

	/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
	function toArrayReducer(arr, item, index) {
	    if (index === 0) {
	        return [item];
	    }
	    arr.push(item);
	    return arr;
	}
	function toArray() {
	    return reduce(toArrayReducer, []);
	}

	/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function window$1(windowBoundaries) {
	    return function windowOperatorFunction(source) {
	        return source.lift(new WindowOperator(windowBoundaries));
	    };
	}
	var WindowOperator = /*@__PURE__*/ (function () {
	    function WindowOperator(windowBoundaries) {
	        this.windowBoundaries = windowBoundaries;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        var windowSubscriber = new WindowSubscriber(subscriber);
	        var sourceSubscription = source.subscribe(windowSubscriber);
	        if (!sourceSubscription.closed) {
	            windowSubscriber.add(subscribeToResult(windowSubscriber, this.windowBoundaries));
	        }
	        return sourceSubscription;
	    };
	    return WindowOperator;
	}());
	var WindowSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(WindowSubscriber, _super);
	    function WindowSubscriber(destination) {
	        var _this = _super.call(this, destination) || this;
	        _this.window = new Subject();
	        destination.next(_this.window);
	        return _this;
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow();
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this._complete();
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	    };
	    WindowSubscriber.prototype._unsubscribe = function () {
	        this.window = null;
	    };
	    WindowSubscriber.prototype.openWindow = function () {
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var destination = this.destination;
	        var newWindow = this.window = new Subject();
	        destination.next(newWindow);
	    };
	    return WindowSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */
	function windowCount(windowSize, startWindowEvery) {
	    if (startWindowEvery === void 0) {
	        startWindowEvery = 0;
	    }
	    return function windowCountOperatorFunction(source) {
	        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
	    };
	}
	var WindowCountOperator = /*@__PURE__*/ (function () {
	    function WindowCountOperator(windowSize, startWindowEvery) {
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	    }
	    WindowCountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
	    };
	    return WindowCountOperator;
	}());
	var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(WindowCountSubscriber, _super);
	    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	        var _this = _super.call(this, destination) || this;
	        _this.destination = destination;
	        _this.windowSize = windowSize;
	        _this.startWindowEvery = startWindowEvery;
	        _this.windows = [new Subject()];
	        _this.count = 0;
	        destination.next(_this.windows[0]);
	        return _this;
	    }
	    WindowCountSubscriber.prototype._next = function (value) {
	        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
	        var destination = this.destination;
	        var windowSize = this.windowSize;
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len && !this.closed; i++) {
	            windows[i].next(value);
	        }
	        var c = this.count - windowSize + 1;
	        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
	            windows.shift().complete();
	        }
	        if (++this.count % startWindowEvery === 0 && !this.closed) {
	            var window_1 = new Subject();
	            windows.push(window_1);
	            destination.next(window_1);
	        }
	    };
	    WindowCountSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        if (windows) {
	            while (windows.length > 0 && !this.closed) {
	                windows.shift().error(err);
	            }
	        }
	        this.destination.error(err);
	    };
	    WindowCountSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        if (windows) {
	            while (windows.length > 0 && !this.closed) {
	                windows.shift().complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowCountSubscriber.prototype._unsubscribe = function () {
	        this.count = 0;
	        this.windows = null;
	    };
	    return WindowCountSubscriber;
	}(Subscriber));

	/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
	function windowTime(windowTimeSpan) {
	    var scheduler = async;
	    var windowCreationInterval = null;
	    var maxWindowSize = Number.POSITIVE_INFINITY;
	    if (isScheduler(arguments[3])) {
	        scheduler = arguments[3];
	    }
	    if (isScheduler(arguments[2])) {
	        scheduler = arguments[2];
	    }
	    else if (isNumeric(arguments[2])) {
	        maxWindowSize = arguments[2];
	    }
	    if (isScheduler(arguments[1])) {
	        scheduler = arguments[1];
	    }
	    else if (isNumeric(arguments[1])) {
	        windowCreationInterval = arguments[1];
	    }
	    return function windowTimeOperatorFunction(source) {
	        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
	    };
	}
	var WindowTimeOperator = /*@__PURE__*/ (function () {
	    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.maxWindowSize = maxWindowSize;
	        this.scheduler = scheduler;
	    }
	    WindowTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
	    };
	    return WindowTimeOperator;
	}());
	var CountedSubject = /*@__PURE__*/ (function (_super) {
	    __extends(CountedSubject, _super);
	    function CountedSubject() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._numberOfNextedValues = 0;
	        return _this;
	    }
	    CountedSubject.prototype.next = function (value) {
	        this._numberOfNextedValues++;
	        _super.prototype.next.call(this, value);
	    };
	    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
	        get: function () {
	            return this._numberOfNextedValues;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CountedSubject;
	}(Subject));
	var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(WindowTimeSubscriber, _super);
	    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
	        var _this = _super.call(this, destination) || this;
	        _this.destination = destination;
	        _this.windowTimeSpan = windowTimeSpan;
	        _this.windowCreationInterval = windowCreationInterval;
	        _this.maxWindowSize = maxWindowSize;
	        _this.scheduler = scheduler;
	        _this.windows = [];
	        var window = _this.openWindow();
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            var closeState = { subscriber: _this, window: window, context: null };
	            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
	            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
	            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
	        }
	        else {
	            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
	            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
	        }
	        return _this;
	    }
	    WindowTimeSubscriber.prototype._next = function (value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            var window_1 = windows[i];
	            if (!window_1.closed) {
	                window_1.next(value);
	                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
	                    this.closeWindow(window_1);
	                }
	            }
	        }
	    };
	    WindowTimeSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	    WindowTimeSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            var window_2 = windows.shift();
	            if (!window_2.closed) {
	                window_2.complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowTimeSubscriber.prototype.openWindow = function () {
	        var window = new CountedSubject();
	        this.windows.push(window);
	        var destination = this.destination;
	        destination.next(window);
	        return window;
	    };
	    WindowTimeSubscriber.prototype.closeWindow = function (window) {
	        window.complete();
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	    };
	    return WindowTimeSubscriber;
	}(Subscriber));
	function dispatchWindowTimeSpanOnly(state) {
	    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
	    if (window) {
	        subscriber.closeWindow(window);
	    }
	    state.window = subscriber.openWindow();
	    this.schedule(state, windowTimeSpan);
	}
	function dispatchWindowCreation(state) {
	    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
	    var window = subscriber.openWindow();
	    var action = this;
	    var context = { action: action, subscription: null };
	    var timeSpanState = { subscriber: subscriber, window: window, context: context };
	    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
	    action.add(context.subscription);
	    action.schedule(state, windowCreationInterval);
	}
	function dispatchWindowClose(state) {
	    var subscriber = state.subscriber, window = state.window, context = state.context;
	    if (context && context.action && context.subscription) {
	        context.action.remove(context.subscription);
	    }
	    subscriber.closeWindow(window);
	}

	/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function windowToggle(openings, closingSelector) {
	    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
	}
	var WindowToggleOperator = /*@__PURE__*/ (function () {
	    function WindowToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    WindowToggleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return WindowToggleOperator;
	}());
	var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(WindowToggleSubscriber, _super);
	    function WindowToggleSubscriber(destination, openings, closingSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.openings = openings;
	        _this.closingSelector = closingSelector;
	        _this.contexts = [];
	        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
	        return _this;
	    }
	    WindowToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        if (contexts) {
	            var len = contexts.length;
	            for (var i = 0; i < len; i++) {
	                contexts[i].window.next(value);
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context_1 = contexts[index];
	                context_1.window.error(err);
	                context_1.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._error.call(this, err);
	    };
	    WindowToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context_2 = contexts[index];
	                context_2.window.complete();
	                context_2.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    WindowToggleSubscriber.prototype._unsubscribe = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context_3 = contexts[index];
	                context_3.window.unsubscribe();
	                context_3.subscription.unsubscribe();
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (outerValue === this.openings) {
	            var closingNotifier = void 0;
	            try {
	                var closingSelector = this.closingSelector;
	                closingNotifier = closingSelector(innerValue);
	            }
	            catch (e) {
	                return this.error(e);
	            }
	            var window_1 = new Subject();
	            var subscription = new Subscription();
	            var context_4 = { window: window_1, subscription: subscription };
	            this.contexts.push(context_4);
	            var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
	            if (innerSubscription.closed) {
	                this.closeWindow(this.contexts.length - 1);
	            }
	            else {
	                innerSubscription.context = context_4;
	                subscription.add(innerSubscription);
	            }
	            this.destination.next(window_1);
	        }
	        else {
	            this.closeWindow(this.contexts.indexOf(outerValue));
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyError = function (err) {
	        this.error(err);
	    };
	    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
	        if (inner !== this.openSubscription) {
	            this.closeWindow(this.contexts.indexOf(inner.context));
	        }
	    };
	    WindowToggleSubscriber.prototype.closeWindow = function (index) {
	        if (index === -1) {
	            return;
	        }
	        var contexts = this.contexts;
	        var context = contexts[index];
	        var window = context.window, subscription = context.subscription;
	        contexts.splice(index, 1);
	        window.complete();
	        subscription.unsubscribe();
	    };
	    return WindowToggleSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function windowWhen(closingSelector) {
	    return function windowWhenOperatorFunction(source) {
	        return source.lift(new WindowOperator$1(closingSelector));
	    };
	}
	var WindowOperator$1 = /*@__PURE__*/ (function () {
	    function WindowOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowSubscriber$1(subscriber, this.closingSelector));
	    };
	    return WindowOperator;
	}());
	var WindowSubscriber$1 = /*@__PURE__*/ (function (_super) {
	    __extends(WindowSubscriber, _super);
	    function WindowSubscriber(destination, closingSelector) {
	        var _this = _super.call(this, destination) || this;
	        _this.destination = destination;
	        _this.closingSelector = closingSelector;
	        _this.openWindow();
	        return _this;
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
	        if (this.closingNotification) {
	            this.closingNotification.unsubscribe();
	        }
	    };
	    WindowSubscriber.prototype.openWindow = function (innerSub) {
	        if (innerSub === void 0) {
	            innerSub = null;
	        }
	        if (innerSub) {
	            this.remove(innerSub);
	            innerSub.unsubscribe();
	        }
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var window = this.window = new Subject();
	        this.destination.next(window);
	        var closingNotifier;
	        try {
	            var closingSelector = this.closingSelector;
	            closingNotifier = closingSelector();
	        }
	        catch (e) {
	            this.destination.error(e);
	            this.window.error(e);
	            return;
	        }
	        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
	    };
	    return WindowSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
	function withLatestFrom() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    return function (source) {
	        var project;
	        if (typeof args[args.length - 1] === 'function') {
	            project = args.pop();
	        }
	        var observables = args;
	        return source.lift(new WithLatestFromOperator(observables, project));
	    };
	}
	var WithLatestFromOperator = /*@__PURE__*/ (function () {
	    function WithLatestFromOperator(observables, project) {
	        this.observables = observables;
	        this.project = project;
	    }
	    WithLatestFromOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
	    };
	    return WithLatestFromOperator;
	}());
	var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
	    __extends(WithLatestFromSubscriber, _super);
	    function WithLatestFromSubscriber(destination, observables, project) {
	        var _this = _super.call(this, destination) || this;
	        _this.observables = observables;
	        _this.project = project;
	        _this.toRespond = [];
	        var len = observables.length;
	        _this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            _this.toRespond.push(i);
	        }
	        for (var i = 0; i < len; i++) {
	            var observable = observables[i];
	            _this.add(subscribeToResult(_this, observable, observable, i));
	        }
	        return _this;
	    }
	    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        var toRespond = this.toRespond;
	        if (toRespond.length > 0) {
	            var found = toRespond.indexOf(outerIndex);
	            if (found !== -1) {
	                toRespond.splice(found, 1);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype.notifyComplete = function () {
	    };
	    WithLatestFromSubscriber.prototype._next = function (value) {
	        if (this.toRespond.length === 0) {
	            var args = [value].concat(this.values);
	            if (this.project) {
	                this._tryProject(args);
	            }
	            else {
	                this.destination.next(args);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return WithLatestFromSubscriber;
	}(OuterSubscriber));

	/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
	function zip$1() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i] = arguments[_i];
	    }
	    return function zipOperatorFunction(source) {
	        return source.lift.call(zip.apply(void 0, [source].concat(observables)));
	    };
	}

	/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
	function zipAll(project) {
	    return function (source) { return source.lift(new ZipOperator(project)); };
	}

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	var operators = /*#__PURE__*/Object.freeze({
		audit: audit,
		auditTime: auditTime,
		buffer: buffer,
		bufferCount: bufferCount,
		bufferTime: bufferTime,
		bufferToggle: bufferToggle,
		bufferWhen: bufferWhen,
		catchError: catchError,
		combineAll: combineAll,
		combineLatest: combineLatest$1,
		concat: concat$1,
		concatAll: concatAll,
		concatMap: concatMap,
		concatMapTo: concatMapTo,
		count: count,
		debounce: debounce,
		debounceTime: debounceTime,
		defaultIfEmpty: defaultIfEmpty,
		delay: delay,
		delayWhen: delayWhen,
		dematerialize: dematerialize,
		distinct: distinct,
		distinctUntilChanged: distinctUntilChanged,
		distinctUntilKeyChanged: distinctUntilKeyChanged,
		elementAt: elementAt,
		endWith: endWith,
		every: every,
		exhaust: exhaust,
		exhaustMap: exhaustMap,
		expand: expand,
		filter: filter,
		finalize: finalize,
		find: find,
		findIndex: findIndex,
		first: first,
		groupBy: groupBy,
		ignoreElements: ignoreElements,
		isEmpty: isEmpty,
		last: last,
		map: map,
		mapTo: mapTo,
		materialize: materialize,
		max: max,
		merge: merge$1,
		mergeAll: mergeAll,
		mergeMap: mergeMap,
		flatMap: mergeMap,
		mergeMapTo: mergeMapTo,
		mergeScan: mergeScan,
		min: min,
		multicast: multicast,
		observeOn: observeOn,
		onErrorResumeNext: onErrorResumeNext$1,
		pairwise: pairwise,
		partition: partition,
		pluck: pluck,
		publish: publish,
		publishBehavior: publishBehavior,
		publishLast: publishLast,
		publishReplay: publishReplay,
		race: race$1,
		reduce: reduce,
		repeat: repeat,
		repeatWhen: repeatWhen,
		retry: retry,
		retryWhen: retryWhen,
		refCount: refCount,
		sample: sample,
		sampleTime: sampleTime,
		scan: scan,
		sequenceEqual: sequenceEqual,
		share: share,
		shareReplay: shareReplay,
		single: single,
		skip: skip,
		skipLast: skipLast,
		skipUntil: skipUntil,
		skipWhile: skipWhile,
		startWith: startWith,
		subscribeOn: subscribeOn,
		switchAll: switchAll,
		switchMap: switchMap,
		switchMapTo: switchMapTo,
		take: take,
		takeLast: takeLast,
		takeUntil: takeUntil,
		takeWhile: takeWhile,
		tap: tap,
		throttle: throttle,
		throttleTime: throttleTime,
		throwIfEmpty: throwIfEmpty,
		timeInterval: timeInterval,
		timeout: timeout,
		timeoutWith: timeoutWith,
		timestamp: timestamp,
		toArray: toArray,
		window: window$1,
		windowCount: windowCount,
		windowTime: windowTime,
		windowToggle: windowToggle,
		windowWhen: windowWhen,
		withLatestFrom: withLatestFrom,
		zip: zip$1,
		zipAll: zipAll
	});

	var ObservableList_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });


	/**
	 * Creates an observable list (or detail) from a promise-callback.
	 *
	 * @deprecated This class will be removed soon in favor of decoupling
	 * this library from rxjs. Use [[Realtime]] for realtime connection and
	 * rxjs `defer()` or `from()` to composite an observable on your own.
	 */
	var ObservableList = /** @class */ (function () {
	    /**
	     * Creates a observable list with optional paging and realtime configuration.
	     *
	     * @param {Promise<IResultBase<TData>>} request List (or detail) from a promise-callback
	     * @param {any} realtime$ Observable realtime object (optional)
	     * @param {IObservableOptions} options The observable configuration
	     */
	    function ObservableList(request, realtime$, options, realtimeFilter) {
	        if (options === void 0) { options = {}; }
	        if (realtimeFilter === void 0) { realtimeFilter = {}; }
	        this.realtimeFilter = realtimeFilter;
	        /**
	         * The inner source for the list observable
	         */
	        this.source = new rxjs_1.Observable();
	        this.seed = { mapping: {}, list: [] };
	        this.pagingDriver = new rxjs_1.Subject();
	        this.specialRealtimeFilter = {
	            source: function (o, val) { return o.source.id === val; },
	            fragmentType: function (o, val) { return !!o[val]; },
	            // the following are not supported or not valid filters
	            orderBy: function (o, val) { return true; },
	            query: function (o, val) { return true; },
	            q: function (o, val) { return true; },
	            pageSize: function (o, val) { return true; },
	            withTotalPages: function (o, val) { return true; },
	            currentPage: function (o, val) { return true; }
	        };
	        this.defaultObservableOptions = {
	            hot: true,
	            realtime: false,
	            pagingStrategy: PagingStrategy.PROGRESSIVE,
	            realtimeAction: RealtimeAction.FULL,
	            pagingDelay: 0
	        };
	        this.options = Object.assign({}, this.defaultObservableOptions, options);
	        // cold / paging
	        this.source = this.compose(request, this.options.pagingStrategy, this.options.pagingDelay);
	        // realtime
	        if (this.options.realtime) {
	            this.source = this.composeRealtime(realtime$);
	        }
	        // hot
	        if (this.options.hot) {
	            this.source = this.composeHot();
	        }
	    }
	    /**
	     * Load more data from this service (next page).
	     */
	    ObservableList.prototype.more = function () {
	        if (this.options.pagingStrategy !== PagingStrategy.PROGRESSIVE) {
	            throw new Error('Only PagingStrategy.PROGRESSIVE does support load more button.');
	        }
	        var paging = this.pagingDriver.paging;
	        var fetching = !paging || paging.fetching;
	        fetching = this.fetchNextPage(fetching, paging);
	        return fetching;
	    };
	    ObservableList.prototype.composeDetail = function () {
	        return this.source.pipe(operators.map(function (list) { return list[0]; }));
	    };
	    /**
	     * Creates a observable with the given paging strategy.
	     *
	     * @param {Promise<IResultBase<TData>>} request List (or detail) from a promise-callback
	     * @param {PagingStrategy} pagingStrategy The paging strategy to use.
	     * @param {number} pagingDelay If all pages are loaded, the paging is delayed by x ms.
	     */
	    ObservableList.prototype.compose = function (request, pagingStrategy, pagingDelay) {
	        if (pagingStrategy === void 0) { pagingStrategy = PagingStrategy.PROGRESSIVE; }
	        if (pagingDelay === void 0) { pagingDelay = 0; }
	        var firstPage$ = rxjs_1.defer(function () { return rxjs_1.from(request()); });
	        return pagingStrategy === PagingStrategy.PROGRESSIVE
	            ? this.composeProgressive(firstPage$)
	            : this.composeAllOrNone(firstPage$, pagingStrategy, pagingDelay);
	    };
	    ObservableList.prototype.composeRealtime = function (realtime$, action) {
	        var _this = this;
	        if (action === void 0) { action = RealtimeAction.FULL; }
	        if (!realtime$) {
	            // tslint:disable-next-line:max-line-length
	            throw new Error('Cannot compose realtime without setting realtime observable in service constructor.');
	        }
	        realtime$ = realtime$.pipe(operators.filter(function (result) { return _this.filterAction(result, action); }), operators.filter(function (result) { return _this.filterRealtime(result); }), operators.map(this.mapData));
	        return this.source.pipe(operators.merge(realtime$), operators.scan(this.accumulator, this.seed), operators.map(function (_a) {
	            var list = _a.list;
	            return list;
	        }));
	    };
	    ObservableList.prototype.composeHot = function () {
	        return this.source.pipe(operators.publishReplay(1), operators.refCount());
	    };
	    ObservableList.prototype.fetchNextPage = function (fetching, paging) {
	        if (!fetching && !paging.done) {
	            var isLast = paging.currentPage >= paging.totalPages;
	            this.pagingDriver.next(isLast ? rxjs_1.empty() : paging.next());
	            paging.done = isLast;
	            fetching = paging.fetching = !isLast;
	        }
	        return fetching;
	    };
	    ObservableList.prototype.composeAllOrNone = function (firstPage$, pagingStrategy, pagingDelay) {
	        var _this = this;
	        return firstPage$.pipe(operators.expand(function (_a) {
	            var paging = _a.paging;
	            return _this.shouldUsePaging(paging, pagingStrategy)
	                ? rxjs_1.from(paging.next()).pipe(operators.delay(pagingDelay))
	                : rxjs_1.empty();
	        }), operators.map(this.mapData));
	    };
	    ObservableList.prototype.composeProgressive = function (firstPage$) {
	        var _this = this;
	        return this.pagingDriver.pipe(operators.mergeMap(function (r) { return r; }), operators.merge(firstPage$), operators.tap(function (_a) {
	            var paging = _a.paging;
	            if (paging) {
	                _this.pagingDriver.paging = paging;
	            }
	        }), operators.map(this.mapData));
	    };
	    ObservableList.prototype.shouldUsePaging = function (paging, pagingStrategy) {
	        if (pagingStrategy === PagingStrategy.ALL && !paging.totalPages) {
	            return !!paging.nextPage;
	        }
	        return (paging && pagingStrategy === PagingStrategy.ALL && paging.currentPage < paging.totalPages);
	    };
	    ObservableList.prototype.accumulator = function (acc, rtItemOrList) {
	        var mapping = acc.mapping, list = acc.list;
	        // if deleted, realtime just returns an string-id
	        if (typeof rtItemOrList === 'string') {
	            var index = list.indexOf(mapping[rtItemOrList]);
	            if (index > -1) {
	                list.splice(index, 1);
	                mapping[rtItemOrList] = undefined;
	            }
	            return acc;
	        }
	        var items = Array.isArray(rtItemOrList) ? rtItemOrList : [rtItemOrList];
	        items.forEach(function (item, index) {
	            if (mapping[item.id]) {
	                mapping[item.id] = Object.assign(mapping[item.id], item);
	            }
	            else {
	                mapping[item.id] = item;
	                list.push(item);
	            }
	        });
	        return acc;
	    };
	    ObservableList.prototype.filterAction = function (result, action) {
	        return action === RealtimeAction.FULL || action === result.realtimeAction;
	    };
	    ObservableList.prototype.filterRealtime = function (result) {
	        if (this.options.realtimeFilter) {
	            return this.options.realtimeFilter(result);
	        }
	        else if (result.realtimeAction === RealtimeAction.CREATE) {
	            var data = result.data;
	            var valid = true;
	            // tslint:disable-next-line:forin
	            for (var key in this.realtimeFilter) {
	                var specialFn = this.specialRealtimeFilter[key];
	                valid = specialFn
	                    ? this.specialRealtimeFilter[key](data, this.realtimeFilter[key])
	                    : data[key] === this.realtimeFilter[key];
	                if (!valid) {
	                    break;
	                }
	            }
	            return valid;
	        }
	        return true;
	    };
	    ObservableList.prototype.mapData = function (result) {
	        return result.data;
	    };
	    return ObservableList;
	}());
	exports.ObservableList = ObservableList;
	var RealtimeAction;
	(function (RealtimeAction) {
	    RealtimeAction["UPDATE"] = "UPDATE";
	    RealtimeAction["DELETE"] = "DELETE";
	    RealtimeAction["CREATE"] = "CREATE";
	    RealtimeAction["FULL"] = "FULL";
	})(RealtimeAction = exports.RealtimeAction || (exports.RealtimeAction = {}));
	var PagingStrategy;
	(function (PagingStrategy) {
	    PagingStrategy["ALL"] = "ALL";
	    PagingStrategy["PROGRESSIVE"] = "PROGRESSIVE";
	    PagingStrategy["NONE"] = "NONE";
	})(PagingStrategy = exports.PagingStrategy || (exports.PagingStrategy = {}));

	});

	unwrapExports(ObservableList_1);
	ObservableList_1.ObservableList;
	ObservableList_1.RealtimeAction;
	ObservableList_1.PagingStrategy;

	var Service_1 = createCommonjsModule(function (module, exports) {
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });


	var Service = /** @class */ (function () {
	    function Service(client, realtime) {
	        var _this = this;
	        this.client = client;
	        this.realtime = realtime;
	        this.cache = new Map();
	        var methodsToHide = ['list', 'create', 'update', 'detail', 'delete', 'detail$', 'list$'];
	        var prototype = Object.getPrototypeOf(this);
	        methodsToHide.forEach(function (method) {
	            if (!prototype.hasOwnProperty(method)) {
	                Object.defineProperty(_this, method, { get: function () { return undefined; } });
	            }
	        });
	    }
	    Service.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, url, res, json, data, paging;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { accept: 'application/json' };
	                        url = this.listUrl;
	                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ headers: headers, params: filter }, url))];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        json = _a.sent();
	                        data = this.propertyName ? json[this.propertyName] : json;
	                        paging = this.getPaging(json, filter);
	                        return [2 /*return*/, { res: res, data: data, paging: paging }];
	                }
	            });
	        });
	    };
	    Service.prototype.list$ = function (filter, options) {
	        var _this = this;
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        var source = filter.source;
	        return new ObservableList_1.ObservableList(function () { return _this.list(filter); }, this.getRealtime(source), options, filter).source;
	    };
	    Service.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, url, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { accept: 'application/json' };
	                        url = this.getDetailUrl(entityOrId);
	                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ headers: headers }, url))];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    Service.prototype.detail$ = function (entityOrId, options) {
	        var _this = this;
	        if (options === void 0) { options = { pagingStrategy: ObservableList_1.PagingStrategy.NONE }; }
	        var obsList$ = new ObservableList_1.ObservableList(function () { return _this.detail(entityOrId); }, this.getRealtime(entityOrId), options);
	        return obsList$.composeDetail().source;
	    };
	    Service.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.listUrl;
	                        method = 'POST';
	                        body = JSON.stringify(this.onBeforeCreate(entity));
	                        headers = { 'content-type': 'application/json', accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ method: method, body: body, headers: headers }, url))];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    Service.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.getDetailUrl(entity);
	                        method = 'PUT';
	                        body = JSON.stringify(this.onBeforeUpdate(entity));
	                        headers = { 'content-type': 'application/json', accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ method: method, body: body, headers: headers }, url))];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    Service.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var method, url, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'DELETE';
	                        url = this.getDetailUrl(entityOrId);
	                        return [4 /*yield*/, this.fetch(url, this.changeFetchOptions({ method: method }, url))];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    Service.prototype.onBeforeCreate = function (obj) {
	        delete obj.id;
	        return obj;
	    };
	    Service.prototype.onBeforeUpdate = function (objWithId) {
	        return objWithId;
	    };
	    Service.prototype.changeFetchOptions = function (options, url) {
	        return options;
	    };
	    Service.prototype.getUrl = function (url) {
	        if (url === void 0) { url = ''; }
	        var baseUrl = this.baseUrl.replace(/\/+$/, '');
	        var partialUrl = url.replace(/^\/+/, '');
	        return baseUrl + "/" + partialUrl;
	    };
	    Service.prototype.getDetailUrl = function (entityOrId) {
	        var id;
	        if (typeof entityOrId === 'object' && entityOrId.id) {
	            id = entityOrId.id;
	        }
	        else {
	            id = entityOrId;
	        }
	        return this.listUrl + "/" + id;
	    };
	    Service.prototype.fetch = function (url, init) {
	        return __awaiter(this, void 0, void 0, function () {
	            var fullUrl, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        fullUrl = this.getUrl(url);
	                        return [4 /*yield*/, this.client.fetch(fullUrl, init)];
	                    case 1:
	                        res = _a.sent();
	                        if (!(res.status >= 400)) return [3 /*break*/, 10];
	                        data = null;
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 4, , 9]);
	                        return [4 /*yield*/, res.json()];
	                    case 3:
	                        data = _a.sent();
	                        return [3 /*break*/, 9];
	                    case 4:
	                        _a.sent();
	                        _a.label = 5;
	                    case 5:
	                        _a.trys.push([5, 7, , 8]);
	                        return [4 /*yield*/, res.text()];
	                    case 6:
	                        data = _a.sent();
	                        return [3 /*break*/, 8];
	                    case 7:
	                        _a.sent();
	                        return [3 /*break*/, 8];
	                    case 8: return [3 /*break*/, 9];
	                    case 9: throw ({ res: res, data: data });
	                    case 10: return [2 /*return*/, res];
	                }
	            });
	        });
	    };
	    Service.prototype.mimeType = function (type) {
	        return "application/vnd.com.nsn.cumulocity." + type + "+json";
	    };
	    Service.prototype.getIdString = function (reference) {
	        var id;
	        if (typeof reference === 'object') {
	            id = reference.id;
	        }
	        else {
	            id = reference;
	        }
	        return String(id);
	    };
	    Service.prototype.getChannel = function (entityOrId) {
	        return entityOrId ? this.channel.replace('*', this.getIdString(entityOrId)) : this.channel;
	    };
	    Service.prototype.getRealtime = function (entityOrId) {
	        if (this.realtime) {
	            return this.realtime.observable(this.getChannel(entityOrId));
	        }
	    };
	    Service.prototype.getPaging = function (json, filter) {
	        if (json.statistics) {
	            var statistics = __assign({}, json.statistics, { nextPage: this.getCurrentPageFromLink(json.next), prevPage: this.getCurrentPageFromLink(json.prev) });
	            return new Paging_1.Paging(this, statistics, filter);
	        }
	        return null;
	    };
	    Service.prototype.getCurrentPageFromLink = function (link) {
	        if (link === void 0) { link = ''; }
	        var matches = link.match(/currentPage=(-{0,1}\d+)/);
	        return matches && parseInt(matches[1], 10);
	    };
	    return Service;
	}());
	exports.Service = Service;

	});

	unwrapExports(Service_1);
	Service_1.Service;

	var FetchClient_1 = createCommonjsModule(function (module, exports) {
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var cross_fetch_1 = __importDefault(browserPonyfill);
	var auths = new WeakMap(); // tslint:disable-line
	var FetchClient = /** @class */ (function () {
	    function FetchClient(authOrBaseUrl, baseUrl) {
	        this.baseUrl = baseUrl;
	        this.tenant = '';
	        this.defaultHeaders = {};
	        if (typeof authOrBaseUrl === 'string') {
	            baseUrl = authOrBaseUrl;
	        }
	        else {
	            this.setAuth(authOrBaseUrl);
	        }
	        this.baseUrl = this.resolveServerUrl(baseUrl);
	    }
	    FetchClient.prototype.setAuth = function (auth) {
	        auths.set(this, auth);
	    };
	    FetchClient.prototype.fetch = function (url, init) {
	        return __awaiter(this, void 0, void 0, function () {
	            var fetchFn, fullUrl, options;
	            return __generator(this, function (_a) {
	                fetchFn = cross_fetch_1.default;
	                try {
	                    fetchFn = window.fetch || fetchFn;
	                }
	                catch (e) { /* do nothing */ }
	                fullUrl = this.getUrl(url, init);
	                options = this.getFetchOptions(init);
	                return [2 /*return*/, fetchFn(fullUrl, options)];
	            });
	        });
	    };
	    FetchClient.prototype.getUrl = function (url, options) {
	        if (url === void 0) { url = ''; }
	        var params = options && options.params;
	        var paramPart = '';
	        if (params && Object.keys(params).length) {
	            paramPart = Object.keys(params)
	                .map(function (k) {
	                var vals = params[k];
	                var encodedKey = encodeURIComponent(k);
	                if (!Array.isArray(vals)) {
	                    vals = [vals];
	                }
	                return vals.map(function (v) { return encodedKey + "=" + encodeURIComponent(v); }).join('&');
	            })
	                .join('&');
	            paramPart = "?" + paramPart;
	        }
	        var baseUrl = this.baseUrl.replace(/\/+$/, '').replace(/^\/+/, '');
	        var partialUrl = url.replace(/\/+$/, '').replace(/^\/+/, '');
	        return baseUrl + "/" + partialUrl + paramPart;
	    };
	    FetchClient.prototype.getFetchOptions = function (options) {
	        if (options === void 0) { options = {}; }
	        var auth = auths.get(this);
	        options.headers = Object.assign({}, this.defaultHeaders, options.headers, { UseXBasic: true });
	        delete options.params;
	        options = auth ? auth.getFetchOptions(options) : options;
	        return options;
	    };
	    FetchClient.prototype.getCometdHandshake = function (config) {
	        if (config === void 0) { config = {}; }
	        var auth = auths.get(this);
	        return auth ? auth.getCometdHandshake(config) : config;
	    };
	    FetchClient.prototype.resolveServerUrl = function (baseUrl) {
	        if (baseUrl === void 0) { baseUrl = ''; }
	        if (baseUrl && baseUrl.startsWith('http')) {
	            return baseUrl.replace(/\/+$/, '');
	        }
	        try {
	            var location_1 = window.location;
	            return location_1.protocol + "//" + location_1.host + "/" + baseUrl.replace(/\/+$/, '');
	        }
	        catch (ex) {
	            throw Error('Your environment does not support relative URLs. Please provide a base URL.');
	        }
	    };
	    return FetchClient;
	}());
	exports.FetchClient = FetchClient;

	});

	unwrapExports(FetchClient_1);
	FetchClient_1.FetchClient;

	var error = function (message) {
	  function E() {
	    this.message = message;
	  }

	  E.prototype = new Error();
	  E.prototype.name = 'InvalidCharacterError';
	  E.prototype.code = 5;
	  return E;
	};
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	var E = error('The string to be encoded contains characters out of range');
	var _btoa = typeof btoa !== 'undefined'
	/* istanbul ignore next */
	? function (input) {
	  return btoa(input);
	} : function (input) {
	  var str = String(input);
	  var output = '';

	  for ( // initialize result and counter
	  var block, charCode, idx = 0, map = chars; // if the next str index does not exist:
	  //   change the mapping table to "="
	  //   check if d has no fractional digits
	  str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
	    charCode = str.charCodeAt(idx += 3 / 4);

	    if (charCode > 0xFF) {
	      throw new E();
	    }

	    block = block << 8 | charCode;
	  }

	  return output;
	};

	var utf8 = function (input) {
	  return encodeURIComponent(input).replace(/%([0-9A-F]{2})/g, function (match, p1) {
	    return String.fromCharCode('0x' + p1);
	  });
	};

	var btoa$1 = (function (input) {
	  return _btoa(utf8(input));
	});

	var btoau = (function (input) {
	  return btoa$1(input).replace(/\+/g, '-').replace(/\//g, '_');
	});

	var E$1 = error('The string to be decoded is not correctly encoded');
	var _atob = typeof atob !== 'undefined'
	/* istanbul ignore next */
	? function (input) {
	  return atob(input);
	} : function (input) {
	  var str = String(input).replace(/[=]+$/, '');

	  if (str.length % 4 == 1) {
	    throw new E$1();
	  }

	  var output = '';

	  for ( // initialize result and counters
	  var bc = 0, bs, buffer, idx = 0; // get next character
	  buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;
	  ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
	    // try to find character in table (0-63, not found => -1)
	    buffer = chars.indexOf(buffer);
	  }

	  return output;
	};

	var utf16 = function (input) {
	  return decodeURIComponent(input.split('').map(function (c) {
	    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	  }).join(''));
	};

	var atob$1 = (function (input) {
	  return utf16(_atob(input));
	});

	var atobu = (function (input) {
	  return atob$1(input.replace(/-/g, '+').replace(/_/g, '/'));
	});



	var b2a_1 = /*#__PURE__*/Object.freeze({
		btoa: btoa$1,
		btoau: btoau,
		atob: atob$1,
		atobu: atobu
	});

	var BasicAuth_1 = createCommonjsModule(function (module, exports) {
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	// this is var and not const to please typedoc https://github.com/TypeStrong/typedoc/issues/691
	var secrets = new WeakMap(); // tslint:disable-line
	/**
	 * Allows to use Basic-Auth for Authorization to the
	 * Cumulocity API.
	 */
	var BasicAuth = /** @class */ (function () {
	    /**
	     * Authenticates the given user against the given tenant.
	     * @param name
	     * @param password
	     * @param tenant
	     */
	    function BasicAuth(credentials) {
	        this.updateCredentials(credentials);
	    }
	    BasicAuth.prototype.updateCredentials = function (_a) {
	        var _b = _a === void 0 ? {} : _a, tenant = _b.tenant, user = _b.user, password = _b.password, token = _b.token, tfa = _b.tfa;
	        var secret = secrets.get(this) || {};
	        if (user && tenant) {
	            user = tenant + "/" + user;
	        }
	        user = user || this.user;
	        password = password || secret.password;
	        if (!token && user && password) {
	            token = b2a_1.btoa(user + ":" + password);
	        }
	        if (user) {
	            this.user = user;
	        }
	        token = token || secret.token;
	        tfa = tfa || secret.tfa;
	        secrets.set(this, { tfa: tfa, token: token, password: password });
	        return token;
	    };
	    BasicAuth.prototype.getFetchOptions = function (options) {
	        var secret = secrets.get(this);
	        var token = secret.token, tfa = secret.tfa;
	        var xsrfToken = this.getCookieValue('XSRF-TOKEN');
	        var headers = __assign({ Authorization: "Basic " + (token || '') }, (xsrfToken ? { 'X-XSRF-TOKEN': xsrfToken } : undefined));
	        if (tfa) {
	            headers.tfatoken = tfa;
	        }
	        options.headers = Object.assign(headers, options.headers);
	        return options;
	    };
	    BasicAuth.prototype.getCometdHandshake = function (config) {
	        if (config === void 0) { config = {}; }
	        var secret = secrets.get(this);
	        var token = secret.token, tfa = secret.tfa;
	        var KEY = 'com.cumulocity.authn';
	        var ext = config.ext = config.ext || {};
	        ext[KEY] = Object.assign(ext[KEY] || {}, { token: token, tfa: tfa });
	        return config;
	    };
	    BasicAuth.prototype.logout = function () {
	        delete this.user;
	        secrets.set(this, {});
	    };
	    BasicAuth.prototype.getCookieValue = function (name) {
	        try {
	            var value = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
	            return value ? value.pop() : undefined;
	        }
	        catch (ex) {
	            return undefined;
	        }
	    };
	    return BasicAuth;
	}());
	exports.BasicAuth = BasicAuth;

	});

	unwrapExports(BasicAuth_1);
	BasicAuth_1.BasicAuth;

	var CookieAuth_1 = createCommonjsModule(function (module, exports) {
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * Allows to use Cookies for Authorization to the
	 * Cumulocity API.
	 */
	var CookieAuth = /** @class */ (function () {
	    function CookieAuth() {
	        this.logoutUrl = 'user/logout';
	    }
	    CookieAuth.prototype.updateCredentials = function (_a) {
	        var user = (_a === void 0 ? {} : _a).user;
	        this.user = user;
	        return undefined;
	    };
	    CookieAuth.prototype.getFetchOptions = function (options) {
	        var xsrfToken = this.getCookieValue('XSRF-TOKEN');
	        var headers = { 'X-XSRF-TOKEN': xsrfToken };
	        options.headers = Object.assign(headers, options.headers);
	        return options;
	    };
	    CookieAuth.prototype.getCometdHandshake = function (config) {
	        if (config === void 0) { config = {}; }
	        var KEY = 'com.cumulocity.authn';
	        var xsrfToken = this.getCookieValue('XSRF-TOKEN');
	        var ext = config.ext = config.ext || {};
	        ext[KEY] = Object.assign(ext[KEY] || {}, { xsrfToken: xsrfToken });
	        return config;
	    };
	    CookieAuth.prototype.logout = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var client, method, body, headers;
	            return __generator(this, function (_a) {
	                if (this.user) {
	                    delete this.user;
	                }
	                client = new FetchClient_1.FetchClient();
	                client.setAuth(this);
	                method = 'POST';
	                body = JSON.stringify({});
	                headers = { 'content-type': 'application/json', accept: 'application/json' };
	                return [2 /*return*/, client.fetch(this.logoutUrl, { headers: headers, body: body, method: method })];
	            });
	        });
	    };
	    CookieAuth.prototype.getCookieValue = function (name) {
	        var value = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
	        return value ? value.pop() : '';
	    };
	    return CookieAuth;
	}());
	exports.CookieAuth = CookieAuth;

	});

	unwrapExports(CookieAuth_1);
	CookieAuth_1.CookieAuth;

	var Severity_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (Severity) {
	    Severity["CRITICAL"] = "CRITICAL";
	    Severity["MAJOR"] = "MAJOR";
	    Severity["MINOR"] = "MINOR";
	    Severity["WARNING"] = "WARNING";
	})(exports.Severity || (exports.Severity = {}));

	});

	unwrapExports(Severity_1);
	Severity_1.Severity;

	var QueriesUtil_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var QueriesUtil = /** @class */ (function () {
	    function QueriesUtil() {
	        var _this = this;
	        this.operatorFns = {
	            __not: function (operand) {
	                return ['not(', _this.buildQueryFilter(operand, null), ')'].join('');
	            },
	            __and: function (operand) {
	                return _this.buildQueryFilter(operand, null, 'and');
	            },
	            __or: function (operand) {
	                return _this.buildQueryFilter(operand, null, 'or');
	            },
	            __eq: function (operand, contextKey) {
	                if (typeof operand === 'object' && operand !== null) {
	                    return _this.buildQueryFilter(operand, contextKey);
	                }
	                return [contextKey, 'eq', _this.quoteString(operand)].join(' ');
	            },
	            __gt: function (operand, contextKey) {
	                return [contextKey, 'gt', _this.quoteString(operand)].join(' ');
	            },
	            __ge: function (operand, contextKey) {
	                return [contextKey, 'ge', _this.quoteString(operand)].join(' ');
	            },
	            __lt: function (operand, contextKey) {
	                return [contextKey, 'lt', _this.quoteString(operand)].join(' ');
	            },
	            __le: function (operand, contextKey) {
	                return [contextKey, 'le', _this.quoteString(operand)].join(' ');
	            },
	            __in: function (operand, contextKey) {
	                var stmts = operand.filter(function (op) { return !!op; }).map(function (op) {
	                    return [contextKey, 'eq', _this.quoteString(op)].join(' ');
	                });
	                return _this.glue(stmts, 'or');
	            },
	            __bygroupid: function (operand) {
	                return ['bygroupid(', operand, ')'].join('');
	            },
	            __has: function (operand) {
	                return ['has(', operand, ')'].join('');
	            }
	        };
	    }
	    QueriesUtil.prototype.buildQuery = function (query) {
	        var q = [];
	        var filter = this.buildQueryFilter(query.__filter || query);
	        var orderBy = this.buildQueryOrderby(query.__orderby);
	        if (filter) {
	            q.push(['$filter=(', filter, ')'].join(''));
	        }
	        if (orderBy) {
	            q.push(['$orderby=', orderBy].join(''));
	        }
	        return q.join(' ');
	    };
	    QueriesUtil.prototype.buildQueryFilter = function (queryObj, _queryKey, _glueType) {
	        var _this = this;
	        var queryKey = _queryKey || null;
	        var glueType = _glueType || 'and';
	        var q = [];
	        if (Array.isArray(queryObj)) {
	            queryObj.forEach(function (qObj) {
	                var _q = _this.buildQueryFilter(qObj, null, glueType);
	                if (_q) {
	                    q.push(_q);
	                }
	            });
	        }
	        else {
	            var _q_1;
	            Object.keys(queryObj).forEach(function (k) {
	                if (_this.operatorFns[k] !== undefined) {
	                    _q_1 = _this.operatorFns[k](queryObj[k], queryKey);
	                    if (_q_1) {
	                        q.push(_q_1);
	                    }
	                }
	                else {
	                    _q_1 = _this.operatorFns.__eq(queryObj[k], k);
	                    if (_q_1) {
	                        q.push(_q_1);
	                    }
	                }
	            });
	        }
	        return this.glue(q, glueType);
	    };
	    QueriesUtil.prototype.buildQueryOrderby = function (query) {
	        var o = [];
	        if (query) {
	            query.forEach(function (q) {
	                Object.keys(q).forEach(function (k) {
	                    if (q[k] !== 0) {
	                        o.push([k, q[k] > 0 ? 'asc' : 'desc'].join(' '));
	                    }
	                });
	            });
	        }
	        return o.join(',');
	    };
	    QueriesUtil.prototype.glue = function (stmts, type) {
	        return ((stmts.length > 1) ? (['(', stmts.join(") " + type + " ("), ')'].join('')) : (stmts[0]));
	    };
	    QueriesUtil.prototype.quoteString = function (s) {
	        return typeof s === 'string' ? ['\'', s, '\''].join('') : s;
	    };
	    return QueriesUtil;
	}());
	exports.QueriesUtil = QueriesUtil;

	});

	unwrapExports(QueriesUtil_1);
	QueriesUtil_1.QueriesUtil;

	var core = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(Service_1);
	__export(FetchClient_1);
	__export(BasicAuth_1);
	__export(CookieAuth_1);
	__export(Paging_1);
	__export(Severity_1);
	__export(ObservableList_1);
	__export(QueriesUtil_1);

	});

	unwrapExports(core);

	var EventService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * This class allows managing for events.
	 */
	var EventService = /** @class */ (function (_super) {
	    __extends(EventService, _super);
	    function EventService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'event';
	        _this.listUrl = 'events';
	        _this.propertyName = 'events';
	        _this.channel = '/events/*';
	        return _this;
	    }
	    /**
	     * Gets the details of a specific event.
	     *
	     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const eventId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await eventService.detail(eventId);
	     *   })();
	     * ```
	     */
	    EventService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new event.
	     *
	     * @param {IEvent} entity Event object with mandantory fragments.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const mandantoryObject: IEvent = {
	     *    source: device,
	     *    text: 'I am an Event!',
	     *    time: '2018-05-02T10:08:00Z',
	     *    type: 'device-type-here',
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await eventService.create(mandantoryObject);
	     *  })();
	     * ```
	     */
	    EventService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates event data.
	     *
	     * @param {Partial<IEvent>} entity Event is partially updatable.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialUpdateObject: Partial<IEvent> = {
	     *    source: device,
	     *    text: 'Changed Event!'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await eventService.update(partialUpdateObject);
	     *  })();
	     * ```
	     */
	    EventService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of events filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying events.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await eventService.list(filter);
	     *   })();
	     * ```
	     */
	    EventService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = eventService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    EventService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * List all events by a given source.
	     *
	     * @param {string | number | IIdentified} sourceOrId The source of the event.
	     * @param {object} filter Object containing filters for querying.
	     * @param {object} options To configure the observable.
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const listBySource$ = eventService.listBySource$(11);
	     *   listBySource$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    EventService.prototype.listBySource$ = function (sourceOrId, filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        Object.assign(filter, {
	            source: this.getIdString(sourceOrId)
	        });
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Removes an event with given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | number | IIdentified} entityOrId entity or id of the event.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const eventId: number = 1;
	     *
	     *   (async () => {
	     *     const {data, res} = await eventService.delete(eventId);
	     *     // data will be null
	     *   })();
	     * ```
	     */
	    EventService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    return EventService;
	}(core.Service));
	exports.EventService = EventService;

	});

	unwrapExports(EventService_1);
	EventService_1.EventService;

	/* eslint-env browser */
	var browser$1 = typeof self == 'object' ? self.FormData : window.FormData;

	var EventBinaryService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var form_data_1 = __importDefault(browser$1);

	var EventBinaryService = /** @class */ (function (_super) {
	    __extends(EventBinaryService, _super);
	    function EventBinaryService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'event';
	        _this.listUrl = 'events';
	        return _this;
	    }
	    /**
	     * Uploads an event binary.
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {Stream | Buffer | File | Blob} file file to upload.
	     * @param {string | number | IEvent} eventOrId Event or Id of the Event.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const file = Buffer.from('aaa');
	     *   const eventId: string | number = 123;
	     *
	     *    (async () => {
	     *      const {data, res} = await eventBinaryService.upload(file, eventId);
	     *   })();
	     * ```
	     */
	    EventBinaryService.prototype.upload = function (file, entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var method, url, body, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'POST';
	                        url = this.getDetailUrl(entityOrId);
	                        body = new form_data_1.default();
	                        body.append('file', file);
	                        headers = {
	                            accept: 'application/json'
	                        };
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Downloads the binary for a given event.
	     * @returns Response wrapped in [[IFetchResponse]]
	     *
	     * @param {string | number | IEvent} eventOrId Event or Id of the Event.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const eventId: string | number = 123;
	     *
	     *    (async () => {
	     *      const res = await eventBinaryService.download(eventId);
	     *   })();
	     */
	    EventBinaryService.prototype.download = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.getDetailUrl(entityOrId);
	                        return [4 /*yield*/, this.fetch(url)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Removes the binary for a given event.
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | number | IEvent} eventOrId Event or Id of the Event.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const eventId: string | number = 123;
	     *
	     *    (async () => {
	     *      const {data, res} = await eventBinaryService.delete(eventId);
	     *   })();
	     * ```
	     */
	    EventBinaryService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    EventBinaryService.prototype.getDetailUrl = function (entityOrId) {
	        var id;
	        if (typeof entityOrId === 'object' && entityOrId.id) {
	            id = entityOrId.id;
	        }
	        else {
	            id = entityOrId;
	        }
	        return this.listUrl + "/" + id + "/binaries";
	    };
	    return EventBinaryService;
	}(core.Service));
	exports.EventBinaryService = EventBinaryService;

	});

	unwrapExports(EventBinaryService_1);
	EventBinaryService_1.EventBinaryService;

	var event = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(EventService_1);
	__export(EventBinaryService_1);

	});

	unwrapExports(event);

	var InventoryBinaryService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var form_data_1 = __importDefault(browser$1);

	var InventoryBinaryService = /** @class */ (function (_super) {
	    __extends(InventoryBinaryService, _super);
	    function InventoryBinaryService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'inventory';
	        _this.listUrl = 'binaries';
	        _this.propertyName = 'managedObjects';
	        return _this;
	    }
	    /**
	     * Uploads a file and creates a managed object with its metadata.
	     * @param file A file to be uploaded.
	     * @param managedObject An object containing metadata about the file.
	     * Note that you can specify `fileType` and `fileName` in case `file` does not define them
	     * but these two properties will be removed from `managedObject` before saving.
	     */
	    InventoryBinaryService.prototype.create = function (file, managedObject) {
	        if (managedObject === void 0) { managedObject = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            var method, url, body, fileName, fileType, bodyHeaders, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'POST';
	                        url = this.listUrl;
	                        body = new form_data_1.default();
	                        if (managedObject.fileName) {
	                            fileName = managedObject.fileName;
	                            delete managedObject.fileName;
	                        }
	                        if (managedObject.fileType) {
	                            fileType = managedObject.fileType;
	                            delete managedObject.fileType;
	                        }
	                        if (!fileName) {
	                            fileName = 'bin';
	                        }
	                        if (typeof (File) !== 'undefined' && file instanceof File) {
	                            fileName = file.name;
	                            fileType = file.type;
	                        }
	                        if (!managedObject.name) {
	                            managedObject.name = fileName;
	                        }
	                        if (!managedObject.type) {
	                            managedObject.type = fileType || 'c8y_upload';
	                        }
	                        body.append('file', file, fileName);
	                        body.append('object', JSON.stringify(managedObject));
	                        if (typeof body.getHeaders === 'function') {
	                            bodyHeaders = body.getHeaders();
	                        }
	                        headers = Object.assign({
	                            accept: 'application/json'
	                        }, bodyHeaders);
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    InventoryBinaryService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as [[ObservableList]]
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = InventoryBinaryService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     */
	    InventoryBinaryService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    InventoryBinaryService.prototype.delete = function (managedObjectOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, managedObjectOrId)];
	            });
	        });
	    };
	    InventoryBinaryService.prototype.download = function (managedObjectOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.getDetailUrl(managedObjectOrId);
	                        return [4 /*yield*/, this.fetch(url)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Gets binary managed object's id from its download or self URL.
	     *
	     * @param {string} url URL string.
	     *
	     * @returns {number} Binary managed object's id.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const id = InventoryBinaryService.getIdFromUrl('http://mytenant.cumulocity.com/inventory/binaries/12345');
	     * ```
	     */
	    InventoryBinaryService.prototype.getIdFromUrl = function (url) {
	        var regexp = new RegExp('\\/inventory\\/binaries\\/(\\d+)|\\/inventory\\/managedObjects\\/(\\d+)');
	        var matches = url.match(regexp);
	        return matches && (matches[1] || matches[2]);
	    };
	    return InventoryBinaryService;
	}(core.Service));
	exports.InventoryBinaryService = InventoryBinaryService;

	});

	unwrapExports(InventoryBinaryService_1);
	InventoryBinaryService_1.InventoryBinaryService;

	var InventoryService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });


	/**
	 * Possible types of a child.
	 */
	var ChildType;
	(function (ChildType) {
	    ChildType["ASSETS"] = "childAssets";
	    ChildType["DEVICES"] = "childDevices";
	    ChildType["ADDITIONS"] = "childAdditions";
	})(ChildType = exports.ChildType || (exports.ChildType = {}));
	/**
	 * This class allows for managing managed objects and different child types, see [[ChildType]].
	 */
	var InventoryService = /** @class */ (function (_super) {
	    __extends(InventoryService, _super);
	    function InventoryService(client, realtime) {
	        var _this = _super.call(this, client, realtime) || this;
	        _this.baseUrl = 'inventory';
	        _this.listUrl = 'managedObjects';
	        _this.propertyName = 'managedObjects';
	        _this.channel = '/managedobjects/*';
	        _this.inventoriesQueryParamName = 'query';
	        _this.devicesQueryParamName = 'q';
	        _this.queriesUtil = new core.QueriesUtil();
	        _this.binary = new InventoryBinaryService_1.InventoryBinaryService(client);
	        return _this;
	    }
	    /**
	     * Gets the details of managed object
	     *
	     * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const managedObjId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.detail(managedObjId);
	     *   })();
	     * ```
	     */
	    InventoryService.prototype.detail = function (managedObjectOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, managedObjectOrId)];
	            });
	        });
	    };
	    /**
	     * Gets the details of managed object as observable
	     *
	     * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.
	     * @param {IObservableOptions} options The observable options.
	     *
	     * @returns Data wrapped as Observable
	     *
	     * @example
	     * ```typescript
	     *
	     *   const managedObjId: number = 1;
	     *
	     *   const detail$ = inventoryService.detail$(managedObjId);
	     *   detail$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    InventoryService.prototype.detail$ = function (entityOrId, options) {
	        return _super.prototype.detail$.call(this, entityOrId, options);
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = inventoryService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    InventoryService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Creates a new managed object.
	     *
	     * @param {Partial<IManagedObject>} managedObject
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialManagedObj: Partial<IManagedObject> = {
	     *    customFragment: 'yourData'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await inventoryService.create(partialManagedObj);
	     *  })();
	     * ```
	     */
	    InventoryService.prototype.create = function (managedObject) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, managedObject)];
	            });
	        });
	    };
	    /**
	     * Updates managed object data.
	     *
	     * @param {Partial<IManagedObject>} managedObject Managed object is partially updatable.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialUpdateObject: Partial<IManagedObject> = {
	     *    customFragment: 'Changed data',
	     *    name: 'Name'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await inventoryService.update(partialUpdateObject);
	     *  })();
	     * ```
	     */
	    InventoryService.prototype.update = function (managedObject) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, managedObject)];
	            });
	        });
	    };
	    /**
	     * Gets the list of managed objects filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying managed objects.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await inventoryService.list(filter);
	     *   })();
	     * ```
	     */
	    InventoryService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets the list of all managed objects filtered and sorted by given query.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying managed objects.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *  const query = {
	     *      name: 'MY-NAM*'
	     *  }
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await inventoryService.listQuery(query, filter);
	     *   })();
	     * ```
	     */
	    InventoryService.prototype.listQuery = function (query, filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                filter[this.inventoriesQueryParamName] = this.queriesUtil.buildQuery(query);
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets the list of all devices filtered and sorted by given query.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying devices.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *  const query = {
	     *      name: 'MY-NAM*'
	     *  }
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await inventoryService.listQueryDevices(query, filter);
	     *   })();
	     * ```
	     */
	    InventoryService.prototype.listQueryDevices = function (query, filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                filter[this.devicesQueryParamName] = this.queriesUtil.buildQuery(query);
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Removes managed object with given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IdReference} managedObjectOrId ManagedObject or Id of the ManagedObject.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const managedObjectId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.delete(managedObjectId);
	     *   })();
	     * ```
	     */
	    InventoryService.prototype.delete = function (managedObjectOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, managedObjectOrId)];
	            });
	        });
	    };
	    /**
	     * Gets a list of child additions from a given managed object (parent)
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {IdReference} parentReference
	     * @param {object} filter
	     *
	     * @example
	     * ```typescript
	     *    const parentReferenceId: IdReference = 1;
	     *
	     *    const filter: object = {
	     *      pageSize: 100,
	     *      withTotalPages: true
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res, paging} = await inventoryService.childAdditionsList(parentReferenceId, filter);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childAdditionsList = function (parentReference, filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.listChildren(ChildType.ADDITIONS, parentReference, filter)];
	            });
	        });
	    };
	    /**
	     * Creates a new managed object as child addition to another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {Partial<IManagedObject>} managedObject
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const mOAsChildAddition: Partial<IManagedObject> = {
	     *      name: 'Child addition MO',
	     *      type: 'new type',
	     *      ...
	     *    };
	     *
	     *    // This is the identifier of the managed object which should be the parent of
	     *    // mOAsChildAddition, see above.
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childAdditionsCreate(mOAsChildAddition, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childAdditionsCreate = function (managedObject, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.createChild(ChildType.ADDITIONS, managedObject, parentReference)];
	            });
	        });
	    };
	    /**
	     * Adds an existing managed object as child addition to another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IdReference} childReference
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const childRef: number = 2;
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childAdditionsCreate(childRef, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childAdditionsAdd = function (childReference, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.addChild(ChildType.ADDITIONS, childReference, parentReference)];
	            });
	        });
	    };
	    /**
	     * Removes an existing managed object as child addition from another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IdReference} childReference
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const childRef: number = 2;
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childAdditionsRemove(childRef, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childAdditionsRemove = function (childReference, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.removeChild(ChildType.ADDITIONS, childReference, parentReference)];
	            });
	        });
	    };
	    /**
	     * Gets a list of child assets from a given managed object (parent)
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {IdReference} parentReference
	     * @param {object} filter
	     *
	     * @example
	     * ```typescript
	     *
	     *    const parentReferenceId: IdReference = 1;
	     *
	     *    const filter: object = {
	     *      pageSize: 100,
	     *      withTotalPages: true
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res, paging} = await inventoryService.childAssetsList(parentReferenceId, filter);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childAssetsList = function (parentReference, filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.listChildren(ChildType.ASSETS, parentReference, filter)];
	            });
	        });
	    };
	    /**
	     * Creates a new managed object as child asset to another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {Partial<IManagedObject>} managedObject
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const mOAsChildAsset: Partial<IManagedObject> = {
	     *      name: 'Child asset MO',
	     *      type: 'new type',
	     *      ...
	     *    };
	     *
	     *    // This is the identifier of the managed object which should be the parent of
	     *    // mOAsChildAsset, see above.
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childAdditionsCreate(mOAsChildAddition, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childAssetsCreate = function (managedObject, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.createChild(ChildType.ASSETS, managedObject, parentReference)];
	            });
	        });
	    };
	    /**
	     * Adds an existing managed object as child asset to another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IdReference} childReference
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const childRef: number = 2;
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childAssetsAdd(childRef, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childAssetsAdd = function (childReference, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.addChild(ChildType.ASSETS, childReference, parentReference)];
	            });
	        });
	    };
	    /**
	     * Removes an existing managed object as child asset from another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IdReference} childReference
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const childRef: number = 2;
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childAssetsRemove(childRef, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childAssetsRemove = function (childReference, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.removeChild(ChildType.ASSETS, childReference, parentReference)];
	            });
	        });
	    };
	    /**
	     * Gets a list of child devices from a given managed object (parent)
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {IdReference} parentReference
	     * @param {object} filter
	     *
	     * @example
	     * ```typescript
	     *
	     *    const parentReferenceId: IdReference = 1;
	     *
	     *    const filter: object = {
	     *      pageSize: 100,
	     *      withTotalPages: true
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res, paging} = await inventoryService.childDevicesList(parentReferenceId, filter);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childDevicesList = function (parentReference, filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.listChildren(ChildType.DEVICES, parentReference, filter)];
	            });
	        });
	    };
	    /**
	     * Creates a new managed object as child device to another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {Partial<IManagedObject>} managedObject
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const mOAsChildDevice: Partial<IManagedObject> = {
	     *      name: 'Child device MO',
	     *      type: 'new type',
	     *      ...
	     *    };
	     *
	     *    // This is the identifier of the managed object which should be the parent of
	     *    // mOAsChildDevice, see above.
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childDevicesCreate(mOAsChildDevice, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childDevicesCreate = function (managedObject, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.createChild(ChildType.DEVICES, managedObject, parentReference)];
	            });
	        });
	    };
	    /**
	     * Adds an existing managed object as child device to another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IdReference} childReference
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const childRef: number = 2;
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childDevicesAdd(childRef, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childDevicesAdd = function (childReference, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.addChild(ChildType.DEVICES, childReference, parentReference)];
	            });
	        });
	    };
	    /**
	     * Removes an existing managed object as child device from another managed object (parent)
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IdReference} childReference
	     * @param {IdReference} parentReference
	     *
	     * @example
	     * ```typescript
	     *
	     *    const childRef: number = 2;
	     *    const parentReferenceId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryService.childDevicesRemove(childRef, parentReferenceId);
	     *    })();
	     * ```
	     */
	    InventoryService.prototype.childDevicesRemove = function (childReference, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.removeChild(ChildType.DEVICES, childReference, parentReference)];
	            });
	        });
	    };
	    InventoryService.prototype.onBeforeUpdate = function (objWithId) {
	        delete objWithId.lastUpdated;
	        return objWithId;
	    };
	    InventoryService.prototype.onBeforeCreate = function (managedObject) {
	        delete managedObject.id;
	        delete managedObject.lastUpdated;
	        return managedObject;
	    };
	    InventoryService.prototype.getChildrenUrl = function (type, parentReference) {
	        return this.getDetailUrl(parentReference) + "/" + type;
	    };
	    InventoryService.prototype.getChildUrl = function (type, childReference, parentReference) {
	        var childId = this.getIdString(childReference);
	        return this.getChildrenUrl(type, parentReference) + "/" + childId;
	    };
	    InventoryService.prototype.listChildren = function (type, parentReference, filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, url, res, json, data, paging;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json' };
	                        url = this.getChildrenUrl(type, parentReference);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: filter })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        json = _a.sent();
	                        data = json.references.map(function (ref) { return ref.managedObject; });
	                        paging = this.getPaging(json, filter);
	                        return [2 /*return*/, { res: res, data: data, paging: paging }];
	                }
	            });
	        });
	    };
	    InventoryService.prototype.createChild = function (type, managedObject, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.getChildrenUrl(type, parentReference);
	                        method = 'POST';
	                        body = JSON.stringify(this.onBeforeCreate(managedObject));
	                        headers = { 'content-type': this.mimeType('managedObject'), accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    InventoryService.prototype.addChild = function (type, childReference, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, childId, body, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.getChildrenUrl(type, parentReference);
	                        method = 'POST';
	                        childId = this.getIdString(childReference);
	                        body = JSON.stringify({ managedObject: { id: String(childId) } });
	                        headers = {
	                            accept: 'application/json',
	                            'content-type': this.mimeType('managedObjectReference')
	                        };
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        data = data.managedObject;
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    InventoryService.prototype.removeChild = function (type, childReference, parentReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            var childId, url, method, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        childId = this.getIdString(childReference);
	                        url = this.getChildrenUrl(type, parentReference) + "/" + childId;
	                        method = 'DELETE';
	                        headers = { accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(url, { method: method, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        data = null;
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    return InventoryService;
	}(core.Service));
	exports.InventoryService = InventoryService;

	});

	unwrapExports(InventoryService_1);
	InventoryService_1.ChildType;
	InventoryService_1.InventoryService;

	var inventory = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(InventoryService_1);
	__export(InventoryBinaryService_1);

	});

	unwrapExports(inventory);

	var MeasurementService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * This class allows for managing measurements.
	 */
	var MeasurementService = /** @class */ (function (_super) {
	    __extends(MeasurementService, _super);
	    function MeasurementService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'measurement';
	        _this.listUrl = 'measurements';
	        _this.propertyName = 'measurements';
	        _this.channel = '/measurements/*';
	        return _this;
	    }
	    /**
	     * Gets the details of selected measurement.
	     *
	     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const measurementId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await measurementService.detail(measurementId);
	     *   })();
	     * ```
	     */
	    MeasurementService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new measurement.
	     *
	     * @param {Partial<IMeasurementCreate>} entity At least sourceId is mandantory.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const mandantoryObject: Partial<IMeasurementCreate> = {
	     *    sourceId: device.id,
	     *    fragment: { series: { unit: '%', value: 51 } },
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await measurementService.create(mandantoryObject);
	     *  })();
	     * ```
	     */
	    MeasurementService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, this.onBeforeCreate(entity))];
	            });
	        });
	    };
	    /**
	     * Gets the list of measurements filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying measurements.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await measurementService.list(filter);
	     *   })();
	     * ```
	     */
	    MeasurementService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = measurementService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    MeasurementService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * List all events by a given source.
	     *
	     * @param {string | number | IIdentified} sourceOrId The source of the event.
	     * @param {object} filter Object containing filters for querying.
	     * @param {object} options To configure the observable.
	     *
	     * @returns Data wrapped as [[ObservableList]]
	     *
	     * @example
	     * ```typescript
	     *
	     *   const listBySource$ = measurementService.listBySource$(11);
	     *   listBySource$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    MeasurementService.prototype.listBySource$ = function (sourceOrId, filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        Object.assign(filter, {
	            source: this.getIdString(sourceOrId)
	        });
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Removes a measurement with given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | number | IIdentified} entityOrId
	     *
	     * @example
	     * ```typescript
	     *
	     *   const id: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await measurementService.delete(id);
	     *   })();
	     * ```
	     */
	    MeasurementService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Gets the list of series in a measurement filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {object} filter Object containing filters for querying measurements.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *    dateFrom: '2018-02-06T10:43:55.077Z',
	     *    dateTo: '2018-02-06T10:50:55.077Z',
	     *    source: device.id
	     *  };
	     *
	     *   (async () => {
	     *     const {data, res} = await measurementService.listSeries(filter);
	     *   })();
	     * ```
	     */
	    MeasurementService.prototype.listSeries = function (params) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.baseUrl + "/" + this.listUrl + "/series";
	                        return [4 /*yield*/, this.client.fetch(url, { params: params })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    MeasurementService.prototype.onBeforeCreate = function (entity) {
	        if (!entity.time) {
	            entity.time = new Date();
	        }
	        if (!entity.type) {
	            entity.type = 'c8y_Measurement';
	        }
	        if (entity.sourceId) {
	            var sourceId = entity.sourceId;
	            delete entity.sourceId;
	            if (!entity.source) {
	                entity.source = {
	                    id: String(sourceId),
	                };
	            }
	        }
	        return entity;
	    };
	    return MeasurementService;
	}(core.Service));
	exports.MeasurementService = MeasurementService;

	});

	unwrapExports(MeasurementService_1);
	MeasurementService_1.MeasurementService;

	var ISeriesFilter = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (aggregationType) {
	    aggregationType["MINUTELY"] = "MINUTELY";
	    aggregationType["HOURLY"] = "HOURLY";
	    aggregationType["MONTHLY"] = "MONTHLY";
	})(exports.aggregationType || (exports.aggregationType = {}));

	});

	unwrapExports(ISeriesFilter);
	ISeriesFilter.aggregationType;

	var measurement = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(MeasurementService_1);
	__export(ISeriesFilter);

	});

	unwrapExports(measurement);

	var AlarmService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * This class allows for managing alarms.
	 */
	var AlarmService = /** @class */ (function (_super) {
	    __extends(AlarmService, _super);
	    function AlarmService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'alarm';
	        _this.listUrl = 'alarms';
	        _this.propertyName = 'alarms';
	        _this.channel = '/alarms/*';
	        return _this;
	    }
	    /**
	     * Gets the details of selected alarms.
	     *
	     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const alarmId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await alarmService.detail(alarmId);
	     *    })();
	     * ```
	     */
	    AlarmService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new alarm.
	     *
	     * @param {IAlarm} entity Alarm object with mandantory fragments.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const mandantoryObject: IAlarm = {
	     *    severity: Severity.CRITICAL,
	     *    source: device,
	     *    text: 'I am an Alarm!',
	     *    time: '2018-05-02T10:08:00Z',
	     *    type: 'device-type-here',
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await alarmService.create(mandantoryObject);
	     *  })();
	     * ```
	     */
	    AlarmService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates alarm data.
	     *
	     * @param {Partial<IAlarm>} entity Alarm is partially updatable.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialUpdateObject: Partial<IAlarm> = {
	     *    severity: Severity.MINOR,
	     *    source: device,
	     *    text: 'Changed Alarm!'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await alarmService.update(partialUpdateObject);
	     *  })();
	     * ```
	     */
	    AlarmService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of alarms filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying alarms.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     severity: Severity.MAJOR,
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await alarmService.list(filter);
	     *   })();
	     * ```
	     */
	    AlarmService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as [[ObservableList]]
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = alarmService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    AlarmService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * List all events by a given source.
	     *
	     * @param {string | number | IIdentified} sourceOrId The source of the event.
	     * @param {object} filter Object containing filters for querying.
	     * @param {object} options To configure the observable.
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const listBySource$ = alarmService.listBySource$(11);
	     *   listBySource$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    AlarmService.prototype.listBySource$ = function (sourceOrId, filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        Object.assign(filter, {
	            source: this.getIdString(sourceOrId)
	        });
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    return AlarmService;
	}(core.Service));
	exports.AlarmService = AlarmService;

	});

	unwrapExports(AlarmService_1);
	AlarmService_1.AlarmService;

	var AlarmStatus_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (AlarmStatus) {
	    AlarmStatus["ACKNOWLEDGED"] = "ACKNOWLEDGED";
	    AlarmStatus["CLEARED"] = "CLEARED";
	    AlarmStatus["ACTIVE"] = "ACTIVE";
	})(exports.AlarmStatus || (exports.AlarmStatus = {}));

	});

	unwrapExports(AlarmStatus_1);
	AlarmStatus_1.AlarmStatus;

	var alarm = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(AlarmService_1);
	__export(AlarmStatus_1);

	});

	unwrapExports(alarm);

	var OperationService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * This class allows for managing operations on a device.
	 */
	var OperationService = /** @class */ (function (_super) {
	    __extends(OperationService, _super);
	    function OperationService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'devicecontrol';
	        _this.listUrl = 'operations';
	        _this.propertyName = 'operations';
	        return _this;
	    }
	    /**
	     * Gets the details of selected operation.
	     *
	     * @param {string|number|IIdentified} entityOrId Entity or Id of the entitytabs.service.ts.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const operationId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await operationService.detail(operationId);
	     *   })();
	     * ```
	     */
	    OperationService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new operation.
	     *
	     * @param {IOperation} entity Operation object with mandantory fragments.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const mandantoryObject: IOperation = {
	     *    com_cumulocity_model_WebCamDevice: {
	     *      name: 'take picture',
	     *      parameters: {
	     *         duration: '5s',
	     *         quality: 'HD'
	     *      }
	     *    },
	     *    deviceId: device.id,
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await operationService.create(mandantoryObject);
	     *  })();
	     * ```
	     */
	    OperationService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates operation data.
	     *
	     * @param {Partial<IOperation>} entity Operation is partially updatable.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialUpdateObject: Partial<IOperation> = {
	     *    com_cumulocity_model_WebCamDevice: {
	     *      name: 'take picture',
	     *      parameters: {
	     *         duration: '2s',
	     *         quality: 'HD',
	     *         ratio: '16:9'
	     *      }
	     *    },
	     *    deviceId: device.id,
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await operationService.update(partialUpdateObject);
	     *  })();
	     * ```
	     */
	    OperationService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of operations filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying operations.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await operationService.list(filter);
	     *   })();
	     * ```
	     */
	    OperationService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list of operations as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = operationService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    OperationService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    return OperationService;
	}(core.Service));
	exports.OperationService = OperationService;

	});

	unwrapExports(OperationService_1);
	OperationService_1.OperationService;

	var OperationBulkService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * This class allows for managing bulk operations.
	 */
	var OperationBulkService = /** @class */ (function (_super) {
	    __extends(OperationBulkService, _super);
	    function OperationBulkService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'devicecontrol';
	        _this.listUrl = 'bulkoperations';
	        _this.propertyName = 'bulkOperations';
	        return _this;
	    }
	    /**
	     * Gets the details of selected bulk operation.
	     *
	     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const bulkOperationId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await operationBulkService.detail(bulkOperationId);
	     *   })();
	     * ```
	     */
	    OperationBulkService.prototype.detail = function (operationOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, operationOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new operation.
	     *
	     * @param {Partial<IOperationBulk>} operation Operation object with mandantory fragments.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const mandantoryObject: Partial<IOperationBulk> = {
	     *    creationRamp: 15,
	     *    groupId: '149044',
	     *    operationPrototype: {
	     *      c8y_Restart: {},
	     *      description: 'Restart device',
	     *      deviceId: device.id,
	     *      status: 'PENDING'
	     *    },
	     *     startDate: '2018-02-15T16:01:00.000Z'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await operationBulkService.create(mandantoryObject);
	     *  })();
	     * ```
	     */
	    OperationBulkService.prototype.create = function (operation) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, operation)];
	            });
	        });
	    };
	    /**
	     * Updates a new operation.
	     *
	     * @param {Partial<IOperationBulk>} operation Operation object.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const updateObject: Partial<IOperationBulk> = {
	     *    creationRamp: 15,
	     *    groupId: '149044',
	     *    operationPrototype: {
	     *      c8y_Restart: {},
	     *      description: 'Restart device',
	     *      deviceId: device.id,
	     *      status: 'PENDING'
	     *    },
	     *     startDate: '2018-02-15T16:01:00.000Z'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await operationBulkService.update(updateObject);
	     *  })();
	     * ```
	     */
	    OperationBulkService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of bulk operations filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying alarms.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await operationBulkService.list(filter);
	     *   })();
	     * ```
	     */
	    OperationBulkService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = operationBulkService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    OperationBulkService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Removes an bulk operation with given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | number | IIdentified):} operationOrId Operation object or id.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const id: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await operationBulkService.delete(id);
	     *   })();
	     * ```
	     */
	    OperationBulkService.prototype.delete = function (operationOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, operationOrId)];
	            });
	        });
	    };
	    return OperationBulkService;
	}(core.Service));
	exports.OperationBulkService = OperationBulkService;

	});

	unwrapExports(OperationBulkService_1);
	OperationBulkService_1.OperationBulkService;

	var OperationBulkStatus_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (OperationBulkStatus) {
	    OperationBulkStatus["ACTIVE"] = "ACTIVE";
	    OperationBulkStatus["COMPLETED"] = "COMPLETED";
	    OperationBulkStatus["DELETED"] = "DELETED";
	})(exports.OperationBulkStatus || (exports.OperationBulkStatus = {}));

	});

	unwrapExports(OperationBulkStatus_1);
	OperationBulkStatus_1.OperationBulkStatus;

	var OperationStatus_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (OperationStatus) {
	    OperationStatus["PENDING"] = "PENDING";
	    OperationStatus["EXECUTING"] = "EXECUTING";
	    OperationStatus["SUCCESSFUL"] = "SUCCESSFUL";
	    OperationStatus["FAILED"] = "FAILED";
	})(exports.OperationStatus || (exports.OperationStatus = {}));

	});

	unwrapExports(OperationStatus_1);
	OperationStatus_1.OperationStatus;

	var operation = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(OperationService_1);
	__export(OperationBulkService_1);
	__export(OperationBulkStatus_1);
	__export(OperationStatus_1);

	});

	unwrapExports(operation);

	var TenantService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * @description
	 * This service allows for managing tenants.
	 */
	var TenantService = /** @class */ (function (_super) {
	    __extends(TenantService, _super);
	    function TenantService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'tenant';
	        _this.listUrl = 'tenants';
	        _this.currentTenantUrl = 'currentTenant';
	        _this.propertyName = 'tenants';
	        _this.fetchOptions = {
	            method: 'PUT',
	            body: {},
	            headers: { 'content-type': 'application/json', accept: 'application/json' }
	        };
	        return _this;
	    }
	    /**
	     * Get a representation of a tenant.
	     *
	     * @param {string|number|IIdentified} entityOrId Tenant's id or tenant object.
	     *
	     * @returns Returns promise object that is resolved with the IIdentified wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const tenantId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await tenantService.detail(tenantId);
	     *   })();
	     * ```
	     *
	     * Required role: ROLE_TENANT_MANAGEMENT_READ<br><br>
	     * User password is never returned in GET response. Authentication mechanism is provided by another interface.
	     */
	    TenantService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new tenant.
	     *
	     * @param {IIdentified} entity Tenant object.
	     *
	     * @returns {IResult<IIdentified>} Returns promise object that is resolved with the details of newly created tenant.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const tenantObject = {
	     *    id: "sample_tenant",
	     *    company: "sample_company",
	     *    domain: "sample_domain.com",
	     *    contactName: "Mr. Doe",
	     *    ...
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await tenantService.create(tenantObject);
	     *  })();
	     * ```
	     *
	     * Required role: ROLE_TENANT_MANAGEMENT_ADMIN or ROLE_TENANT_MANAGEMENT_CREATE<br><br>
	     * Note that creating a tenant with adminName, adminPass and adminEmail, creates an admin user with these settings.
	     * For the tenant id SQL keywords (e.g., select, cross, where) are not allowed.
	     */
	    TenantService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates tenant data.
	     *
	     * @param {IIdentified} entity Tenant is partially updatable.
	     *
	     * @returns {IResult<IIdentified>} Returns promise object that is resolved with the saved tenant object.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialUpdateObject: IIdentified = {
	     *     adminName : "newAdmin"
	     *     ...
	     *   }
	     *
	     *  (async () => {
	     *    const {data, res} = await tenantService.update(partialUpdateObject);
	     *  })();
	     * ```
	     *
	     * Required role: ROLE_TENANT_MANAGEMENT_ADMIN or ROLE_TENANT_MANAGEMENT_UPDATE<br><br>
	     * Note that updating adminPass and adminEmail updates these settings in the admin user of the tenant.
	     * Updating adminName has no effect.
	     */
	    TenantService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of tenants filtered by parameters.
	     *
	     * @param {object} filter Object containing filters for querying tenants.
	     *
	     * @returns Returns promise object that is resolved with the IIdentified wrapped by IResultList.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     severity: Severity.MAJOR,
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await tenantService.list(filter);
	     *   })();
	     * ```
	     *
	     * Required role: ROLE_TENANT_MANAGEMENT_READ
	     */
	    TenantService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = tenantService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    TenantService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Delete a representation of a tenant.
	     *
	     * @param {string|number|IIdentified} entityOrId Tenant's id or tenant object.
	     *
	     * @returns Returns promise object that is resolved with the IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const tenantId: string = "uniqueTenantId";
	     *
	     *    (async () => {
	     *      const {data, res} = await tenantService.delete(tenantId);
	     *   })();
	     * ```
	     *
	     * Required role: ROLE_TENANT_MANAGEMENT_ADMIN
	     */
	    TenantService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    TenantService.prototype.current = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json' };
	                        return [4 /*yield*/, this.fetch(this.currentTenantUrl, { headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * enable support user for current tenant.
	     *
	     * @returns Returns promise object that is resolved with the IResult.
	     *
	     * @example
	     * ```typescript
	     *    (async () => {
	     *      const {res} = await tenantService.enableSupportUser();
	     *   })();
	     * ```
	     */
	    TenantService.prototype.enableSupportUser = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = 'support-user/enable';
	                        return [4 /*yield*/, this.fetch(url, this.fetchOptions)];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    /**
	     * disable support user for current tenant.
	     *
	     * @returns Returns promise object that is resolved with the IResult.
	     *
	     * @example
	     * ```typescript
	     *    (async () => {
	     *      const {res} = await tenantService.disableSupportUser();
	     *   })();
	     * ```
	     */
	    TenantService.prototype.disableSupportUser = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = 'support-user/disable';
	                        return [4 /*yield*/, this.fetch(url, this.fetchOptions)];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    TenantService.prototype.currentTenantType = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var tenantData;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.current()];
	                    case 1:
	                        tenantData = _a.sent();
	                        if (tenantData.data.customProperties &&
	                            tenantData.data.customProperties.tenantType === 'TRIAL') {
	                            return [2 /*return*/, 'TRIAL'];
	                        }
	                        return [2 /*return*/, 'REGULAR'];
	                }
	            });
	        });
	    };
	    TenantService.prototype.onBeforeCreate = function (obj) {
	        return obj;
	    };
	    return TenantService;
	}(core.Service));
	exports.TenantService = TenantService;

	});

	unwrapExports(TenantService_1);
	TenantService_1.TenantService;

	var TenantStatus_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (TenantStatus) {
	    TenantStatus["ACTIVE"] = "ACTIVE";
	    TenantStatus["SUSPENDED"] = "SUSPENDED";
	})(exports.TenantStatus || (exports.TenantStatus = {}));

	});

	unwrapExports(TenantStatus_1);
	TenantStatus_1.TenantStatus;

	var tenant = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(TenantService_1);
	__export(TenantStatus_1);

	});

	unwrapExports(tenant);

	var UserInventoryRoleService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * @description
	 * This service allows for managing current user's inventory roles.
	 */
	var UserInventoryRoleService = /** @class */ (function (_super) {
	    __extends(UserInventoryRoleService, _super);
	    function UserInventoryRoleService(userUrl, client) {
	        var _this = _super.call(this, client) || this;
	        _this.listUrl = "inventory";
	        _this.currenUserUrl = "currentUser";
	        _this.propertyName = 'inventoryAssignments';
	        _this.baseUrl = "user/" + userUrl + "/roles";
	        return _this;
	    }
	    /**
	     * Get a representation of a concrete current user's inventory role.
	     *
	     * @param {string|number|IUserInventoryRole} entityOrId inventory role id or inventory role object.
	     *
	     * @returns Returns promise object that is resolved with the IUserInventoryRole wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const inventoryRoleId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await userInventoryRoleService.detail(inventoryRoleId);
	     *   })();
	     * ```
	     *
	     * Required role: ROLE_TENANT_MANAGEMENT_READ<br><br>
	     * User password is never returned in GET response. Authentication mechanism is provided by another interface.
	     */
	    UserInventoryRoleService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Assign inventory role to current user.
	     *
	     * @param {IUserInventoryRole} entity Inventory Role object.
	     *
	     * @returns Returns promise object that is resolved with the details of newly assigned inventory role.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const inventoryRoleObject: IUserInventoryRole = {
	     *    ...
	     *  };
	     *
	     *    (async () => {
	     *      const {data, res} = await userInventoryRoleService.create(inventoryRoleObject);
	     *   })();
	     * ```
	     */
	    UserInventoryRoleService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates an inventory role.
	     *
	     * @param {Partial<IUserInventoryRole>} entity Inventory Role object.
	     */
	    UserInventoryRoleService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list the inventory roles applied to a current user.
	     *
	     * @param {object} filter Object containing filters for querying inventory roles.
	     *
	     * @returns Returns promise object that is resolved with the IUserInventoryRole wrapped by IResultList.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     severity: Severity.MAJOR,
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await userInventoryRoleService.list(filter);
	     *   })();
	     * ```
	     */
	    UserInventoryRoleService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as [[ObservableList]]
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = userInventoryRoleService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    UserInventoryRoleService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Unassign inventory role from current user
	     *
	     * @param {string|number|IIdentified} entityOrId Inventory Role id or Inventory Role object.
	     *
	     * @returns Returns promise object that is resolved with the IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const inventoryRoleId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await userInventoryRoleService.delete(inventoryRoleId);
	     *   })();
	     * ```
	     */
	    UserInventoryRoleService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    return UserInventoryRoleService;
	}(core.Service));
	exports.UserInventoryRoleService = UserInventoryRoleService;

	});

	unwrapExports(UserInventoryRoleService_1);
	UserInventoryRoleService_1.UserInventoryRoleService;

	var UserService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });


	/**
	 * @description
	 * This service allows for managing users.
	 */
	var UserService = /** @class */ (function (_super) {
	    __extends(UserService, _super);
	    function UserService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'user';
	        _this.currentUserUrl = 'currentUser';
	        _this.passwordResetUrl = 'passwordReset';
	        _this.verifyTFACodeUrl = 'pin';
	        _this.totpCurrentUserURL = _this.currentUserUrl + "/totpSecret";
	        _this.verifyTOTPCodeUrl = _this.totpCurrentUserURL + "/verify";
	        _this.activateTOTPCodeUrl = _this.totpCurrentUserURL + "/activity";
	        _this.revokeTOTPSecretUrl = 'totpSecret/revoke';
	        _this.propertyName = 'users';
	        return _this;
	    }
	    Object.defineProperty(UserService.prototype, "listUrl", {
	        get: function () {
	            return this.client.tenant + "/users";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Gets the details of given user.
	     *
	     * @param {string | number | IUser} entityOrId User's id or user object.
	     *
	     * @returns Returns promise object that is resolved with the IUser wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const userId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.detail(userId);
	     *   })();
	     * ```
	     * User password is never returned in GET response. Authentication mechanism is provided by another interface.
	     */
	    UserService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new user.
	     *
	     * @param {IUser} entity User object.
	     *
	     * @returns {IResult<IUser>} Returns promise object that is resolved with the details of newly created user.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const userObject: IUser = {
	     *    userName: "newUser",
	     *    password: "userPassword12!@"
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await userService.create(userObject);
	     *  })();
	     * ```
	     */
	    UserService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates user data.
	     *
	     * @param {Partial<IUser>} entity User is partially updatable.
	     *
	     * @returns {IResult<IUserGroup>} Returns promise object that is resolved with the saved user object.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialUpdateObject: Partial<IUser> = {
	     *     "id" : "myuser",
	     *     "userName" : "newUserName",
	     *     "email": "newUserEmail@example.com"
	     *     ...
	     *   }
	     *
	     *  (async () => {
	     *    const {data, res} = await userService.update(partialUpdateObject);
	     *  })();
	     * ```
	     * When user is updated with changed permissions or groups, suitable audit record is created with type
	     * 'User' and activity 'User updated'.
	     */
	    UserService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of users filtered by parameters.
	     *
	     * @param {object} filter Object containing filters for querying users.
	     *
	     * @returns Returns promise object that is resolved with the IUser wrapped by IResultList.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await userService.list(filter);
	     *   })();
	     * ```
	     */
	    UserService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = userInventoryRoleService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    UserService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Removes user.
	     *
	     * @param {number|IIdentified} entityOrId User's id or user object.
	     *
	     * @returns Returns promise object that is resolved with the IResult of null.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const userId: string = "uniqueUserId";
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.delete(userGroupId);
	     *   })();
	     * ```
	     */
	    UserService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Create instance of User Inventory Role Service related with given User.
	     *
	     * @param {string|number|IUser} entityOrId User's id or user object.
	     *
	     * @returns Returns UserInventoryRoleService object that is related with given User.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const userId: string = "uniqueUserId";
	     *
	     *    const userInventoryRoleService = userService.inventoryAssignment(userGroupId);
	     *    (async () => {
	     *      const {data, res} = await userInventoryRoleService.create(...);
	     *   })();
	     * ```
	     */
	    UserService.prototype.inventoryAssignment = function (entityOrId) {
	        return new UserInventoryRoleService_1.UserInventoryRoleService(this.getDetailUrl(entityOrId), this.client);
	    };
	    /**
	     * Gets user that is currently logged in.
	     *
	     * @returns Returns promise object that is resolved with the IUser wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.current();
	     *   })();
	     * ```
	     */
	    UserService.prototype.current = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = {
	                            'content-type': 'application/json',
	                            Accept: 'application/vnd.com.nsn.cumulocity.user+json;'
	                        };
	                        return [4 /*yield*/, this.fetch(this.currentUserUrl, { headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Gets user that is currently logged in with the list of all roles assigned.
	     *
	     * @returns Returns promise object that is resolved with the ICurrenUser wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.currentWithEffectiveRoles();
	     *   })();
	     * ```
	     */
	    UserService.prototype.currentWithEffectiveRoles = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = {
	                            'content-type': 'application/json',
	                            Accept: 'application/vnd.com.nsn.cumulocity.currentUser+json;'
	                        };
	                        return [4 /*yield*/, this.fetch(this.currentUserUrl, { headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Updates the current user
	     *
	     * @param {IUser} user The user object with the properties to be updated
	     *
	     * @return Returns promise object resolved with the IUser wrapped by IResult
	     */
	    UserService.prototype.updateCurrent = function (user) {
	        return __awaiter(this, void 0, void 0, function () {
	            var mimeType, headers, body, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        mimeType = 'application/vnd.com.nsn.cumulocity.user+json';
	                        headers = { 'content-type': mimeType, Accept: mimeType };
	                        body = JSON.stringify(this.onBeforeUpdate(user));
	                        return [4 /*yield*/, this.fetch(this.currentUserUrl, { headers: headers, body: body, method: 'PUT' })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Sends an email message with a link allowing user to reset their password.
	     *
	     * @param {string} email The email address to send the message to.
	     * @param {string} tenantId The id of user's tenant (if cannot be inferred from URL).
	     *
	     * @returns Returns a request result object.
	     *
	     * @example
	     * ```typescript
	     *   const email = 'user@example.com';
	     *   const tenantId = 't123456';
	     *
	     *   (async () => {
	     *     const { res, data } = await userService.sendPasswordResetMail(email, tenantId);
	     *   })();
	     * ```
	     */
	    UserService.prototype.sendPasswordResetMail = function (email, tenantId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, method, url, params, body, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json', accept: 'application/json' };
	                        method = 'POST';
	                        url = this.passwordResetUrl;
	                        params = tenantId ? { tenantId: tenantId } : {};
	                        body = JSON.stringify({ email: email });
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method, params: params, body: body })];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    /**
	     * Resets user's password to a new one.
	     *
	     * @param {IResetPassword} newPassword Object with token, user's email, new password and its strength indicator.
	     * @param {string} tenantId The id of user's tenant (if cannot be inferred from URL).
	     *
	     * @returns Returns a request result object.
	     *
	     * @example
	     * ```typescript
	     *   const newPassword: IResetPassword = {
	     *     token: '123123ASDAWERER@#!WEDS$@#!WADA#A#EA#EA#EA',
	     *     email: 'user@example.com',
	     *     newPassword: 'myNewPassword',
	     *     passwordStrength: PasswordStrength.GREEN
	     *   };
	     *   const tenantId = 't123456';
	     *
	     *   (async () => {
	     *     const { res, data } = await userService.resetPassword(newPassword, tenantId);
	     *   })();
	     * ```
	     */
	    UserService.prototype.resetPassword = function (newPassword, tenantId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, method, url, params, body, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json', accept: 'application/json' };
	                        method = 'PUT';
	                        url = this.passwordResetUrl;
	                        params = tenantId ? { tenantId: tenantId } : {};
	                        body = JSON.stringify(newPassword);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method, params: params, body: body })];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    /**
	     * Verifies TFA code which is sent via SMS. If invoked with string '0', new TFA code will be sent.
	     *
	     * @param {string} pin The code to verify.
	     *
	     * @returns Returns a status object.
	     *
	     * @example
	     * ```typescript
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.verifyTFACode('123123');
	     *   })();
	     * ```
	     */
	    UserService.prototype.verifyTFACode = function (pin) {
	        return __awaiter(this, void 0, void 0, function () {
	            var method, body, headers, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'POST';
	                        body = JSON.stringify({ pin: pin });
	                        headers = { 'content-type': 'application/json', accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(this.verifyTFACodeUrl, { headers: headers, body: body, method: method })];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    /**
	     * Verifies TFA code which is generated by a TOTP app.
	     *
	     * @param {string} code The code to verify.
	     *
	     * @returns Returns a status object.
	     *
	     * @example
	     * ```typescript
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.verifyTotpCode('123123');
	     *   })();
	     * ```
	     */
	    UserService.prototype.verifyTotpCode = function (code) {
	        return __awaiter(this, void 0, void 0, function () {
	            var method, headers, body, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'POST';
	                        headers = { 'content-type': 'application/json' };
	                        body = JSON.stringify({ code: code });
	                        return [4 /*yield*/, this.fetch(this.verifyTOTPCodeUrl, { headers: headers, body: body, method: method })];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    /**
	     * Verifies TFA code which is generated by a TOTP app.
	     *
	     * @returns Returns a status object.
	     *
	     * @example
	     * ```typescript
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.activateTotp();
	     *   })();
	     * ```
	     */
	    UserService.prototype.activateTotp = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var method, headers, body, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'POST';
	                        headers = { 'content-type': 'application/json' };
	                        body = JSON.stringify({ isActive: true });
	                        return [4 /*yield*/, this.fetch(this.activateTOTPCodeUrl, { headers: headers, body: body, method: method })];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    /**
	     * Checks if TOTP is activated and enforced.
	     *
	     * @returns Returns an object of ITotpStatus if it is active.
	     *
	     * @example
	     * ```typescript
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.getActivityTotp();
	     *      console.log(data.isActive);
	     *   })();
	     * ```
	     */
	    UserService.prototype.getActivityTotp = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var method, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'GET';
	                        headers = { 'content-type': 'application/json' };
	                        return [4 /*yield*/, this.fetch(this.activateTOTPCodeUrl, { headers: headers, method: method })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Generates a secret which can be used to setup two-factor authentication with TOTP.
	     *
	     * @returns Returns the secret and an URL to a QR Code.
	     *
	     * @example
	     * ```typescript
	     *
	     *    (async () => {
	     *      const {data, res} = await userService.generateTotpSecret();
	     *      console.log(secret);
	     *   })();
	     * ```
	     */
	    UserService.prototype.generateTotpSecret = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var method, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'POST';
	                        headers = { 'content-type': 'application/json', accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(this.totpCurrentUserURL, { headers: headers, method: method })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Revokes a specific user's TOTP secret.
	     *
	     * @param {IUser} user User whose TOTP secret to revoke.
	     *
	     * @returns Status object
	     */
	    UserService.prototype.totpRevokeSecret = function (user) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, headers, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.getDetailUrl(user) + "/" + this.revokeTOTPSecretUrl;
	                        method = 'DELETE';
	                        headers = { accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method })];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    /**
	     * Update user phone number.
	     */
	    UserService.prototype.savePhoneNumber = function (phoneNumber) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, options, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = 'user/currentUserPhone';
	                        options = {
	                            method: 'PUT',
	                            headers: { 'content-type': 'application/json', accept: 'application/json' },
	                            body: JSON.stringify({
	                                phone: phoneNumber
	                            })
	                        };
	                        return [4 /*yield*/, this.client.fetch(url, options)];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res }];
	                }
	            });
	        });
	    };
	    UserService.prototype.hasRole = function (user, roleId) {
	        return this.hasRoleInUser(user, roleId) || this.hasRoleInGroups(user, roleId);
	    };
	    UserService.prototype.hasAllRoles = function (user, roleIds) {
	        var _this = this;
	        return roleIds.every(function (roleId) { return _this.hasRole(user, roleId); });
	    };
	    UserService.prototype.hasAnyRole = function (user, roleIds) {
	        var _this = this;
	        return roleIds.some(function (roleId) { return _this.hasRole(user, roleId); });
	    };
	    UserService.prototype.onBeforeUpdate = function (user) {
	        var obj = Object.assign({}, user);
	        delete obj.id;
	        delete obj.userName;
	        return obj;
	    };
	    UserService.prototype.getDetailUrl = function (entityOrId) {
	        var id;
	        if (typeof entityOrId === 'object' && entityOrId.id) {
	            id = entityOrId.id;
	        }
	        else if (typeof entityOrId === 'object' && entityOrId.userName) {
	            id = entityOrId.userName;
	        }
	        else {
	            id = entityOrId;
	        }
	        return this.listUrl + "/" + encodeURIComponent(String(id));
	    };
	    UserService.prototype.hasRoleInUser = function (user, roleId) {
	        var effectiveRoles = user.effectiveRoles || [];
	        return (this.hasRoleInReferences((user && user.roles && user.roles.references) || [], roleId) ||
	            effectiveRoles.some(function (_a) {
	                var id = _a.id;
	                return roleId === id;
	            }));
	    };
	    UserService.prototype.hasRoleInGroups = function (user, roleId) {
	        var _this = this;
	        var groupReferences = (user && user.groups && user.groups.references) || [];
	        return groupReferences.some(function (groupRef) {
	            return _this.hasRoleInReferences(groupRef.group.roles.references, roleId);
	        });
	    };
	    UserService.prototype.hasRoleInReferences = function (references, roleId) {
	        return references.some(function (ref) { return ref.role.id === roleId; });
	    };
	    return UserService;
	}(core.Service));
	exports.UserService = UserService;

	});

	unwrapExports(UserService_1);
	UserService_1.UserService;

	var PasswordStrength_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (PasswordStrength) {
	    PasswordStrength["GREEN"] = "GREEN";
	    PasswordStrength["RED"] = "RED";
	    PasswordStrength["YELLOW"] = "YELLOW";
	})(exports.PasswordStrength || (exports.PasswordStrength = {}));

	});

	unwrapExports(PasswordStrength_1);
	PasswordStrength_1.PasswordStrength;

	var user = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(UserService_1);
	__export(UserInventoryRoleService_1);
	__export(PasswordStrength_1);

	});

	unwrapExports(user);

	var ApplicationBinaryService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	var form_data_1 = __importDefault(browser$1);
	var ApplicationBinaryService = /** @class */ (function (_super) {
	    __extends(ApplicationBinaryService, _super);
	    function ApplicationBinaryService(client, applicationOrId) {
	        var _this = _super.call(this, client) || this;
	        _this.listUrl = 'binaries';
	        _this.propertyName = 'attachments';
	        _this.baseUrl = "application/applications/" + _this.getIdString(applicationOrId);
	        return _this;
	    }
	    ApplicationBinaryService.prototype.upload = function (binary, fileName) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, bufferOrStream, uploadFileName, bodyHeaders, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.listUrl;
	                        method = 'POST';
	                        body = new form_data_1.default();
	                        bufferOrStream = binary instanceof ArrayBuffer ? Buffer.from(binary) : binary;
	                        uploadFileName = fileName;
	                        if (typeof (File) !== 'undefined' && binary instanceof File) {
	                            uploadFileName = binary.name;
	                        }
	                        body.append('file', bufferOrStream, uploadFileName);
	                        body.append('fileName', uploadFileName);
	                        if (typeof body.getHeaders === 'function') {
	                            bodyHeaders = body.getHeaders();
	                        }
	                        headers = Object.assign({
	                            accept: 'application/json'
	                        }, bodyHeaders);
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    ApplicationBinaryService.prototype.list = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this)];
	            });
	        });
	    };
	    ApplicationBinaryService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    ApplicationBinaryService.prototype.delete = function (binaryOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, binaryOrId)];
	            });
	        });
	    };
	    ApplicationBinaryService.prototype.listPlugins = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, url, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { accept: 'application/json' };
	                        url = this.listUrl + "/plugins";
	                        return [4 /*yield*/, this.fetch(url, { headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    ApplicationBinaryService.prototype.addPlugin = function (pluginName, pluginFile) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, bufferOrStream, bodyHeaders, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.listUrl + "/plugins/" + encodeURIComponent(pluginName);
	                        method = 'POST';
	                        body = new form_data_1.default();
	                        bufferOrStream = pluginFile instanceof ArrayBuffer ? Buffer.from(pluginFile) : pluginFile;
	                        body.append('file', bufferOrStream);
	                        if (typeof body.getHeaders === 'function') {
	                            bodyHeaders = body.getHeaders();
	                        }
	                        headers = Object.assign({
	                            accept: 'application/json'
	                        }, bodyHeaders);
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    ApplicationBinaryService.prototype.removePlugin = function (pluginName) {
	        return __awaiter(this, void 0, void 0, function () {
	            var method, headers, url, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        method = 'DELETE';
	                        headers = { accept: 'application/json' };
	                        url = this.listUrl + "/plugins/" + pluginName;
	                        return [4 /*yield*/, this.fetch(url, { method: method, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    ApplicationBinaryService.prototype.updateFiles = function (files) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, bodyHeaders, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.listUrl + "/files";
	                        method = 'POST';
	                        body = new form_data_1.default();
	                        files.forEach(function (file) {
	                            var bufferOrStream = file.contents instanceof ArrayBuffer ? Buffer.from(file.contents) : file.contents;
	                            body.append(file.path, bufferOrStream);
	                        });
	                        if (typeof body.getHeaders === 'function') {
	                            bodyHeaders = body.getHeaders();
	                        }
	                        headers = Object.assign({
	                            accept: 'application/json'
	                        }, bodyHeaders);
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    return ApplicationBinaryService;
	}(core.Service));
	exports.ApplicationBinaryService = ApplicationBinaryService;

	});

	unwrapExports(ApplicationBinaryService_1);
	ApplicationBinaryService_1.ApplicationBinaryService;

	var ApplicationType_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (ApplicationType) {
	    ApplicationType["EXTERNAL"] = "EXTERNAL";
	    ApplicationType["HOSTED"] = "HOSTED";
	    ApplicationType["MICROSERVICE"] = "MICROSERVICE";
	    ApplicationType["FEATURE"] = "FEATURE";
	})(exports.ApplicationType || (exports.ApplicationType = {}));

	});

	unwrapExports(ApplicationType_1);
	ApplicationType_1.ApplicationType;

	var ApplicationService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });





	var ApplicationService = /** @class */ (function (_super) {
	    __extends(ApplicationService, _super);
	    function ApplicationService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'application';
	        _this.listUrl = 'applications';
	        _this.propertyName = 'applications';
	        _this.channel = '/applications/*';
	        return _this;
	    }
	    /**
	     * Creates a new application.
	     *
	     * @param {IIdentified} entity Application object.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const newApp = {
	     *    name: 'New application',
	     *    type: 'EXTERNAL',
	     *    key: 'new-app'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await applicationService.create(newApp);
	     *  })();
	     * ```
	     */
	    ApplicationService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    ApplicationService.prototype.clone = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.getDetailUrl(entity) + "/clone";
	                        method = 'POST';
	                        body = '';
	                        headers = { 'content-type': 'application/json', accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Gets the list of existing applications filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying applications.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await applicationService.list(filter);
	     *   })();
	     * ```
	     */
	    ApplicationService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as [[ObservableList]]
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = alarmService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    ApplicationService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Gets the details of selected application.
	     *
	     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const applicationId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await applicationService.detail(applicationId);
	     *   })();
	     * ```
	     */
	    ApplicationService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Updates existing application.
	     * Make sure that you specifiy the application id within the update object.
	     *
	     * @param {IIdentified} entity Application object.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const updateApp = {
	     *    id: 38
	     *    name: 'Updated application'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await applicationService.update(updateApp);
	     *  })();
	     * ```
	     */
	    ApplicationService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Removes an application with given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | number | IIdentified} entityOrId entity or id of the application.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const removeApp: object = {
	     *     id: 38
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res} = await applicationService.delete(removeApp);
	     *     // data will be null
	     *   })();
	     * ```
	     */
	    ApplicationService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    ApplicationService.prototype.listByName = function (name) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, url, res, json, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json' };
	                        url = "applicationsByName/" + encodeURIComponent(name);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        json = _a.sent();
	                        data = json[this.propertyName];
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    ApplicationService.prototype.listByTenant = function (tenantOrName, params) {
	        if (params === void 0) { params = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, tenantService, tenantName, _a, _b, url, res, json, data;
	            return __generator(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json' };
	                        tenantService = new tenant.TenantService(this.client);
	                        _a = this.getIdString;
	                        _b = tenantOrName;
	                        if (_b) return [3 /*break*/, 2];
	                        return [4 /*yield*/, tenantService.current()];
	                    case 1:
	                        _b = (_c.sent()).data.name;
	                        _c.label = 2;
	                    case 2:
	                        tenantName = _a.apply(this, [_b]);
	                        url = "applicationsByTenant/" + encodeURIComponent(tenantName);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: params })];
	                    case 3:
	                        res = _c.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 4:
	                        json = _c.sent();
	                        data = json[this.propertyName];
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    ApplicationService.prototype.listByOwner = function (tenantOrName, params) {
	        if (params === void 0) { params = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, tenantService, tenantName, _a, _b, url, res, json, data;
	            return __generator(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json' };
	                        tenantService = new tenant.TenantService(this.client);
	                        _a = this.getIdString;
	                        _b = tenantOrName;
	                        if (_b) return [3 /*break*/, 2];
	                        return [4 /*yield*/, tenantService.current()];
	                    case 1:
	                        _b = (_c.sent()).data.name;
	                        _c.label = 2;
	                    case 2:
	                        tenantName = _a.apply(this, [_b]);
	                        url = "applicationsByOwner/" + encodeURIComponent(tenantName);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: params })];
	                    case 3:
	                        res = _c.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 4:
	                        json = _c.sent();
	                        data = json[this.propertyName];
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    ApplicationService.prototype.listByUser = function (userOrId, params) {
	        if (params === void 0) { params = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, userService, userId, _a, _b, url, res, json, data;
	            return __generator(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json' };
	                        userService = new user.UserService(this.client);
	                        _a = this.getIdString;
	                        _b = userOrId;
	                        if (_b) return [3 /*break*/, 2];
	                        return [4 /*yield*/, userService.current()];
	                    case 1:
	                        _b = (_c.sent()).data;
	                        _c.label = 2;
	                    case 2:
	                        userId = _a.apply(this, [_b]);
	                        url = "applicationsByUser/" + encodeURIComponent(userId);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: params })];
	                    case 3:
	                        res = _c.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 4:
	                        json = _c.sent();
	                        data = json[this.propertyName];
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    ApplicationService.prototype.binary = function (application) {
	        return new ApplicationBinaryService_1.ApplicationBinaryService(this.client, application);
	    };
	    ApplicationService.prototype.getHref = function (application) {
	        if (application.type === ApplicationType_1.ApplicationType.EXTERNAL) {
	            return application.externalUrl;
	        }
	        return "/apps/" + (application.public ? 'public/' : '') + application.contextPath;
	    };
	    /**
	     * Checks if current user can access specified application.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | IApplication} application Application name or contextPath as a
	     * string or Application object.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const checkApp: object = {
	     *    name: 'myApplication'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await applicationService.isAvailable(checkApp);
	     *  })();
	     * ```
	     */
	    ApplicationService.prototype.isAvailable = function (application) {
	        return __awaiter(this, void 0, void 0, function () {
	            var _a, res, data, available;
	            var _this = this;
	            return __generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0: return [4 /*yield*/, this.listByUser(undefined, {
	                            dropOverwrittenApps: true,
	                            noPaging: true
	                        })];
	                    case 1:
	                        _a = _b.sent(), res = _a.res, data = _a.data;
	                        available = (data || []).some(function (availableApp) {
	                            return typeof application === 'string'
	                                ? availableApp.name === application || availableApp.contextPath === application
	                                : _this.isMatch(availableApp, application);
	                        });
	                        return [2 /*return*/, { data: available, res: res }];
	                }
	            });
	        });
	    };
	    ApplicationService.prototype.isMatch = function (object, source) {
	        var _this = this;
	        return Object.keys(source).every(function (key) {
	            if (Array.isArray(object[key]) && Array.isArray(source[key])) {
	                return source[key].every(function (el) { return object[key].includes(el); });
	            }
	            else if (typeof object[key] === 'object' &&
	                object[key] !== null &&
	                typeof source[key] === 'object' &&
	                source[key] !== null) {
	                return _this.isMatch(object[key], source[key]);
	            }
	            else {
	                return object[key] === source[key];
	            }
	        });
	    };
	    return ApplicationService;
	}(core.Service));
	exports.ApplicationService = ApplicationService;

	});

	unwrapExports(ApplicationService_1);
	ApplicationService_1.ApplicationService;

	var ApplicationAvailability_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (ApplicationAvailability) {
	    ApplicationAvailability["MARKET"] = "MARKET";
	    ApplicationAvailability["PRIVATE"] = "PRIVATE";
	})(exports.ApplicationAvailability || (exports.ApplicationAvailability = {}));

	});

	unwrapExports(ApplicationAvailability_1);
	ApplicationAvailability_1.ApplicationAvailability;

	var application = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(ApplicationService_1);
	__export(ApplicationType_1);
	__export(ApplicationAvailability_1);

	});

	unwrapExports(application);

	var SystemOptionsService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	var SystemOptionsService = /** @class */ (function (_super) {
	    __extends(SystemOptionsService, _super);
	    function SystemOptionsService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'tenant/system';
	        _this.listUrl = 'options';
	        _this.propertyName = 'options';
	        return _this;
	    }
	    /**
	     * Gets the details of given system option.
	     *
	     * @param {string|number|IIdentified} option System option object with mandantory fragments.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const option: ISystemOption = {
	     *      category: 'alarm.type.mapping',
	     *      key: 'temp_to_high'
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res} = await systemOptionsService.detail(option);
	     *   })();
	     * ```
	     */
	    SystemOptionsService.prototype.detail = function (option) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, option)];
	            });
	        });
	    };
	    /**
	     * Gets the list of system options filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying system options.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await systemOptionsService.list(filter);
	     *   })();
	     * ```
	     */
	    SystemOptionsService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, url, res, json, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json' };
	                        url = this.listUrl;
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, params: filter })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        json = _a.sent();
	                        data = json[this.propertyName];
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    SystemOptionsService.prototype.getDetailUrl = function (option) {
	        return this.listUrl + "/" + option.category + "/" + option.key;
	    };
	    SystemOptionsService.prototype.onBeforeCreate = function (obj) {
	        return obj;
	    };
	    return SystemOptionsService;
	}(core.Service));
	exports.SystemOptionsService = SystemOptionsService;

	});

	unwrapExports(SystemOptionsService_1);
	SystemOptionsService_1.SystemOptionsService;

	var systemOptions = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(SystemOptionsService_1);

	});

	unwrapExports(systemOptions);

	var TenantOptionsService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * @description
	 * This service allows for managing tenant's options.
	 */
	var TenantOptionsService = /** @class */ (function (_super) {
	    __extends(TenantOptionsService, _super);
	    function TenantOptionsService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'tenant';
	        _this.listUrl = 'options';
	        _this.propertyName = 'options';
	        _this.securityOptionsCategories = ['password'];
	        _this.securityOptionsListUrl = 'security-options';
	        _this.systemOptions = 'system';
	        return _this;
	    }
	    /**
	     * Get a representation of a tenant's option.
	     *
	     * @param {ITenantOption} entity Tenant option object.
	     *
	     * @returns {IResult<ITenantOption>} Returns promise object that is resolved with
	     * the ITenantOption wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const option: ITenantOption = {
	     *      category: 'access.control',
	     *      key: 'allow.origin'
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res} = await tenantService.detail(option);
	     *   })();
	     * ```
	     *
	     * Required role: ROLE_OPTION_MANAGEMENT_READ
	     */
	    TenantOptionsService.prototype.detail = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Creates a new tenant's option.
	     *
	     * @param {ITenantOption} entity Tenant's Option object.
	     *
	     * @returns {IResult<IIdentified>} Returns promise object that is resolved with
	     * the details of newly created tenant option.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const tenantObject = {
	     *    id: "sample_tenant",
	     *    company: "sample_company",
	     *    domain: "sample_domain.com",
	     *    contactName: "Mr. Doe",
	     *    ...
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await tenantService.create(tenantObject);
	     *  })();
	     * ```
	     *
	     * Required role: ROLE_OPTION_MANAGEMENT_ADMIN<br><br>
	     * Options are category-key-value tuples, storing tenant configuration.Some categories of options
	     * allow creation of new one, other are limited to predefined set of keys.<br><br>
	     * Any option of any tenant can be defined as "non-editable" by "management" tenant. Afterwards, any PUT or DELETE
	     * requests made on that option by the owner tenant, will result in 403 error (Unauthorized).
	     */
	    TenantOptionsService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates tenant's option data.
	     *
	     * @param {ITenantOption} entity Tenant option is partially updatable.
	     *
	     * @returns {IResult<ITenantOption>} Returns promise object that is resolved with the saved tenant option object.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialUpdateObject: IIdentified = {
	     *     value : "http://developer.cumulocity.com"
	     *     ...
	     *   }
	     *
	     *  (async () => {
	     *    const {data, res} = await tenantOptionsService.update(partialUpdateObject);
	     *  })();
	     * ```
	     *
	     * Required role: ROLE_OPTION_MANAGEMENT_ADMIN
	     */
	    TenantOptionsService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of tenant's options filtered by parameters.
	     *
	     * @param {object} filter Object containing filters for querying tenant options.
	     *
	     * @returns {IResultList<ITenantOption>} Returns promise object that is resolved
	     * with the ITenantOption wrapped by IResultList.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     severity: Severity.MAJOR,
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await tenantOptionsService.list(filter);
	     *   })();
	     * ```
	     *
	     * Required role: ROLE_OPTION_MANAGEMENT_READ
	     */
	    TenantOptionsService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = tenantOptionsService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    TenantOptionsService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Delete a representation of a tenant's option.
	     *
	     * @param {string|number|IIdentified} entityOrId Tenant's option id or tenant's option object.
	     *
	     * @returns Returns promise object that is resolved with the IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const tenantOptionId: string = "uniqueTenantId";
	     *
	     *    (async () => {
	     *      const {data, res} = await tenantOptionsService.delete(tenantOptionId);
	     *   })();
	     * ```
	     *
	     * Required role: ROLE_TENANT_MANAGEMENT_ADMIN
	     */
	    TenantOptionsService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    TenantOptionsService.prototype.getDetailUrl = function (entity) {
	        if (this.securityOptionsCategories.indexOf(entity.category) > -1) {
	            return this.securityOptionsListUrl + "/" + entity.category + "/" + entity.key;
	        }
	        else {
	            return this.listUrl + "/" + entity.category + "/" + entity.key;
	        }
	    };
	    TenantOptionsService.prototype.onBeforeCreate = function (obj) {
	        return obj;
	    };
	    return TenantOptionsService;
	}(core.Service));
	exports.TenantOptionsService = TenantOptionsService;

	});

	unwrapExports(TenantOptionsService_1);
	TenantOptionsService_1.TenantOptionsService;

	var tenantOptions = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(TenantOptionsService_1);

	});

	unwrapExports(tenantOptions);

	var TenantSecurityOptionsService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * @description
	 * This service allows to get tenant security option.
	 */
	var TenantSecurityOptionsService = /** @class */ (function (_super) {
	    __extends(TenantSecurityOptionsService, _super);
	    function TenantSecurityOptionsService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'tenant';
	        _this.listUrl = 'security-options';
	        _this.category = 'password';
	        _this.propertyName = 'options';
	        return _this;
	    }
	    /**
	     * Get a specific tenant's security option.
	     *
	     * @param {ITenantSecurityOption} Tenant's security option object with key value.
	     *
	     * @returns Returns promise object that is resolved with the ITenantSecurityOption wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *     const option: ITenantSecurityOption = {
	     *        key: 'limit.validity'
	     *      };
	     *
	     *    (async () => {
	     *      const {data, res} = await tenantSecurityOptionsService.detail(option);
	     *   })();
	     * ```
	     */
	    TenantSecurityOptionsService.prototype.detail = function (tenantSecurityOption) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, tenantSecurityOption)];
	            });
	        });
	    };
	    TenantSecurityOptionsService.prototype.getDetailUrl = function (tenantSecurityOption) {
	        return this.listUrl + "/" + this.category + "/" + tenantSecurityOption.key;
	    };
	    TenantSecurityOptionsService.prototype.onBeforeCreate = function (obj) {
	        return obj;
	    };
	    return TenantSecurityOptionsService;
	}(core.Service));
	exports.TenantSecurityOptionsService = TenantSecurityOptionsService;

	});

	unwrapExports(TenantSecurityOptionsService_1);
	TenantSecurityOptionsService_1.TenantSecurityOptionsService;

	var tenantSecurityOptions = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(TenantSecurityOptionsService_1);

	});

	unwrapExports(tenantSecurityOptions);

	var TenantLoginOptionsService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * @description
	 * This service allows to get tenant login options.
	 */
	var TenantLoginOptionsService = /** @class */ (function (_super) {
	    __extends(TenantLoginOptionsService, _super);
	    function TenantLoginOptionsService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'tenant';
	        _this.loginOptionsUrl = 'loginOptions';
	        return _this;
	    }
	    /**
	     * Gets the tenant's login options.
	     *
	     * @example
	     * ```typescript
	     *
	     *    (async () => {
	     *      const {data, res} = await tenantLoginOptionsService.detail();
	     *   })();
	     * ```
	     */
	    TenantLoginOptionsService.prototype.detail = function () {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.loginOptionsUrl;
	                        if (this.client.tenant) {
	                            url = this.loginOptionsUrl + "?tenantId=" + this.client.tenant;
	                        }
	                        return [4 /*yield*/, this.fetch(url)];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    return TenantLoginOptionsService;
	}(core.Service));
	exports.TenantLoginOptionsService = TenantLoginOptionsService;

	});

	unwrapExports(TenantLoginOptionsService_1);
	TenantLoginOptionsService_1.TenantLoginOptionsService;

	var tenantLoginOptions = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(TenantLoginOptionsService_1);

	});

	unwrapExports(tenantLoginOptions);

	var AuditService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	var AuditService = /** @class */ (function (_super) {
	    __extends(AuditService, _super);
	    function AuditService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'audit';
	        _this.listUrl = 'auditRecords';
	        _this.propertyName = 'auditRecords';
	        return _this;
	    }
	    /**
	     * Gets the details of selected audit record.
	     *
	     * @param {string|number|IAuditRecord} entityOrId Entity or Id of the entity.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const auditId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await auditService.detail(auditId);
	     *   })();
	     * ```
	     */
	    AuditService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new audit record for a given source.
	     *
	     * @param {IAuditRecord} entity Audit record object with mandantory fragments.
	     * IAuditRecord implements the [[IEvent]] interface.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const mandantoryObject: IAuditRecord = {
	     *    type: AuditRecordType.ALARM,
	     *    time: '2018-05-02T10:08:00Z',
	     *    severity: Severity.MAJOR,
	     *    source: {id: 1}
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await auditService.create(mandantoryObject);
	     *  })();
	     * ```
	     */
	    AuditService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of audit records filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying audit records.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     severity: Severity.MAJOR,
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await auditService.list(filter);
	     *   })();
	     * ```
	     */
	    AuditService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = auditService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    AuditService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    return AuditService;
	}(core.Service));
	exports.AuditService = AuditService;

	});

	unwrapExports(AuditService_1);
	AuditService_1.AuditService;

	var AuditRecordType_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (AuditRecordType) {
	    AuditRecordType["ALARM"] = "Alarm";
	    AuditRecordType["CEP_MODULE"] = "CepModule";
	    AuditRecordType["EVENT"] = "Event";
	    AuditRecordType["INVENTORY"] = "Inventory";
	    AuditRecordType["INVENTORY_ROLE"] = "InventoryRole";
	    AuditRecordType["OPERATION"] = "Operation";
	    AuditRecordType["OPTION"] = "Option";
	    AuditRecordType["GROUP"] = "Group";
	    AuditRecordType["SMART_RULE"] = "SmartRule";
	    AuditRecordType["SYSTEM"] = "SYSTEM";
	    AuditRecordType["TENANT"] = "Tenant";
	    AuditRecordType["USER"] = "User";
	})(exports.AuditRecordType || (exports.AuditRecordType = {}));

	});

	unwrapExports(AuditRecordType_1);
	AuditRecordType_1.AuditRecordType;

	var ChangeType_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (ChangeType) {
	    ChangeType["ADDED"] = "ADDED";
	    ChangeType["REPLACED"] = "REPLACED";
	    ChangeType["REMOVED"] = "REMOVED";
	})(exports.ChangeType || (exports.ChangeType = {}));

	});

	unwrapExports(ChangeType_1);
	ChangeType_1.ChangeType;

	var audit$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(AuditService_1);
	__export(AuditRecordType_1);
	__export(ChangeType_1);

	});

	unwrapExports(audit$1);

	var InventoryRoleService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	var InventoryRoleService = /** @class */ (function (_super) {
	    __extends(InventoryRoleService, _super);
	    function InventoryRoleService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'user';
	        _this.listUrl = 'inventoryroles';
	        _this.propertyName = 'roles';
	        return _this;
	    }
	    /**
	     * Gets the details of inventory role.
	     *
	     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const inventoryRoleId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await inventoryRoleService.detail(inventoryRoleId);
	     *   })();
	     * ```
	     */
	    InventoryRoleService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new inventory role.
	     *
	     * @param {IIdentified} entity
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const newRole: IIdentified = {
	     *    name: 'Custom role'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await inventoryRoleService.create(newRole);
	     *  })();
	     * ```
	     */
	    InventoryRoleService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates inventory role data.
	     *
	     * @param {IIdentified} entity
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const updateObject: IIdentified = {
	     *    id: 1,
	     *    name: 'changed role'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await inventoryRoleService.update(updateObject);
	     *  })();
	     * ```
	     */
	    InventoryRoleService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of inventory roles filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying alarms.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await inventoryRoleService.list(filter);
	     *   })();
	     * ```
	     */
	    InventoryRoleService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = inventoryRoleService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    InventoryRoleService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Removes an inventory role with given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IExternalIdentity} identity Identity object with mandantory fragments.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const id: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await identityService.delete(id);
	     *   })();
	     * ```
	     */
	    InventoryRoleService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    return InventoryRoleService;
	}(core.Service));
	exports.InventoryRoleService = InventoryRoleService;

	});

	unwrapExports(InventoryRoleService_1);
	InventoryRoleService_1.InventoryRoleService;

	var inventoryRole = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(InventoryRoleService_1);

	});

	unwrapExports(inventoryRole);

	var DeviceRegistrationStatus_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	(function (DeviceRegistrationStatus) {
	    DeviceRegistrationStatus["WAITING_FOR_CONNECTION"] = "WAITING_FOR_CONNECTION";
	    DeviceRegistrationStatus["PENDING_ACCEPTANCE"] = "PENDING_ACCEPTANCE";
	    DeviceRegistrationStatus["ACCEPTED"] = "ACCEPTED";
	})(exports.DeviceRegistrationStatus || (exports.DeviceRegistrationStatus = {}));

	});

	unwrapExports(DeviceRegistrationStatus_1);
	DeviceRegistrationStatus_1.DeviceRegistrationStatus;

	var DeviceRegistrationService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });



	/**
	 * This class allows registration of a new device.
	 */
	var DeviceRegistrationService = /** @class */ (function (_super) {
	    __extends(DeviceRegistrationService, _super);
	    function DeviceRegistrationService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'devicecontrol';
	        _this.listUrl = 'newDeviceRequests';
	        _this.propertyName = 'newDeviceRequests';
	        return _this;
	    }
	    /**
	     * Gets the details of device registration.
	     *
	     * @param {string|number|IIdentified} entityOrId Entity or Id of the entity.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const entityId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await deviceRegistrationService.detail(entityId);
	     *    })();
	     * ```
	     */
	    DeviceRegistrationService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new device registration.
	     *
	     * @param {IDeviceRegistrationCreate} entity Device registration object with mandantory fragments.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const mandantoryObject: IDeviceRegistrationCreate = {
	     *      id: 1,
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res} = await deviceRegistrationService.create(mandantoryObject);
	     *    })();
	     * ```
	     */
	    DeviceRegistrationService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of device registrations by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying registrations.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await deviceRegistrationService.list(filter);
	     *   })();
	     * ```
	     */
	    DeviceRegistrationService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = deviceRegistrationService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    DeviceRegistrationService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Removes an registration with given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | number | IIdentified} entityOrId entity or id of the registration.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const id = 'abc';
	     *
	     *   (async () => {
	     *     const {data, res} = await deviceRegistrationService.delete(id);
	     *     // data will be null
	     *   })();
	     * ```
	     */
	    DeviceRegistrationService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Accepts the device registration for given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | number | IIdentified} entityOrId entity or id of registration.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const id = 'abc';
	     *
	     *   (async () => {
	     *     const {data, res} = await deviceRegistrationService.accept(id);
	     *   })();
	     * ```
	     */
	    DeviceRegistrationService.prototype.accept = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var id, update;
	            return __generator(this, function (_a) {
	                id = this.getIdString(entityOrId);
	                update = Object.getPrototypeOf(this).update.bind(this);
	                return [2 /*return*/, update({ id: id, status: DeviceRegistrationStatus_1.DeviceRegistrationStatus.ACCEPTED })];
	            });
	        });
	    };
	    /**
	     * Bootstraps the device with given id.
	     *
	     * @param entityOrId entity or id of registration.
	     * @param options for details see [[IDeviceBootstrapOptions]]
	     *
	     * @example
	     * ```typescript
	     *
	     *   const id: 'abc';
	     *   const options: IDeviceBootstrapOptions = {
	     *     basicAuthToken: 'Basic dGVuYW50L3VzZXJuYW1lOnBhc3N3b3Jk',
	     *     basicAuth: {
	     *       user: 'username',
	     *       pass: 'password'
	     *     }
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res} = await deviceRegistrationService.bootstrap(id, options);
	     *   })();
	     * ```
	     */
	    DeviceRegistrationService.prototype.bootstrap = function (entityOrId, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var id, body, url, basicAuth, basicAuthToken, user, pass, headers, method, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        id = this.getIdString(entityOrId);
	                        body = JSON.stringify({ id: id });
	                        url = this.baseUrl + "/deviceCredentials";
	                        basicAuth = options.basicAuth;
	                        basicAuthToken = options.basicAuthToken;
	                        if (basicAuth) {
	                            user = basicAuth.user, pass = basicAuth.pass;
	                            basicAuthToken = b2a_1.btoa(user + ":" + pass);
	                        }
	                        headers = {
	                            Authorization: "Basic " + basicAuthToken,
	                            accept: 'application/json',
	                            'content-type': 'application/json',
	                        };
	                        method = 'POST';
	                        return [4 /*yield*/, this.client.fetch(url, { body: body, headers: headers, method: method })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        if (res.status > 400) {
	                            throw { res: res, data: data };
	                        }
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    DeviceRegistrationService.prototype.onBeforeCreate = function (entity) {
	        return entity;
	    };
	    DeviceRegistrationService.prototype.onBeforeUpdate = function (entity) {
	        var noIdEntity = Object.assign({}, entity);
	        delete noIdEntity.id;
	        return noIdEntity;
	    };
	    return DeviceRegistrationService;
	}(core.Service));
	exports.DeviceRegistrationService = DeviceRegistrationService;

	});

	unwrapExports(DeviceRegistrationService_1);
	DeviceRegistrationService_1.DeviceRegistrationService;

	var DeviceRegistrationBulkService_1 = createCommonjsModule(function (module, exports) {
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var form_data_1 = __importDefault(browser$1);
	/**
	 * This class allows for bulk registering devices.
	 */
	var DeviceRegistrationBulkService = /** @class */ (function () {
	    /**
	     * Instantiate class and assign client
	     * @param {IFetchClient} client
	     */
	    function DeviceRegistrationBulkService(client) {
	        this.client = client;
	    }
	    /**
	     * A new device registration as bulk.
	     *
	     * @param {Stream | Buffer} csv
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const csvString = `
	     *  ID,CREDENTIALS,TENANT,TYPE,NAME,ICCID,IDTYPE,PATH,SHELL
	     *  e2eDeviceRegistrationId,e2epassword123!,e2edocker,c8y_e2eDevice,e2eDevice,123456789,89456,e2eDeviceGroup,1
	     *  900001,e2epassword123!,e2edocker,c8y_e2eDevice1,e2eDevice1,123456789,89456,e2eDeviceGroup,1
	     *  900002,e2epassword123!,e2edocker,c8y_e2eDevice2,e2eDevice2,123456789,89456,e2eDeviceGroup,1`.trim();
	     *
	     *  const csvBuffer = Buffer.from(csvString):
	     *
	     *  (async () => {
	     *    const {data, res} = await deviceRegistrationBulkService.create(csvBuffer);
	     *  })();
	     * ```
	     */
	    DeviceRegistrationBulkService.prototype.create = function (csv) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, fileName, bodyHeaders, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = '/devicecontrol/bulkNewDeviceRequests';
	                        method = 'POST';
	                        body = new form_data_1.default();
	                        fileName = 'bulk-registration.csv';
	                        if (typeof (File) !== 'undefined' && csv instanceof File) {
	                            fileName = csv.name;
	                        }
	                        body.append('file', csv, fileName);
	                        if (typeof body.getHeaders === 'function') {
	                            bodyHeaders = body.getHeaders();
	                        }
	                        headers = Object.assign({
	                            accept: 'application/json'
	                        }, bodyHeaders);
	                        return [4 /*yield*/, this.client.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    return DeviceRegistrationBulkService;
	}());
	exports.DeviceRegistrationBulkService = DeviceRegistrationBulkService;

	});

	unwrapExports(DeviceRegistrationBulkService_1);
	DeviceRegistrationBulkService_1.DeviceRegistrationBulkService;

	var deviceRegistration = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(DeviceRegistrationService_1);
	__export(DeviceRegistrationBulkService_1);
	__export(DeviceRegistrationStatus_1);

	});

	unwrapExports(deviceRegistration);

	var UserRoleService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * @description
	 * This service allows for fetch user roles.
	 */
	var UserRoleService = /** @class */ (function (_super) {
	    __extends(UserRoleService, _super);
	    function UserRoleService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'user';
	        _this.listUrl = 'roles';
	        _this.propertyName = 'roles';
	        return _this;
	    }
	    /**
	     * Gets the details of given role.
	     *
	     * @param {string|number|IRole} entityOrId Roles's id or role object.
	     *
	     * @returns Returns promise object that is resolved with the IRole wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const roleId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await userRoleService.detail(roleId);
	     *   })();
	     * ```
	     */
	    UserRoleService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Gets the list of user roles filtered by parameters.
	     *
	     * @param {object} filter Object containing filters for querying roles.
	     *
	     * @returns Returns promise object that is resolved with the IRole wrapped by IResultList.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     severity: Severity.MAJOR,
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await userRoleService.list(filter);
	     *   })();
	     * ```
	     */
	    UserRoleService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = userRoleService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    UserRoleService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    return UserRoleService;
	}(core.Service));
	exports.UserRoleService = UserRoleService;

	});

	unwrapExports(UserRoleService_1);
	UserRoleService_1.UserRoleService;

	var userRole = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(UserRoleService_1);

	});

	unwrapExports(userRole);

	var UserGroupService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	var ChildType;
	(function (ChildType) {
	    ChildType["ROLES"] = "roles";
	    ChildType["USERS"] = "users";
	})(ChildType || (ChildType = {}));
	/**
	 * @description
	 * This service allows for managing user groups.
	 */
	var UserGroupService = /** @class */ (function (_super) {
	    __extends(UserGroupService, _super);
	    function UserGroupService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.baseUrl = 'user';
	        _this.propertyName = 'groups';
	        return _this;
	    }
	    Object.defineProperty(UserGroupService.prototype, "listUrl", {
	        get: function () {
	            return this.client.tenant + "/groups";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Gets the details of given user group.
	     *
	     * @param {string|number|IUserGroup} entityOrId Group's id or role object.
	     *
	     * @returns Returns promise object that is resolved with the IUserGroup wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const groupId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await userGroupService.detail(roleId);
	     *   })();
	     * ```
	     */
	    UserGroupService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Creates a new user group.
	     *
	     * @param {IUserGroup} entity User Group object.
	     *
	     * @returns {IResult<IUserGroup>} Returns promise object that is resolved with
	     * the details of newly created user group.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const userGroupObject: IUserGroup = {
	     *    name: "new user group"
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await userGroupService.create(userGroupObject);
	     *  })();
	     * ```
	     */
	    UserGroupService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Updates user group data.
	     *
	     * @param {Partial<IUserGroup>} entity User group is partially updatable.
	     *
	     * @returns {IResult<IUserGroup>} Returns promise object that is resolved with the saved user group object.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const partialUpdateObject: Partial<IUserGroup> = {
	     *     "id" : 1,
	     *     "self" : "[URL to this resource]",
	     *     "name" : "PlatformAdministrators",
	     *     ...
	     *   }
	     *
	     *  (async () => {
	     *    const {data, res} = await userGroupService.update(partialUpdateObject);
	     *  })();
	     * ```
	     */
	    UserGroupService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Gets the list of user groups filtered by parameters.
	     *
	     * @param {object} filter Object containing filters for querying User Groups.
	     *
	     * @returns Returns promise object that is resolved with the IUserGroup wrapped by IResultList.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     severity: Severity.MAJOR,
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await userGroupService.list(filter);
	     *   })();
	     * ```
	     */
	    UserGroupService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets a list as observable.
	     *
	     * @param {object} filter Object containing filters for querying
	     * @param {object} options To configure the observable
	     *
	     * @returns Data wrapped as Observable.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const list$ = userGroupService.list$();
	     *   list$.subscribe((data) => console.log(data));
	     * ```
	     *
	     * @deprecated This function will be removed soon in favor of decoupling
	     * this library from rxjs. Use [[Realtime]] for realtime connection and
	     * rxjs `defer()` or `from()` to composite an observable on your own.
	     */
	    UserGroupService.prototype.list$ = function (filter, options) {
	        if (filter === void 0) { filter = {}; }
	        if (options === void 0) { options = {}; }
	        return _super.prototype.list$.call(this, filter, options);
	    };
	    /**
	     * Removes user group.
	     *
	     * @param {number | IIdentified} entityOrId User group's id or user group object.
	     *
	     * @returns Returns promise object that is resolved with the IResult of null.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const userGroupId: number = 1;
	     *
	     *    (async () => {
	     *      const {data, res} = await userGroupService.delete(userGroupId);
	     *   })();
	     * ```
	     * When group is removed, suitable audit records are created with type 'User'
	     * and activity 'User updated' with information that user has been removed from group.
	     *
	     * Please, note that the ADMINS and DEVICES groups can not be deleted.
	     */
	    UserGroupService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Assign role to user group.
	     *
	     * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
	     * @param {string | Partial<ISource>} childEntityOrSelf Url to role resource or IRoleReference object.
	     *
	     * @returns Returns promise object that is resolved with the IRoleReference wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const userGroupId: number = 1;
	     *    const roleResource: string = "[URL to the Role resource]";
	     *
	     *    (async () => {
	     *      const {data, res} = await userGroupService.addRoleToGroup(userGroupId, roleResource);
	     *   })();
	     * ```
	     * When role is assigned to user, suitable audit record is created with type 'User' and activity 'User updated'.
	     */
	    UserGroupService.prototype.addRoleToGroup = function (entityOrId, childEntityOrSelf) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.addChild(ChildType.ROLES, entityOrId, childEntityOrSelf)];
	            });
	        });
	    };
	    /**
	     * Unassign role from user
	     *
	     * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
	     * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IRoleReference object.
	     *
	     * @returns Returns promise object that is resolved with the IResult of null.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const userGroupId: number = 1;
	     *    const userResource: string = "[URL to the Role resource]";
	     *
	     *    (async () => {
	     *      const {data, res} = await userGroupService.removeRoleFromGroup(userGroupId, userResource);
	     *   })();
	     * ```
	     */
	    UserGroupService.prototype.removeRoleFromGroup = function (entityOrId, childEntityOrSelf) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.removeChild(ChildType.ROLES, entityOrId, childEntityOrSelf)];
	            });
	        });
	    };
	    /**
	     * Assign user to user group.
	     *
	     * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
	     * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IUserReference object.
	     *
	     * @returns Returns promise object that is resolved with the IUserReference wrapped by IResult.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const userGroupId: number = 1;
	     *    const userResource: string = "[URL to the User resource]";
	     *
	     *    (async () => {
	     *      const {data, res} = await userGroupService.addUserToGroup(userGroupId, userResource);
	     *   })();
	     * ```
	     * When user is added to group, suitable audit record is created with type 'User' and activity 'User updated'.
	     */
	    UserGroupService.prototype.addUserToGroup = function (entityOrId, childEntityOrSelf) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.addChild(ChildType.USERS, entityOrId, childEntityOrSelf)];
	            });
	        });
	    };
	    /**
	     * Remove user from a group
	     *
	     * @param {string | number | Partial<IUserGroup>} entityOrId User group's id or user group object.
	     * @param {string | Partial<ISource>} childEntityOrSelf Url to user resource or IUserReference object.
	     *
	     * @returns Returns promise object that is resolved with the IResult of null.
	     *
	     * @example
	     * ```typescript
	     *
	     *    const userGroupId: number = 1;
	     *    const userResource: string = "[URL to the User resource]";
	     *
	     *    (async () => {
	     *      const {data, res} = await userGroupService.removeUserFromGroup(userGroupId, userResource);
	     *   })();
	     * ```
	     * When user is removed from group, suitable audit record is created with type 'User' and activity 'User updated'.
	     */
	    UserGroupService.prototype.removeUserFromGroup = function (entityOrId, childEntityOrSelf) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, this.removeChild(ChildType.USERS, entityOrId, childEntityOrSelf)];
	            });
	        });
	    };
	    UserGroupService.prototype.getSelf = function (childReference) {
	        if (typeof childReference === 'object' && childReference.self) {
	            return childReference.self;
	        }
	        else {
	            return childReference;
	        }
	    };
	    UserGroupService.prototype.getChildUrl = function (type, userGroupOrId) {
	        return this.getDetailUrl(userGroupOrId) + "/" + type;
	    };
	    UserGroupService.prototype.getChildReferenceAsBody = function (type, childReference) {
	        var childSelf = this.getSelf(childReference);
	        switch (type) {
	            case ChildType.ROLES:
	                return JSON.stringify({ role: { self: String(childSelf) } });
	            case ChildType.USERS:
	                return JSON.stringify({ user: { self: String(childSelf) } });
	        }
	        throw new Error('UserGroupService -> getChild -> unsupported child type');
	    };
	    UserGroupService.prototype.addChild = function (type, userGroupOrId, childReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            var url, method, body, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        url = this.getChildUrl(type, userGroupOrId);
	                        method = 'POST';
	                        body = this.getChildReferenceAsBody(type, childReference);
	                        headers = {
	                            accept: 'application/json',
	                            'content-type': 'application/json'
	                        };
	                        return [4 /*yield*/, this.fetch(url, { method: method, body: body, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        data = data.managedObject;
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    UserGroupService.prototype.removeChild = function (type, userGroupOrId, childReference) {
	        return __awaiter(this, void 0, void 0, function () {
	            var childId, url, method, headers, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        childId = this.getIdString(childReference);
	                        url = this.getChildUrl(type, userGroupOrId) + "/" + encodeURIComponent(String(childId));
	                        method = 'DELETE';
	                        headers = { accept: 'application/json' };
	                        return [4 /*yield*/, this.fetch(url, { method: method, headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        data = null;
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    return UserGroupService;
	}(core.Service));
	exports.UserGroupService = UserGroupService;

	});

	unwrapExports(UserGroupService_1);
	UserGroupService_1.UserGroupService;

	var userGroup = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(UserGroupService_1);

	});

	unwrapExports(userGroup);

	var IdentityService_1 = createCommonjsModule(function (module, exports) {
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * This class allwos for managing external identifiers.
	 */
	var IdentityService = /** @class */ (function () {
	    function IdentityService(client) {
	        this.baseUrl = 'identity';
	        this.propertyName = 'externalIds';
	        this.client = client;
	    }
	    /**
	     * Gets the list of identities filtered by parameters.
	     *
	     * @returns Response wrapped in [[IResultList]]
	     *
	     * @param {object} filter Object containing filters for querying identity.
	     *
	     * @example
	     * ```typescript
	     *
	     *  const filter: object = {
	     *     pageSize: 100,
	     *     withTotalPages: true
	     *   };
	     *
	     *   (async () => {
	     *     const {data, res, paging} = await identityService.list(filter);
	     *   })();
	     * ```
	     */
	    IdentityService.prototype.list = function (managedObjectId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, url, res, json, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { accept: 'application/json' };
	                        url = this.getExternalIdsOfGlobalIdUrl(managedObjectId);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        json = _a.sent();
	                        data = json[this.propertyName];
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Creates a new identity.
	     *
	     * @param {IExternalIdentity} identity Identity object with mandantory fragments.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *   const linkedManagedObjectId = '123';
	     *   const identity: IExternalIdentity = {
	     *      type: 'type',
	     *      externalId: '1',
	     *      managedObject: {
	     *        id: linkedManagedObjectId
	     *      }
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res} = await identityService.create(identity);
	     *   })();
	     * ```
	     */
	    IdentityService.prototype.create = function (identity) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, method, body, url, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { 'content-type': 'application/json', accept: 'application/json' };
	                        method = 'POST';
	                        body = JSON.stringify(identity);
	                        url = this.getExternalIdsOfGlobalIdUrl(identity.managedObject.id);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method, body: body })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Gets the details of an identity.
	     *
	     * @param {IExternalIdentity} identity Identity object with mandantory fragments.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const identity: IExternalIdentity = {
	     *      type: 'type',
	     *      externalId: '1'
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res} = await identityService.detail(identity);
	     *   })();
	     * ```
	     */
	    IdentityService.prototype.detail = function (identity) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, url, res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { accept: 'application/json' };
	                        url = this.getExternalIdUrl(identity);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers })];
	                    case 1:
	                        res = _a.sent();
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        data = _a.sent();
	                        return [2 /*return*/, { res: res, data: data }];
	                }
	            });
	        });
	    };
	    /**
	     * Removes an identity with given id.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {IExternalIdentity} identity Identity object with mandantory fragments.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const identity: IExternalIdentity = {
	     *      type: 'type',
	     *      externalId: '1'
	     *    };
	     *
	     *    (async () => {
	     *      const {data, res} = await identityService.delete(identity);
	     *   })();
	     * ```
	     */
	    IdentityService.prototype.delete = function (identity) {
	        return __awaiter(this, void 0, void 0, function () {
	            var headers, method, url, res;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        headers = { accept: 'application/json' };
	                        method = 'DELETE';
	                        url = this.getExternalIdUrl(identity);
	                        return [4 /*yield*/, this.fetch(url, { headers: headers, method: method })];
	                    case 1:
	                        res = _a.sent();
	                        return [2 /*return*/, { res: res, data: null }];
	                }
	            });
	        });
	    };
	    IdentityService.prototype.fetch = function (url, init) {
	        return __awaiter(this, void 0, void 0, function () {
	            var res, data;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.client.fetch(url, init)];
	                    case 1:
	                        res = _a.sent();
	                        if (!(res.status >= 400)) return [3 /*break*/, 10];
	                        data = null;
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 4, , 9]);
	                        return [4 /*yield*/, res.json()];
	                    case 3:
	                        data = _a.sent();
	                        return [3 /*break*/, 9];
	                    case 4:
	                        _a.sent();
	                        _a.label = 5;
	                    case 5:
	                        _a.trys.push([5, 7, , 8]);
	                        return [4 /*yield*/, res.text()];
	                    case 6:
	                        data = _a.sent();
	                        return [3 /*break*/, 8];
	                    case 7:
	                        _a.sent();
	                        return [3 /*break*/, 8];
	                    case 8: return [3 /*break*/, 9];
	                    case 9: throw { res: res, data: data };
	                    case 10: return [2 /*return*/, res];
	                }
	            });
	        });
	    };
	    IdentityService.prototype.getExternalIdsOfGlobalIdUrl = function (managedObjectId) {
	        return "/" + this.baseUrl + "/globalIds/" + managedObjectId + "/externalIds";
	    };
	    IdentityService.prototype.getExternalIdUrl = function (identity) {
	        return "/" + this.baseUrl + "/externalIds/" + identity.type + "/" + identity.externalId;
	    };
	    return IdentityService;
	}());
	exports.IdentityService = IdentityService;

	});

	unwrapExports(IdentityService_1);
	IdentityService_1.IdentityService;

	var identity$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(IdentityService_1);

	});

	unwrapExports(identity$1);

	var TrustedCertificateService_1 = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * This class allows for managing trusted certificates.
	 */
	var TrustedCertificateService = /** @class */ (function (_super) {
	    __extends(TrustedCertificateService, _super);
	    function TrustedCertificateService() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.listUrl = 'trusted-certificates';
	        _this.propertyName = 'certificates';
	        return _this;
	    }
	    Object.defineProperty(TrustedCertificateService.prototype, "baseUrl", {
	        get: function () {
	            return "/tenant/tenants/" + this.client.tenant;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Gets a list of trusted certificates.
	     *
	     * @returns Response wrapped in [[IResultList]].
	     *
	     * @example
	     * ```typescript
	     *
	     *   (async () => {
	     *     const {data, res} = await trustedCertificateService.list();
	     *   })();
	     * ```
	     */
	    TrustedCertificateService.prototype.list = function (filter) {
	        if (filter === void 0) { filter = {}; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.list.call(this, filter)];
	            });
	        });
	    };
	    /**
	     * Gets the details of trusted certificate
	     *
	     * @param {string | ITrustedCertificate} entityOrId Trusted certificate object or trusted certificate fingerprint.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *    const fingerprint: string = 'abc';
	     *
	     *    (async () => {
	     *      const {data, res} = await trustedCertificateService.detail(fingerprint);
	     *   })();
	     * ```
	     */
	    TrustedCertificateService.prototype.detail = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.detail.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Removes a trusted certificate with given fingerprint.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @param {string | ITrustedCertificate} entityOrId Trusted certificate object or trusted certificate fingerprint.
	     *
	     * @example
	     * ```typescript
	     *
	     *   const fingerprint: string = 'abc';
	     *
	     *    (async () => {
	     *      const {data, res} = await trustedCertificateService.delete(fingerprint);
	     *   })();
	     * ```
	     */
	    TrustedCertificateService.prototype.delete = function (entityOrId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.delete.call(this, entityOrId)];
	            });
	        });
	    };
	    /**
	     * Updates trusted certificate data.
	     *
	     * @param entity Trusted certificate partial object.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const certificate: Partial<ITrustedCertificate> = {
	     *    name: 'Name'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await trustedCertificateService.update(certificate);
	     *  })();
	     * ```
	     */
	    TrustedCertificateService.prototype.update = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.update.call(this, entity)];
	            });
	        });
	    };
	    /**
	     * Creates a new trusted certificate.
	     *
	     * @param {Partial<ITrustedCertificate>} Trusted certificate object.
	     *
	     * @returns Response wrapped in [[IResult]]
	     *
	     * @example
	     * ```typescript
	     *
	     *  const certificate: Partial<ITrustedCertificate> = {
	     *    name: 'Name',
	     *    certInPemFormat: 'MIID+DCCAuCgAwIBAgIJAO1Q9t/M9gYlMA0GC...',
	     *    status: 'ENABLED'
	     *  };
	     *
	     *  (async () => {
	     *    const {data, res} = await trustedCertificateService.create(certificate);
	     *  })();
	     * ```
	     */
	    TrustedCertificateService.prototype.create = function (entity) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                return [2 /*return*/, _super.prototype.create.call(this, entity)];
	            });
	        });
	    };
	    TrustedCertificateService.prototype.getDetailUrl = function (entityOrId) {
	        var id;
	        if (typeof entityOrId === 'object' && entityOrId.fingerprint) {
	            id = entityOrId.fingerprint;
	        }
	        else {
	            id = entityOrId;
	        }
	        return this.listUrl + "/" + id;
	    };
	    return TrustedCertificateService;
	}(core.Service));
	exports.TrustedCertificateService = TrustedCertificateService;

	});

	unwrapExports(TrustedCertificateService_1);
	TrustedCertificateService_1.TrustedCertificateService;

	var trustedCertificates = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(TrustedCertificateService_1);

	});

	unwrapExports(trustedCertificates);

	var services = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.FetchClient = core.FetchClient;
	exports.BasicAuth = core.BasicAuth;

	exports.EventService = event.EventService;
	exports.EventBinaryService = event.EventBinaryService;

	exports.InventoryService = inventory.InventoryService;
	exports.InventoryBinaryService = inventory.InventoryBinaryService;

	exports.MeasurementService = measurement.MeasurementService;

	exports.AlarmService = alarm.AlarmService;

	exports.OperationBulkService = operation.OperationBulkService;
	exports.OperationService = operation.OperationService;

	exports.ApplicationService = application.ApplicationService;

	exports.UserService = user.UserService;

	exports.TenantService = tenant.TenantService;

	exports.SystemOptionsService = systemOptions.SystemOptionsService;

	exports.TenantOptionsService = tenantOptions.TenantOptionsService;

	exports.TenantSecurityOptionsService = tenantSecurityOptions.TenantSecurityOptionsService;

	exports.TenantLoginOptionsService = tenantLoginOptions.TenantLoginOptionsService;

	exports.AuditService = audit$1.AuditService;

	exports.InventoryRoleService = inventoryRole.InventoryRoleService;

	exports.DeviceRegistrationService = deviceRegistration.DeviceRegistrationService;
	exports.DeviceRegistrationBulkService = deviceRegistration.DeviceRegistrationBulkService;

	exports.UserRoleService = userRole.UserRoleService;

	exports.UserGroupService = userGroup.UserGroupService;

	exports.Realtime = realtime.Realtime;

	exports.IdentityService = identity$1.IdentityService;

	exports.TrustedCertificateService = trustedCertificates.TrustedCertificateService;

	});

	unwrapExports(services);
	services.FetchClient;
	services.BasicAuth;
	services.EventService;
	services.EventBinaryService;
	services.InventoryService;
	services.InventoryBinaryService;
	services.MeasurementService;
	services.AlarmService;
	services.OperationBulkService;
	services.OperationService;
	services.ApplicationService;
	services.UserService;
	services.TenantService;
	services.SystemOptionsService;
	services.TenantOptionsService;
	services.TenantSecurityOptionsService;
	services.TenantLoginOptionsService;
	services.AuditService;
	services.InventoryRoleService;
	services.DeviceRegistrationService;
	services.DeviceRegistrationBulkService;
	services.UserRoleService;
	services.UserGroupService;
	services.Realtime;
	services.IdentityService;
	services.TrustedCertificateService;

	var Client_1 = createCommonjsModule(function (module, exports) {
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });


	var Client = /** @class */ (function () {
	    /**
	     * Initializes a new Client, which allows to request data from the API. Differently
	     * to Client.authenticate([...]) it needs a tenant given and does not verify if the
	     * login is correct.
	     *
	     * @example
	     * ```typescript
	     *
	     * const auth = new BasicAuth({
	     *   user: 'youruser',
	     *   password: 'yourpassword',
	     *   tenant: 'acme'
	     * }); // use CookieAuth() if your platform uses oauth (only in browser!)
	     *
	     * const baseUrl = 'https://acme.cumulocity.com';
	     * const client = new Client(auth, baseUrl);
	     * (async () => {
	     *   const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });
	     * })();
	     * ```
	     *
	     * @param auth The Authentication strategy to use (e.g. new BasicAuth())
	     * @param baseUrl The URL to request (optional in browser, mandatory in node)
	     */
	    function Client(auth, baseUrl) {
	        var client = new services.FetchClient(auth, baseUrl);
	        this.realtime = new realtime.Realtime(client);
	        this.alarm = new services.AlarmService(client, this.realtime);
	        this.application = new services.ApplicationService(client, this.realtime);
	        this.audit = new services.AuditService(client);
	        this.core = client;
	        this.deviceRegistration = new services.DeviceRegistrationService(client);
	        this.deviceRegistrationBulk = new services.DeviceRegistrationBulkService(client);
	        this.event = new services.EventService(client, this.realtime);
	        this.inventory = new services.InventoryService(client, this.realtime);
	        this.inventoryBinary = new services.InventoryBinaryService(client);
	        this.inventoryRole = new services.InventoryRoleService(client);
	        this.measurement = new services.MeasurementService(client, this.realtime);
	        this.operation = new services.OperationService(client);
	        this.operationBulk = new services.OperationBulkService(client);
	        this.options = {
	            security: new services.TenantSecurityOptionsService(client),
	            system: new services.SystemOptionsService(client),
	            login: new services.TenantLoginOptionsService(client),
	            tenant: new services.TenantOptionsService(client),
	        };
	        this.role = new services.InventoryRoleService(client);
	        this.tenant = new services.TenantService(client);
	        this.user = new services.UserService(client);
	        this.userGroup = new services.UserGroupService(client);
	        this.userRole = new services.UserRoleService(client);
	        this.identity = new services.IdentityService(client);
	    }
	    /**
	     * Authenticates the given user. Determines the tenant by itself via a call to tenant/currentTenant.
	     *
	     * @example
	     * ```typescript
	     *
	     * let client: Client;
	     * (async () => {
	     *  client = await Client.authenticate({
	     *    user: 'testuser',
	     *    password: 'password1337!'
	     *  }, 'https://acme.cumulocity.com');
	     *
	     *  //you have access to the client api now
	     *  const { data, paging, res }); =  await client.inventory.list({ pageSize: 100 });
	     * })();
	     * ```
	     */
	    Client.authenticate = function (credentials, baseUrl) {
	        return __awaiter(this, void 0, void 0, function () {
	            var auth, clientCore, res, name, client;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        auth = new services.BasicAuth(credentials);
	                        clientCore = new services.FetchClient(auth, baseUrl);
	                        return [4 /*yield*/, clientCore.fetch('/tenant/currentTenant', { method: 'GET' })];
	                    case 1:
	                        res = _a.sent();
	                        if (res.status !== 200) {
	                            throw { res: res };
	                        }
	                        return [4 /*yield*/, res.json()];
	                    case 2:
	                        name = (_a.sent()).name;
	                        client = new Client(auth, baseUrl);
	                        client.core.tenant = name;
	                        return [2 /*return*/, client];
	                }
	            });
	        });
	    };
	    /**
	     * Allows to use http to register a device on the platform.
	     *
	     * @deprecated Please use MQTT to bootstrap a device.
	     */
	    Client.deviceBootstrap = function (options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var deviceId, timeout, baseUrl, basicAuthToken, expire, clientCore, deviceRegistration, client, data, username, password, tenantId, auth, error_1, retry;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        deviceId = options.deviceId, timeout = options.timeout, baseUrl = options.baseUrl, basicAuthToken = options.basicAuthToken;
	                        expire = options.expire;
	                        if (timeout && !expire) {
	                            expire = Date.now() + timeout;
	                        }
	                        clientCore = new services.FetchClient(undefined, baseUrl);
	                        deviceRegistration = new services.DeviceRegistrationService(clientCore);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, deviceRegistration.bootstrap(deviceId, { basicAuthToken: basicAuthToken })];
	                    case 2:
	                        data = (_a.sent()).data;
	                        username = data.username, password = data.password, tenantId = data.tenantId;
	                        auth = new services.BasicAuth({ user: username, tenant: tenantId, password: password });
	                        client = new Client(auth, baseUrl);
	                        client.core.tenant = tenantId;
	                        return [3 /*break*/, 4];
	                    case 3:
	                        error_1 = _a.sent();
	                        retry = (!expire || Date.now() < expire) && error_1.res.status === 404;
	                        if (retry) {
	                            return [2 /*return*/, Client.deviceBootstrap(Object.assign({ expire: expire }, options))];
	                        }
	                        else {
	                            throw error_1;
	                        }
	                    case 4: return [2 /*return*/, client];
	                }
	            });
	        });
	    };
	    /**
	     * Allows to change the current Authentication
	     * @param auth The new Authentication information.
	     */
	    Client.prototype.setAuth = function (auth) {
	        this.core.setAuth(auth);
	        this.realtime.disconnect();
	    };
	    return Client;
	}());
	exports.Client = Client;

	});

	unwrapExports(Client_1);
	Client_1.Client;

	var public_api = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var cross_fetch_1 = __importDefault(browserPonyfill);
	__export(Client_1);
	__export(alarm);
	__export(application);
	__export(audit$1);
	__export(core);
	__export(trustedCertificates);
	__export(deviceRegistration);
	__export(event);
	__export(identity$1);
	__export(inventory);
	__export(inventoryRole);
	__export(measurement);
	__export(operation);
	__export(realtime);
	__export(systemOptions);
	__export(tenant);
	__export(tenantOptions);
	__export(tenantSecurityOptions);
	__export(tenantLoginOptions);
	__export(user);
	__export(userGroup);
	__export(userRole);
	function polyfillFetch() {
	    if (!window.fetch) {
	        window.fetch = cross_fetch_1.default;
	    }
	}
	exports.polyfillFetch = polyfillFetch;

	});

	unwrapExports(public_api);
	public_api.polyfillFetch;

	var esm5 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(public_api);

	});

	var index$21 = unwrapExports(esm5);

	var thingsCloudClient = createCommonjsModule$1(function (module, exports) {
	var __awaiter = (commonjsGlobal$1 && commonjsGlobal$1.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal$1 && commonjsGlobal$1.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ThingsCloudClient = void 0;

	var ThingsCloudClient = /** @class */ (function () {
	    /**
	     * Things Cloudのデータを取得する
	     * @class
	     * @param {FetchClient} deviceId deviceId or groupId
	     *
	     *
	     */
	    function ThingsCloudClient(fetchClient) {
	        this.fetchClient = fetchClient;
	        this.measurementService = new index$21.MeasurementService(fetchClient);
	        this.alarmService = new index$21.AlarmService(fetchClient);
	        this.eventService = new index$21.EventService(fetchClient);
	        this.inventoryService = new index$21.InventoryService(fetchClient);
	        this.realtime = new index$21.Realtime(fetchClient);
	    }
	    /**
	     * Things Cloud に接続し、Alarm 一覧を取得する
	     *
	     * @param {object} param
	     *
	     * @returns Promise<IResultList<IAlarm>>
	     *
	     * @example
	     * ```typescript
	     *
	     *     const alarmsFilter = {
	     *        deviceId: "123456",
	     *        filter: {
	     *          pageSize: 10,
	     *          type: "c8y_UnavailabilityAlarm"
	     *        }
	     *     };
	     *
	     *    (async () => {
	     *       const alarms = await thingsCloudClient.getAlarms(alarmsFilter);
	     *    })();
	     * ```
	     */
	    ThingsCloudClient.prototype.getAlarms = function (param) {
	        return __awaiter(this, void 0, void 0, function () {
	            var requestFilter;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        requestFilter = (param.filter) ? JSON.parse(JSON.stringify(param.filter)) : {};
	                        if (param.deviceId) {
	                            requestFilter.source = param.deviceId;
	                        }
	                        requestFilter.withTotalPages = true;
	                        return [4 /*yield*/, this.alarmService.list(requestFilter)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Things Cloud に接続し、Event 一覧を取得する
	     *
	     * @param {object} param
	     *
	     * @returns Promise<IResultList<IEvent>>
	     *
	     * @example
	     * ```typescript
	     *
	     *     const eventsFilter = {
	     *        deviceId: "123456",
	     *        filter: {
	     *          pageSize: 10,
	     *          type: "c8y_LocationUpdate"
	     *        }
	     *     };
	     *
	     *    (async () => {
	     *       const events = await thingsCloudClient.getEvents(eventsFilter);
	     *    })();
	     * ```
	     */
	    ThingsCloudClient.prototype.getEvents = function (param) {
	        return __awaiter(this, void 0, void 0, function () {
	            var requestFilter;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        requestFilter = (param.filter) ? JSON.parse(JSON.stringify(param.filter)) : {};
	                        if (param.deviceId) {
	                            requestFilter.source = param.deviceId;
	                        }
	                        requestFilter.withTotalPages = true;
	                        return [4 /*yield*/, this.eventService.list(requestFilter)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Things Cloud に接続し、Measurement 一覧を取得する
	     *
	     * @param {object} param
	     *
	     * @returns Promise<IResultList<IMeasurement>>
	     *
	     * @example
	     * ```typescript
	     *
	     *     const measurementsFilter = {
	     *        deviceId: "123456",
	     *        filter: {
	     *          pageSize: 10,
	     *          valueFragmentType: "c8y_Temperature"
	     *        }
	     *     };
	     *
	     *    (async () => {
	     *       const measurements = await thingsCloudClient.getMeasurements(measurementsFilter);
	     *    })();
	     * ```
	     */
	    ThingsCloudClient.prototype.getMeasurements = function (param) {
	        return __awaiter(this, void 0, void 0, function () {
	            var requestFilter;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        requestFilter = (param.filter) ? JSON.parse(JSON.stringify(param.filter)) : {};
	                        if (param.deviceId) {
	                            requestFilter.source = param.deviceId;
	                        }
	                        return [4 /*yield*/, this.measurementService.list(requestFilter)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * MO ID に対し、サブアセット（ManagedObject の ID）を取得する。
	     * ID がデバイスの場合、単独のデバイスが設定され、アセットの場合、再帰的に
	     * 子アセットのデバイスが設定される。
	     *
	     * @param {string} moId MO ID
	     *
	     * @returns Promise デバイスIDの配列
	     *
	     * @example
	     * ```typescript
	     *
	     *     const moId = "123456";
	     *
	     *    (async () => {
	     *       const moIds = await thingsCloudClient.getSubAssets(moId);
	     *    })();
	     * ```
	     */
	    ThingsCloudClient.prototype.getSubAssets = function (moId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var mos;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.getSubAssetMOs(moId)];
	                    case 1:
	                        mos = _a.sent();
	                        return [2 /*return*/, mos.map(function (mo) { return mo.id; })];
	                }
	            });
	        });
	    };
	    /**
	     * MO ID に対し、サブアセット（ManagedObject）を取得する。
	     * ID がデバイスの場合、単独のデバイスが設定され、アセットの場合、再帰的に
	     * 子アセットのデバイスが設定される。
	     *
	     * @param {string} moId MO ID
	     *
	     * @returns Promise デバイス ManagedObject の配列
	     *
	     * @example
	     * ```typescript
	     *
	     *     const moId = "123456";
	     *
	     *    (async () => {
	     *       const mos = await thingsCloudClient.getSubAssetMOs(moId);
	     *    })();
	     * ```
	     */
	    ThingsCloudClient.prototype.getSubAssetMOs = function (moId) {
	        return __awaiter(this, void 0, void 0, function () {
	            var devices;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        devices = [];
	                        return [4 /*yield*/, this.getSubAssetMOsImpl(moId, devices)];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/, devices];
	                }
	            });
	        });
	    };
	    /**
	     * リアルタイムにイベント等を取得するための Realtime オブジェクトを取得する
	     *
	     * @returns Realtime のインスタンス
	     */
	    ThingsCloudClient.prototype.getRealtime = function () {
	        return this.realtime;
	    };
	    /**
	     * リアルタイム通知のチャネル監視を解除する
	     *
	     * @param subscription チャネル監視中のサブスクリプション
	     */
	    ThingsCloudClient.prototype.unsubscribeRealtime = function (subscription) {
	        this.realtime.unsubscribe(subscription);
	    };
	    /**
	     * デバイスかグループを判断し、デバイスの場合はdevicesへpush、
	     * グループの場合は再帰的に関数を呼び出す。
	     *
	     * @param {string} moId moId
	     * @param {IManagedObject} devices デバイス情報のリスト
	     *
	     * @returns Promise<void>
	     */
	    ThingsCloudClient.prototype.getSubAssetMOsImpl = function (moId, devices) {
	        return __awaiter(this, void 0, void 0, function () {
	            var res, _i, _a, data;
	            return __generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0: return [4 /*yield*/, this.inventoryService.detail(moId)];
	                    case 1:
	                        res = _b.sent();
	                        if (!(res.data.childAssets.references.length > 0)) return [3 /*break*/, 6];
	                        _i = 0, _a = res.data.childAssets.references;
	                        _b.label = 2;
	                    case 2:
	                        if (!(_i < _a.length)) return [3 /*break*/, 5];
	                        data = _a[_i];
	                        return [4 /*yield*/, this.getSubAssetMOsImpl(data.managedObject.id, devices)];
	                    case 3:
	                        _b.sent(); // 再帰
	                        _b.label = 4;
	                    case 4:
	                        _i++;
	                        return [3 /*break*/, 2];
	                    case 5: return [3 /*break*/, 7];
	                    case 6:
	                        // 指定されたのはデバイス
	                        if (devices.map(function (mo) { return mo.id; }).indexOf(res.data.id) > -1)
	                            return [2 /*return*/];
	                        devices.push(res.data);
	                        _b.label = 7;
	                    case 7: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    return ThingsCloudClient;
	}());
	exports.ThingsCloudClient = ThingsCloudClient;
	});

	unwrapExports$1(thingsCloudClient);
	thingsCloudClient.ThingsCloudClient;

	var thingsCloudDataSupplier = createCommonjsModule$1(function (module, exports) {
	var __awaiter = (commonjsGlobal$1 && commonjsGlobal$1.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal$1 && commonjsGlobal$1.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ThingsCloudDataSupplier = void 0;


	var ThingsCloudDataSupplier = /** @class */ (function () {
	    /**
	     * ThingsCloudDataSupplierクラスのコンストラクタです。
	     * 各メソッドでThingsCloudの対象テナントからデータを取得し、そのデータをフラット化して返却します。
	     *
	     * @class
	     *
	     * @param {baseUrl} baseUrl 情報を取得するテナントのURL
	     * @param {user} user 情報を取得するための認証情報(ユーザ名)
	     * @param {password} password 情報を取得するための認証情報(パスワード)
	     *
	     * @desc
	     * *フラット化について*
	     * このクラスでは、各メソッドで結果がフラット化され返却されます。例えば、データを取得した結果が
	     * ```json
	     * [
	     *   {
	     *     "c8y_Temperature": {
	     *       "T": {
	     *         "value": 18.0,
	     *         "unit": "C"
	     *       }
	     *     }
	     *   },
	     *   :
	     * ]
	     * ```
	     * のような JSON 構造だった場合、
	     * ```json
	     * [
	     *   {
	     *     "c8y_Temperature_T_value": 18.0,
	     *     "c8y_Temperature_T_unit": "C"
	     *   },
	     *   :
	     * ]
	     * ```
	     * のような形式の変換がなされます。
	     * このようなデータ形式の変換操作をフラット化と呼びます。
	     */
	    function ThingsCloudDataSupplier(fetchClient) {
	        this.thingsCloudClient = new thingsCloudClient.ThingsCloudClient(fetchClient);
	    }
	    /**
	     * deviceId, measurementsFilterで指定されたデバイスのMeasurement情報を
	     * 取得し、フラット化された(階層的なオブジェクト構造があった場合、ルートに設定した)
	     * オブジェクトの配列として返却します。
	     *
	     * @param {string} deviceId deviceId or groupId (groupId を指定した場合、再帰的に子のデバイスが検索され、対象となります。)
	     * @param {object} measurementsFilter Measurement のフィルタ条件を指定する情報
	     *
	     * @returns Measurement配列で解決する Promise
	     * @example
	     * ```typescript
	     * async () => {
	     *   :
	     *   // thingsCloudDataSupplier にインスタンスを格納
	     *   :
	     *   const measurements = await thingsCloudDataSupplier.getMeasurementsArray('123456', {
	     *     type: 'c8y_TemperatureMeasurement',
	     *     dateFrom: '2022-02-01T00:00:00.000+09:00',
	     *     dateTo: '2022-02-28T23:59:59.999+09:00'
	     *   });
	     * }
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.getMeasurementsArray = function (deviceId, measurementsFilter) {
	        return __awaiter(this, void 0, void 0, function () {
	            var flattenOption, deviceIds, measurements, promises, measurementsList;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        flattenOption = measurementsFilter.flatten;
	                        delete measurementsFilter.flatten;
	                        return [4 /*yield*/, this.thingsCloudClient.getSubAssets(deviceId)];
	                    case 1:
	                        deviceIds = _a.sent();
	                        measurements = [];
	                        promises = deviceIds.map(function (deviceId) { return __awaiter(_this, void 0, void 0, function () {
	                            return __generator(this, function (_a) {
	                                switch (_a.label) {
	                                    case 0: return [4 /*yield*/, this.thingsCloudClient.getMeasurements({ deviceId: deviceId, filter: measurementsFilter })];
	                                    case 1: return [2 /*return*/, (_a.sent()).data];
	                                }
	                            });
	                        }); });
	                        return [4 /*yield*/, Promise.all(promises)];
	                    case 2:
	                        measurementsList = _a.sent();
	                        measurementsList.forEach(function (result) {
	                            measurements = measurements.concat(result);
	                        });
	                        if (flattenOption || flattenOption === void 0)
	                            measurements = this.flatten(measurements);
	                        measurements.forEach(function (f) { return f.time = new Date(f.time); });
	                        return [2 /*return*/, measurements];
	                }
	            });
	        });
	    };
	    /**
	     * deviceId, alarmsFilterで指定されたデバイスのAlarm情報を
	     * 取得し、フラット化された(階層的なオブジェクト構造があった場合、ルートに設定した)
	     * オブジェクトの配列として返却します。
	     *
	     * @param {string} deviceId deviceId or groupId (groupId を指定した場合、再帰的に子のデバイスが検索され、対象となります。)
	     * @param {object} alarmsFilter Alarm のフィルタ条件を指定する情報
	     *
	     * @returns Alarm配列で解決する Promise
	     * @example
	     * ```typescript
	     * async () => {
	     *   :
	     *   // thingsCloudDataSupplier にインスタンスを格納
	     *   :
	     *   const alarms = await thingsCloudDataSupplier.getAlarmsArray('123456', {
	     *     type: 'c8y_UnavailabilityAlarm',
	     *     dateFrom: '2022-02-01T00:00:00.000+09:00',
	     *     dateTo: '2022-02-28T23:59:59.999+09:00',
	     *     status: 'CLEARED'
	     *   });
	     * }
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.getAlarmsArray = function (deviceId, alarmsFilter) {
	        return __awaiter(this, void 0, void 0, function () {
	            var flattenOption, deviceIds, alarms, promises, alarmsList;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        flattenOption = alarmsFilter.flatten;
	                        delete alarmsFilter.flatten;
	                        return [4 /*yield*/, this.thingsCloudClient.getSubAssets(deviceId)];
	                    case 1:
	                        deviceIds = _a.sent();
	                        alarms = [];
	                        promises = deviceIds.map(function (deviceId) { return __awaiter(_this, void 0, void 0, function () {
	                            return __generator(this, function (_a) {
	                                switch (_a.label) {
	                                    case 0: return [4 /*yield*/, this.thingsCloudClient.getAlarms({ deviceId: deviceId, filter: alarmsFilter })];
	                                    case 1: return [2 /*return*/, (_a.sent()).data];
	                                }
	                            });
	                        }); });
	                        return [4 /*yield*/, Promise.all(promises)];
	                    case 2:
	                        alarmsList = _a.sent();
	                        alarmsList.forEach(function (result) {
	                            alarms = alarms.concat(result);
	                        });
	                        if (flattenOption || flattenOption === void 0)
	                            alarms = this.flatten(alarms);
	                        // alarms.forEach(f => f.time = new Date(f.time)); IAlarm の time は string 
	                        return [2 /*return*/, alarms];
	                }
	            });
	        });
	    };
	    /**
	     * deviceId, eventsFilterで指定されたデバイスのEvent情報を
	     * 取得し、フラット化された(階層的なオブジェクト構造があった場合、ルートに設定した)
	     * オブジェクトの配列として返却します。
	     *
	     * @param {string} deviceId deviceId or groupId (groupId を指定した場合、再帰的に子のデバイスが検索され、対象となります。)
	     * @param {object} eventsFilter Event のフィルタ条件を指定する情報
	     *
	     * @returns Event配列で解決する Promise
	     * @example
	     * ```typescript
	     * async () => {
	     *   :
	     *   // thingsCloudDataSupplier にインスタンスを格納
	     *   :
	     *   const events = await thingsCloudDataSupplier.getEventsArray('123456', {
	     *     type: 'c8y_UpdateEvent',
	     *     dateFrom: '2022-02-01T00:00:00.000+09:00',
	     *     dateTo: '2022-02-28T23:59:59.999+09:00'
	     *   });
	     * }
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.getEventsArray = function (deviceId, eventsFilter) {
	        return __awaiter(this, void 0, void 0, function () {
	            var flattenOption, deviceIds, events, promises, eventsList;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        flattenOption = eventsFilter.flatten;
	                        delete eventsFilter.flatten;
	                        return [4 /*yield*/, this.thingsCloudClient.getSubAssets(deviceId)];
	                    case 1:
	                        deviceIds = _a.sent();
	                        events = [];
	                        promises = deviceIds.map(function (deviceId) { return __awaiter(_this, void 0, void 0, function () {
	                            return __generator(this, function (_a) {
	                                switch (_a.label) {
	                                    case 0: return [4 /*yield*/, this.thingsCloudClient.getEvents({ deviceId: deviceId, filter: eventsFilter })];
	                                    case 1: return [2 /*return*/, (_a.sent()).data];
	                                }
	                            });
	                        }); });
	                        return [4 /*yield*/, Promise.all(promises)];
	                    case 2:
	                        eventsList = _a.sent();
	                        eventsList.forEach(function (result) {
	                            events = events.concat(result);
	                        });
	                        if (flattenOption || flattenOption === void 0)
	                            events = this.flatten(events);
	                        // events.forEach(f => f.time = new Date(f.time)); IEvent の time は string
	                        return [2 /*return*/, events];
	                }
	            });
	        });
	    };
	    /**
	     * deviceIdで指定されたデバイスのMOリストをオブジェクトの配列として返却します
	     *
	     * @param {string} deviceId deviceId or groupId (groupId を指定した場合、再帰的に子のデバイスが検索され、対象となります。)
	     *
	     * @returns IManagedObject配列で解決する Promise
	     * @example
	     * ```typescript
	     *
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.getDevicesArray = function (deviceId) {
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.thingsCloudClient.getSubAssetMOs(deviceId)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * 対象のオブジェクトを監視し、メジャーメントのリアルタイム通知を受け取ります
	     *
	     * @param {string} target 監視対象オブジェクト deviceId or '*' (テナント内全てのデバイスが対象)
	     *
	     * @returns リアルタイム通知で受け取ったメジャーメント
	     * @example
	     * ```typescript
	     *    thingsCloudDataSupplier.getRealtimeMeasurement('12345')
	     *      .subscribe(notifiedData => {
	                updateData();
	     *      })
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.getRealtimeMeasurement = function (target) {
	        this.realtimeSubscription = this.thingsCloudClient.getRealtime();
	        var notified = new esm5$1.Subject();
	        this.realtimeSubscription.subscribe("/measurements/".concat(target), function (notifiedData) {
	            notified.next(notifiedData.data.data);
	        });
	        return notified;
	    };
	    /**
	     * 対象のオブジェクトを監視し、アラームのリアルタイム通知を受け取ります
	     *
	     * @param {string} target 監視対象オブジェクト deviceId or '*' (テナント内全てのデバイスが対象)
	     *
	     * @returns リアルタイム通知で受け取ったアラーム
	     * @example
	     * ```typescript
	     *    thingsCloudDataSupplier.getRealtimeAlarm('12345')
	     *      .subscribe(notifiedData => {
	     *         updateData();
	     *       })
	     *  ```
	     */
	    ThingsCloudDataSupplier.prototype.getRealtimeAlarm = function (target) {
	        this.realtimeSubscription = this.thingsCloudClient.getRealtime();
	        var notified = new esm5$1.Subject();
	        this.realtimeSubscription.subscribe("/alarms/".concat(target), function (notifiedData) {
	            notified.next(notifiedData.data.data);
	        });
	        return notified;
	    };
	    /**
	     * 対象のオブジェクトを監視し、イベントのリアルタイム通知を受け取ります
	     *
	     * @param {string} target 監視対象オブジェクト deviceId or '*' (テナント内全てのデバイスが対象)
	     *
	     * @returns リアルタイム通知で受け取ったイベント
	     * @example
	     * ```typescript
	     *    thingsCloudDataSupplier.getRealtimeEvent('12345')
	     *      .subscribe(notifiedData => {
	     *        updateData();
	     *      })
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.getRealtimeEvent = function (target) {
	        this.realtimeSubscription = this.thingsCloudClient.getRealtime();
	        var notified = new esm5$1.Subject();
	        this.realtimeSubscription.subscribe("/events/".concat(target), function (notifiedData) {
	            notified.next(notifiedData.data.data);
	        });
	        return notified;
	    };
	    /**
	     * 対象のオブジェクトを監視し、マネージドオブジェクトのリアルタイム通知を受け取ります
	     *
	     * @param {string} target 監視対象オブジェクト deviceId or '*' (テナント内全てのデバイスが対象)
	     *
	     * @returns リアルタイム通知で受け取ったマネージドオブジェクト
	     * @example
	     * ```typescript
	     *    thingsCloudDataSupplier.getRealtimeManagedObject('12345')
	     *      .subscribe(notifiedData => {
	                updateData();
	     *      })
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.getRealtimeManagedObject = function (target) {
	        this.realtimeSubscription = this.thingsCloudClient.getRealtime();
	        var notified = new esm5$1.Subject();
	        this.realtimeSubscription.subscribe("/managedobjects/".concat(target), function (notifiedData) {
	            notified.next(notifiedData.data.data);
	        });
	        return notified;
	    };
	    /**
	     * リアルタイム通知のチャネル監視を解除します
	     */
	    ThingsCloudDataSupplier.prototype.unsubscribeRealtime = function () {
	        this.thingsCloudClient.unsubscribeRealtime(this.realtimeSubscription);
	    };
	    /**
	     * 指定された object の配列に関し、各 object の階層を平坦化し 1 層に変換します。
	     * 例： [{a: 1, b: {c: 5}}] ---> [{a: 1, b_c: 5}]
	     * object 値に配列を含む場合、配列内の object は平坦化されないことに注意して下さい。
	     * 例： [{a: 1, b: [{c: 5}]}] ---> [{a: 1, b: [{c: 5}]}] (変更なし)
	     *
	     * @param objectArray object の配列
	     * @returns  各要素が平坦化(つなぎ文字は _)された object の配列(Plot で利用可能な形式)
	     * @example
	     * ```typescript
	     * :
	     * // thingsCloudDataSupplier にインスタンスを格納
	     * :
	     * const array = [{a: 1, b: {c: 5}}];
	     * const result = thingsCloudDataSupplier.flatten(array);
	     * console.log(result); // expected: [{a: 1, b_c: 5}]
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.flatten = function (objectArray) {
	        var _this = this;
	        objectArray.forEach(function (obj) { return _this.flattenImpl(obj, '', obj); });
	        return objectArray;
	    };
	    /**
	     * flatten の実処理を行います。parent のデータが平坦化され、上書きされます。
	     *
	     * @param parent flatten 先のデータを格納する object
	     * @param parentKey 階層化されたキー情報を連結したもの
	     * @param obj flatten 対象となる object (再帰により子オブジェクトが指定される)
	     * @example
	     * ```typescript
	     * :
	     * // thingsCloudDataSupplier にインスタンスを格納
	     * :
	     * const obj = {a: 1, b: {c: 5}};
	     * const result = thingsCloudDataSupplier._flatten(obj, '', obj);
	     * console.log(result); // expected: {a: 1, b_c: 5}
	     * ```
	     */
	    ThingsCloudDataSupplier.prototype.flattenImpl = function (parent, parentKey, obj) {
	        var _this = this;
	        var keys = Object.keys(obj);
	        if (keys.length == 0)
	            return;
	        if (parentKey)
	            delete parent[parentKey];
	        keys.forEach(function (key) {
	            var v = obj[key];
	            var ckey = parentKey + ((parentKey !== '') ? '_' : '') + key;
	            if (v !== null && typeof v === 'object' && !Array.isArray(v)) {
	                _this.flattenImpl(parent, ckey, v);
	            }
	            else {
	                if (parent !== obj) {
	                    parent[ckey] = v;
	                }
	            }
	        });
	    };
	    return ThingsCloudDataSupplier;
	}());
	exports.ThingsCloudDataSupplier = ThingsCloudDataSupplier;
	});

	unwrapExports$1(thingsCloudDataSupplier);
	thingsCloudDataSupplier.ThingsCloudDataSupplier;

	var src = createCommonjsModule$1(function (module, exports) {
	var __createBinding = (commonjsGlobal$1 && commonjsGlobal$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal$1 && commonjsGlobal$1.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(thingsCloudDataSupplier, exports);
	__exportStar(thingsCloudClient, exports);
	});

	var index = unwrapExports$1(src);

	return index;

}));
